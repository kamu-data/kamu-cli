// Copyright Kamu Data, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

use std::fmt::{self, Write};
use std::path::PathBuf;

use clap::CommandFactory;
use clap::builder::PossibleValue;

#[test_group::group(resourcegen)]
#[test_log::test(tokio::test)]
async fn generate_reference_markdown() {
    let command = kamu_cli::cli::Cli::command();
    let markdown = generate_markdown_for_command(&command);

    let mut docs_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    docs_path.push("../../../resources/cli-reference.md");

    let file_content = indoc::formatdoc!(
        "
        <!--
        THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

        To regenerate this schema from existing code, use the following command:
            make codegen-cli-reference
        -->

        {markdown}"
    );

    std::fs::write(&docs_path, file_content).unwrap();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Markdown generator
// Based on: https://github.com/ConnorGray/clap-markdown
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

fn generate_markdown_for_command(command: &clap::Command) -> String {
    let mut buffer = String::with_capacity(2048);
    write_help_markdown(&mut buffer, command);
    buffer
}

fn write_help_markdown(buffer: &mut String, command: &clap::Command) {
    // Write the commands/subcommands sections
    build_command_markdown(buffer, &[], command).unwrap();
}

fn build_command_markdown(
    buffer: &mut String,
    // Parent commands of `command`.
    parent_command_path: &[String],
    command: &clap::Command,
) -> std::fmt::Result {
    // Don't document commands marked with `clap(hide = true)` (which includes
    // `print-all-help`).
    if command.is_hide_set() {
        return Ok(());
    }

    // Append the name of `command` to `command_path`.
    let command_path = {
        let mut command_path = parent_command_path.to_owned();
        command_path.push(command.get_name().to_owned());
        command_path
    };

    // Write the markdown heading

    writeln!(buffer, "## `{}`\n", command_path.join(" "),)?;

    if let Some(long_about) = command.get_long_about() {
        writeln!(buffer, "{long_about}\n")?;
    } else if let Some(about) = command.get_about() {
        writeln!(buffer, "{about}\n")?;
    }

    writeln!(
        buffer,
        "**Usage:** `{}{}`\n",
        if parent_command_path.is_empty() {
            String::new()
        } else {
            let mut s = parent_command_path.join(" ");
            s.push(' ');
            s
        },
        command
            .clone()
            .render_usage()
            .to_string()
            .replace("Usage: ", "")
    )?;

    // Subcommands

    if command.get_subcommands().next().is_some() {
        writeln!(buffer, "**Subcommands:**\n")?;

        for subcommand in command.get_subcommands() {
            if subcommand.is_hide_set() {
                continue;
            }

            let aliases = subcommand.get_visible_aliases().collect::<Vec<_>>();

            writeln!(
                buffer,
                "* `{}{}` — {}",
                subcommand.get_name(),
                if aliases.is_empty() {
                    String::new()
                } else {
                    format!(" [{}]", aliases.join(","))
                },
                match subcommand.get_about() {
                    Some(about) => about.to_string(),
                    None => String::new(),
                },
            )?;
        }

        writeln!(buffer)?;
    }

    // Arguments

    if command.get_positionals().next().is_some() {
        writeln!(buffer, "**Arguments:**\n")?;

        for pos_arg in command.get_positionals() {
            if !pos_arg.is_hide_set() {
                write_arg_markdown(buffer, pos_arg)?;
            }
        }

        writeln!(buffer)?;
    }

    // Options

    let non_pos: Vec<_> = command
        .get_arguments()
        .filter(|arg| !arg.is_positional())
        .collect();

    if !non_pos.is_empty() {
        writeln!(buffer, "**Options:**\n")?;

        for arg in non_pos {
            if !arg.is_hide_set() {
                write_arg_markdown(buffer, arg)?;
            }
        }

        writeln!(buffer)?;
    }

    assert!(command.get_before_help().is_none());

    if let Some(after_help) = command.get_after_help() {
        writeln!(buffer, "{}\n", after_help.to_string().trim_start())?;
    }

    // Recurse to write subcommands

    // Include extra space between commands. This is purely for the benefit of
    // anyone reading the source .md file.
    write!(buffer, "\n\n")?;

    for subcommand in command.get_subcommands() {
        build_command_markdown(buffer, &command_path, subcommand)?;
    }

    Ok(())
}

fn write_arg_markdown(buffer: &mut String, arg: &clap::Arg) -> fmt::Result {
    // Markdown list item
    write!(buffer, "* ")?;

    let value_name: String = match arg.get_value_names() {
        // TODO: What if multiple names are provided?
        Some([name, ..]) => name.as_str().to_owned(),
        Some([]) => unreachable!("clap Arg::get_value_names() returned Some(..) of empty list"),
        None => arg.get_id().to_string().to_ascii_uppercase(),
    };

    match (arg.get_short(), arg.get_long()) {
        (Some(short), Some(long)) => {
            if arg.get_action().takes_values() {
                write!(buffer, "`-{short}`, `--{long} <{value_name}>`")?;
            } else {
                write!(buffer, "`-{short}`, `--{long}`")?;
            }
        }
        (Some(short), None) => {
            if arg.get_action().takes_values() {
                write!(buffer, "`-{short} <{value_name}>`")?;
            } else {
                write!(buffer, "`-{short}`")?;
            }
        }
        (None, Some(long)) => {
            if arg.get_action().takes_values() {
                write!(buffer, "`--{long} <{value_name}>`")?;
            } else {
                write!(buffer, "`--{long}`")?;
            }
        }
        (None, None) => {
            debug_assert!(
                arg.is_positional(),
                "unexpected non-positional Arg with neither short nor long name: {arg:?}"
            );

            write!(buffer, "`<{value_name}>`",)?;
        }
    }

    if let Some(help) = arg.get_help() {
        writeln!(buffer, " — {help}")?;
    } else {
        writeln!(buffer)?;
    }

    // Arg default values

    if !arg.get_default_values().is_empty() {
        let default_values: String = arg
            .get_default_values()
            .iter()
            .map(|value| format!("`{}`", value.to_string_lossy()))
            .collect::<Vec<String>>()
            .join(", ");

        if arg.get_default_values().len() > 1 {
            // Plural
            writeln!(buffer, "\n  Default values: {default_values}")?;
        } else {
            // Singular
            writeln!(buffer, "\n  Default value: {default_values}")?;
        }
    }

    // Arg possible values

    let possible_values: Vec<PossibleValue> = arg
        .get_possible_values()
        .into_iter()
        .filter(|pv| !pv.is_hide_set())
        .collect();

    let is_bool_flag = |pvals: &Vec<PossibleValue>| {
        pvals.len() == 2 && pvals[0].get_name() == "true" && pvals[1].get_name() == "false"
    };

    if !possible_values.is_empty() && !is_bool_flag(&possible_values) {
        let any_have_help: bool = possible_values.iter().any(|pv| pv.get_help().is_some());

        if any_have_help {
            // If any of the possible values have help text, print them
            // as a separate item in a bulleted list, and include the
            // help text for those that have it. E.g.:
            //
            //     Possible values:
            //     - `value1`: The help text
            //     - `value2`
            //     - `value3`: The help text

            let text: String = possible_values
                .iter()
                .map(|pv| match pv.get_help() {
                    Some(help) => {
                        format!("  - `{}`:\n    {}\n", pv.get_name(), help)
                    }
                    None => format!("  - `{}`\n", pv.get_name()),
                })
                .collect::<String>();

            writeln!(buffer, "\n  Possible values:\n{text}")?;
        } else {
            // If none of the possible values have any documentation, print
            // them all inline on a single line.
            let text: String = possible_values
                .iter()
                // TODO: Show PossibleValue::get_help(), and PossibleValue::get_name_and_aliases().
                .map(|pv| format!("`{}`", pv.get_name()))
                .collect::<Vec<String>>()
                .join(", ");

            writeln!(buffer, "\n  Possible values: {text}\n")?;
        }
    }

    Ok(())
}
