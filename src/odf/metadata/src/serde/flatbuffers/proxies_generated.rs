// Copyright Kamu Data, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

#![allow(clippy::all)]
#![allow(clippy::pedantic)]
// Generated with flatc=flatc version 24.12.23
// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_READ_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_READ_STEP: u8 = 7;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_READ_STEP: [ReadStep; 8] = [
    ReadStep::NONE,
    ReadStep::ReadStepCsv,
    ReadStep::ReadStepGeoJson,
    ReadStep::ReadStepEsriShapefile,
    ReadStep::ReadStepParquet,
    ReadStep::ReadStepJson,
    ReadStep::ReadStepNdJson,
    ReadStep::ReadStepNdGeoJson,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReadStep(pub u8);
#[allow(non_upper_case_globals)]
impl ReadStep {
    pub const NONE: Self = Self(0);
    pub const ReadStepCsv: Self = Self(1);
    pub const ReadStepGeoJson: Self = Self(2);
    pub const ReadStepEsriShapefile: Self = Self(3);
    pub const ReadStepParquet: Self = Self(4);
    pub const ReadStepJson: Self = Self(5);
    pub const ReadStepNdJson: Self = Self(6);
    pub const ReadStepNdGeoJson: Self = Self(7);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 7;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ReadStepCsv,
        Self::ReadStepGeoJson,
        Self::ReadStepEsriShapefile,
        Self::ReadStepParquet,
        Self::ReadStepJson,
        Self::ReadStepNdJson,
        Self::ReadStepNdGeoJson,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ReadStepCsv => Some("ReadStepCsv"),
            Self::ReadStepGeoJson => Some("ReadStepGeoJson"),
            Self::ReadStepEsriShapefile => Some("ReadStepEsriShapefile"),
            Self::ReadStepParquet => Some("ReadStepParquet"),
            Self::ReadStepJson => Some("ReadStepJson"),
            Self::ReadStepNdJson => Some("ReadStepNdJson"),
            Self::ReadStepNdGeoJson => Some("ReadStepNdGeoJson"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ReadStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ReadStep {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ReadStep {
    type Output = ReadStep;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ReadStep {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ReadStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ReadStep {}
pub struct ReadStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TRANSFORM: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TRANSFORM: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM: [Transform; 2] = [Transform::NONE, Transform::TransformSql];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Transform(pub u8);
#[allow(non_upper_case_globals)]
impl Transform {
    pub const NONE: Self = Self(0);
    pub const TransformSql: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TransformSql];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TransformSql => Some("TransformSql"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Transform {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Transform {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
pub struct TransformUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MERGE_STRATEGY: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MERGE_STRATEGY: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MERGE_STRATEGY: [MergeStrategy; 4] = [
    MergeStrategy::NONE,
    MergeStrategy::MergeStrategyAppend,
    MergeStrategy::MergeStrategyLedger,
    MergeStrategy::MergeStrategySnapshot,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MergeStrategy(pub u8);
#[allow(non_upper_case_globals)]
impl MergeStrategy {
    pub const NONE: Self = Self(0);
    pub const MergeStrategyAppend: Self = Self(1);
    pub const MergeStrategyLedger: Self = Self(2);
    pub const MergeStrategySnapshot: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MergeStrategyAppend,
        Self::MergeStrategyLedger,
        Self::MergeStrategySnapshot,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MergeStrategyAppend => Some("MergeStrategyAppend"),
            Self::MergeStrategyLedger => Some("MergeStrategyLedger"),
            Self::MergeStrategySnapshot => Some("MergeStrategySnapshot"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MergeStrategy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MergeStrategy {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MergeStrategy {
    type Output = MergeStrategy;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MergeStrategy {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MergeStrategy {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MergeStrategy {}
pub struct MergeStrategyUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ATTACHMENTS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ATTACHMENTS: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATTACHMENTS: [Attachments; 2] =
    [Attachments::NONE, Attachments::AttachmentsEmbedded];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Attachments(pub u8);
#[allow(non_upper_case_globals)]
impl Attachments {
    pub const NONE: Self = Self(0);
    pub const AttachmentsEmbedded: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::AttachmentsEmbedded];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::AttachmentsEmbedded => Some("AttachmentsEmbedded"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Attachments {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Attachments {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Attachments {
    type Output = Attachments;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Attachments {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Attachments {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Attachments {}
pub struct AttachmentsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COMPRESSION_FORMAT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COMPRESSION_FORMAT: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPRESSION_FORMAT: [CompressionFormat; 2] =
    [CompressionFormat::Gzip, CompressionFormat::Zip];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CompressionFormat(pub i32);
#[allow(non_upper_case_globals)]
impl CompressionFormat {
    pub const Gzip: Self = Self(0);
    pub const Zip: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Gzip, Self::Zip];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Gzip => Some("Gzip"),
            Self::Zip => Some("Zip"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CompressionFormat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CompressionFormat {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for CompressionFormat {
    type Output = CompressionFormat;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for CompressionFormat {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CompressionFormat {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CompressionFormat {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATASET_KIND: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATASET_KIND: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATASET_KIND: [DatasetKind; 2] = [DatasetKind::Root, DatasetKind::Derivative];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DatasetKind(pub i32);
#[allow(non_upper_case_globals)]
impl DatasetKind {
    pub const Root: Self = Self(0);
    pub const Derivative: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Root, Self::Derivative];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Root => Some("Root"),
            Self::Derivative => Some("Derivative"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DatasetKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DatasetKind {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for DatasetKind {
    type Output = DatasetKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DatasetKind {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DatasetKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DatasetKind {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EVENT_TIME_SOURCE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EVENT_TIME_SOURCE: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TIME_SOURCE: [EventTimeSource; 4] = [
    EventTimeSource::NONE,
    EventTimeSource::EventTimeSourceFromMetadata,
    EventTimeSource::EventTimeSourceFromPath,
    EventTimeSource::EventTimeSourceFromSystemTime,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventTimeSource(pub u8);
#[allow(non_upper_case_globals)]
impl EventTimeSource {
    pub const NONE: Self = Self(0);
    pub const EventTimeSourceFromMetadata: Self = Self(1);
    pub const EventTimeSourceFromPath: Self = Self(2);
    pub const EventTimeSourceFromSystemTime: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EventTimeSourceFromMetadata,
        Self::EventTimeSourceFromPath,
        Self::EventTimeSourceFromSystemTime,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EventTimeSourceFromMetadata => Some("EventTimeSourceFromMetadata"),
            Self::EventTimeSourceFromPath => Some("EventTimeSourceFromPath"),
            Self::EventTimeSourceFromSystemTime => Some("EventTimeSourceFromSystemTime"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for EventTimeSource {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for EventTimeSource {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for EventTimeSource {
    type Output = EventTimeSource;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for EventTimeSource {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for EventTimeSource {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for EventTimeSource {}
pub struct EventTimeSourceUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_CACHING: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_CACHING: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_CACHING: [SourceCaching; 2] =
    [SourceCaching::NONE, SourceCaching::SourceCachingForever];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceCaching(pub u8);
#[allow(non_upper_case_globals)]
impl SourceCaching {
    pub const NONE: Self = Self(0);
    pub const SourceCachingForever: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SourceCachingForever];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SourceCachingForever => Some("SourceCachingForever"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SourceCaching {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceCaching {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for SourceCaching {
    type Output = SourceCaching;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SourceCaching {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceCaching {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceCaching {}
pub struct SourceCachingUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_ORDERING: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_ORDERING: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_ORDERING: [SourceOrdering; 2] =
    [SourceOrdering::ByEventTime, SourceOrdering::ByName];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceOrdering(pub i32);
#[allow(non_upper_case_globals)]
impl SourceOrdering {
    pub const ByEventTime: Self = Self(0);
    pub const ByName: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ByEventTime, Self::ByName];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ByEventTime => Some("ByEventTime"),
            Self::ByName => Some("ByName"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SourceOrdering {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceOrdering {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for SourceOrdering {
    type Output = SourceOrdering;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SourceOrdering {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceOrdering {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceOrdering {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MQTT_QOS: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MQTT_QOS: i32 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MQTT_QOS: [MqttQos; 3] = [
    MqttQos::AtMostOnce,
    MqttQos::AtLeastOnce,
    MqttQos::ExactlyOnce,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MqttQos(pub i32);
#[allow(non_upper_case_globals)]
impl MqttQos {
    pub const AtMostOnce: Self = Self(0);
    pub const AtLeastOnce: Self = Self(1);
    pub const ExactlyOnce: Self = Self(2);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::AtMostOnce, Self::AtLeastOnce, Self::ExactlyOnce];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::AtMostOnce => Some("AtMostOnce"),
            Self::AtLeastOnce => Some("AtLeastOnce"),
            Self::ExactlyOnce => Some("ExactlyOnce"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MqttQos {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MqttQos {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MqttQos {
    type Output = MqttQos;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MqttQos {
    type Scalar = i32;
    #[inline]
    fn to_little_endian(self) -> i32 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: i32) -> Self {
        let b = i32::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MqttQos {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MqttQos {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_FETCH_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_FETCH_STEP: u8 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FETCH_STEP: [FetchStep; 6] = [
    FetchStep::NONE,
    FetchStep::FetchStepUrl,
    FetchStep::FetchStepFilesGlob,
    FetchStep::FetchStepContainer,
    FetchStep::FetchStepMqtt,
    FetchStep::FetchStepEthereumLogs,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FetchStep(pub u8);
#[allow(non_upper_case_globals)]
impl FetchStep {
    pub const NONE: Self = Self(0);
    pub const FetchStepUrl: Self = Self(1);
    pub const FetchStepFilesGlob: Self = Self(2);
    pub const FetchStepContainer: Self = Self(3);
    pub const FetchStepMqtt: Self = Self(4);
    pub const FetchStepEthereumLogs: Self = Self(5);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FetchStepUrl,
        Self::FetchStepFilesGlob,
        Self::FetchStepContainer,
        Self::FetchStepMqtt,
        Self::FetchStepEthereumLogs,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FetchStepUrl => Some("FetchStepUrl"),
            Self::FetchStepFilesGlob => Some("FetchStepFilesGlob"),
            Self::FetchStepContainer => Some("FetchStepContainer"),
            Self::FetchStepMqtt => Some("FetchStepMqtt"),
            Self::FetchStepEthereumLogs => Some("FetchStepEthereumLogs"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for FetchStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for FetchStep {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for FetchStep {
    type Output = FetchStep;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FetchStep {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for FetchStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for FetchStep {}
pub struct FetchStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PREP_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PREP_STEP: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PREP_STEP: [PrepStep; 3] = [
    PrepStep::NONE,
    PrepStep::PrepStepDecompress,
    PrepStep::PrepStepPipe,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PrepStep(pub u8);
#[allow(non_upper_case_globals)]
impl PrepStep {
    pub const NONE: Self = Self(0);
    pub const PrepStepDecompress: Self = Self(1);
    pub const PrepStepPipe: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::PrepStepDecompress, Self::PrepStepPipe];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PrepStepDecompress => Some("PrepStepDecompress"),
            Self::PrepStepPipe => Some("PrepStepPipe"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PrepStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PrepStep {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for PrepStep {
    type Output = PrepStep;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PrepStep {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PrepStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PrepStep {}
pub struct PrepStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_METADATA_EVENT: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_METADATA_EVENT: u8 = 13;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_METADATA_EVENT: [MetadataEvent; 14] = [
    MetadataEvent::NONE,
    MetadataEvent::AddData,
    MetadataEvent::ExecuteTransform,
    MetadataEvent::Seed,
    MetadataEvent::SetPollingSource,
    MetadataEvent::SetTransform,
    MetadataEvent::SetVocab,
    MetadataEvent::SetAttachments,
    MetadataEvent::SetInfo,
    MetadataEvent::SetLicense,
    MetadataEvent::SetDataSchema,
    MetadataEvent::AddPushSource,
    MetadataEvent::DisablePushSource,
    MetadataEvent::DisablePollingSource,
];

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MetadataEvent(pub u8);
#[allow(non_upper_case_globals)]
impl MetadataEvent {
    pub const NONE: Self = Self(0);
    pub const AddData: Self = Self(1);
    pub const ExecuteTransform: Self = Self(2);
    pub const Seed: Self = Self(3);
    pub const SetPollingSource: Self = Self(4);
    pub const SetTransform: Self = Self(5);
    pub const SetVocab: Self = Self(6);
    pub const SetAttachments: Self = Self(7);
    pub const SetInfo: Self = Self(8);
    pub const SetLicense: Self = Self(9);
    pub const SetDataSchema: Self = Self(10);
    pub const AddPushSource: Self = Self(11);
    pub const DisablePushSource: Self = Self(12);
    pub const DisablePollingSource: Self = Self(13);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 13;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::AddData,
        Self::ExecuteTransform,
        Self::Seed,
        Self::SetPollingSource,
        Self::SetTransform,
        Self::SetVocab,
        Self::SetAttachments,
        Self::SetInfo,
        Self::SetLicense,
        Self::SetDataSchema,
        Self::AddPushSource,
        Self::DisablePushSource,
        Self::DisablePollingSource,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::AddData => Some("AddData"),
            Self::ExecuteTransform => Some("ExecuteTransform"),
            Self::Seed => Some("Seed"),
            Self::SetPollingSource => Some("SetPollingSource"),
            Self::SetTransform => Some("SetTransform"),
            Self::SetVocab => Some("SetVocab"),
            Self::SetAttachments => Some("SetAttachments"),
            Self::SetInfo => Some("SetInfo"),
            Self::SetLicense => Some("SetLicense"),
            Self::SetDataSchema => Some("SetDataSchema"),
            Self::AddPushSource => Some("AddPushSource"),
            Self::DisablePushSource => Some("DisablePushSource"),
            Self::DisablePollingSource => Some("DisablePollingSource"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MetadataEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MetadataEvent {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for MetadataEvent {
    type Output = MetadataEvent;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MetadataEvent {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MetadataEvent {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MetadataEvent {}
pub struct MetadataEventUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RAW_QUERY_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RAW_QUERY_RESPONSE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RAW_QUERY_RESPONSE: [RawQueryResponse; 5] = [
    RawQueryResponse::NONE,
    RawQueryResponse::RawQueryResponseProgress,
    RawQueryResponse::RawQueryResponseSuccess,
    RawQueryResponse::RawQueryResponseInvalidQuery,
    RawQueryResponse::RawQueryResponseInternalError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct RawQueryResponse(pub u8);
#[allow(non_upper_case_globals)]
impl RawQueryResponse {
    pub const NONE: Self = Self(0);
    pub const RawQueryResponseProgress: Self = Self(1);
    pub const RawQueryResponseSuccess: Self = Self(2);
    pub const RawQueryResponseInvalidQuery: Self = Self(3);
    pub const RawQueryResponseInternalError: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::RawQueryResponseProgress,
        Self::RawQueryResponseSuccess,
        Self::RawQueryResponseInvalidQuery,
        Self::RawQueryResponseInternalError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::RawQueryResponseProgress => Some("RawQueryResponseProgress"),
            Self::RawQueryResponseSuccess => Some("RawQueryResponseSuccess"),
            Self::RawQueryResponseInvalidQuery => Some("RawQueryResponseInvalidQuery"),
            Self::RawQueryResponseInternalError => Some("RawQueryResponseInternalError"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for RawQueryResponse {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for RawQueryResponse {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for RawQueryResponse {
    type Output = RawQueryResponse;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for RawQueryResponse {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for RawQueryResponse {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for RawQueryResponse {}
pub struct RawQueryResponseUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TRANSFORM_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TRANSFORM_RESPONSE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM_RESPONSE: [TransformResponse; 5] = [
    TransformResponse::NONE,
    TransformResponse::TransformResponseProgress,
    TransformResponse::TransformResponseSuccess,
    TransformResponse::TransformResponseInvalidQuery,
    TransformResponse::TransformResponseInternalError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TransformResponse(pub u8);
#[allow(non_upper_case_globals)]
impl TransformResponse {
    pub const NONE: Self = Self(0);
    pub const TransformResponseProgress: Self = Self(1);
    pub const TransformResponseSuccess: Self = Self(2);
    pub const TransformResponseInvalidQuery: Self = Self(3);
    pub const TransformResponseInternalError: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TransformResponseProgress,
        Self::TransformResponseSuccess,
        Self::TransformResponseInvalidQuery,
        Self::TransformResponseInternalError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TransformResponseProgress => Some("TransformResponseProgress"),
            Self::TransformResponseSuccess => Some("TransformResponseSuccess"),
            Self::TransformResponseInvalidQuery => Some("TransformResponseInvalidQuery"),
            Self::TransformResponseInternalError => Some("TransformResponseInternalError"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for TransformResponse {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for TransformResponse {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for TransformResponse {
    type Output = TransformResponse;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TransformResponse {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for TransformResponse {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for TransformResponse {}
pub struct TransformResponseUnionTableOffset {}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// struct Timestamp, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Timestamp(pub [u8; 16]);
impl Default for Timestamp {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timestamp")
            .field("year", &self.year())
            .field("ordinal", &self.ordinal())
            .field("seconds_from_midnight", &self.seconds_from_midnight())
            .field("nanoseconds", &self.nanoseconds())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Timestamp>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const Timestamp as *const u8,
            <Self as flatbuffers::Push>::size(),
        );
        dst.copy_from_slice(src);
    }

    // FIXME: https://github.com/kamu-data/kamu-cli/issues/1084
    // #[inline]
    // fn alignment() -> flatbuffers::PushAlignment {
    //     flatbuffers::PushAlignment::new(4)
    // }
}

impl<'a> flatbuffers::Verifiable for Timestamp {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Timestamp {
    #[allow(clippy::too_many_arguments)]
    pub fn new(year: i32, ordinal: u16, seconds_from_midnight: u32, nanoseconds: u32) -> Self {
        let mut s = Self([0; 16]);
        s.set_year(year);
        s.set_ordinal(ordinal);
        s.set_seconds_from_midnight(seconds_from_midnight);
        s.set_nanoseconds(nanoseconds);
        s
    }

    pub fn year(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<<i32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_year(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<<i32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn ordinal(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<<u16 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_ordinal(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<<u16 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn seconds_from_midnight(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_seconds_from_midnight(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
        }
    }

    pub fn nanoseconds(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        EndianScalar::from_little_endian(unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
            mem.assume_init()
        })
    }

    pub fn set_nanoseconds(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid value in this slot
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const _ as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
            );
        }
    }
}

pub enum OffsetIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct OffsetInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OffsetInterval<'a> {
    type Inner = OffsetInterval<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> OffsetInterval<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OffsetInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args OffsetIntervalArgs,
    ) -> flatbuffers::WIPOffset<OffsetInterval<'bldr>> {
        let mut builder = OffsetIntervalBuilder::new(_fbb);
        builder.add_end(args.end);
        builder.add_start(args.start);
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(OffsetInterval::VT_START, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn end(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(OffsetInterval::VT_END, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for OffsetInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("start", Self::VT_START, false)?
            .visit_field::<u64>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct OffsetIntervalArgs {
    pub start: u64,
    pub end: u64,
}
impl<'a> Default for OffsetIntervalArgs {
    #[inline]
    fn default() -> Self {
        OffsetIntervalArgs { start: 0, end: 0 }
    }
}

pub struct OffsetIntervalBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> OffsetIntervalBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_start(&mut self, start: u64) {
        self.fbb_
            .push_slot::<u64>(OffsetInterval::VT_START, start, 0);
    }
    #[inline]
    pub fn add_end(&mut self, end: u64) {
        self.fbb_.push_slot::<u64>(OffsetInterval::VT_END, end, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> OffsetIntervalBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        OffsetIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OffsetInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OffsetInterval<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OffsetInterval");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum DataSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct DataSlice<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSlice<'a> {
    type Inner = DataSlice<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DataSlice<'a> {
    pub const VT_LOGICAL_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_PHYSICAL_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET_INTERVAL: flatbuffers::VOffsetT = 8;
    pub const VT_SIZE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DataSlice { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DataSliceArgs<'args>,
    ) -> flatbuffers::WIPOffset<DataSlice<'bldr>> {
        let mut builder = DataSliceBuilder::new(_fbb);
        builder.add_size(args.size);
        if let Some(x) = args.offset_interval {
            builder.add_offset_interval(x);
        }
        if let Some(x) = args.physical_hash {
            builder.add_physical_hash(x);
        }
        if let Some(x) = args.logical_hash {
            builder.add_logical_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn logical_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    DataSlice::VT_LOGICAL_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn physical_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    DataSlice::VT_PHYSICAL_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn offset_interval(&self) -> Option<OffsetInterval<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                    DataSlice::VT_OFFSET_INTERVAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn size(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(DataSlice::VT_SIZE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for DataSlice<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "logical_hash",
                Self::VT_LOGICAL_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "physical_hash",
                Self::VT_PHYSICAL_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "offset_interval",
                Self::VT_OFFSET_INTERVAL,
                false,
            )?
            .visit_field::<u64>("size", Self::VT_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct DataSliceArgs<'a> {
    pub logical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub physical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub offset_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub size: u64,
}
impl<'a> Default for DataSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        DataSliceArgs {
            logical_hash: None,
            physical_hash: None,
            offset_interval: None,
            size: 0,
        }
    }
}

pub struct DataSliceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DataSliceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_logical_hash(
        &mut self,
        logical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DataSlice::VT_LOGICAL_HASH,
            logical_hash,
        );
    }
    #[inline]
    pub fn add_physical_hash(
        &mut self,
        physical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DataSlice::VT_PHYSICAL_HASH,
            physical_hash,
        );
    }
    #[inline]
    pub fn add_offset_interval(
        &mut self,
        offset_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                DataSlice::VT_OFFSET_INTERVAL,
                offset_interval,
            );
    }
    #[inline]
    pub fn add_size(&mut self, size: u64) {
        self.fbb_.push_slot::<u64>(DataSlice::VT_SIZE, size, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DataSliceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DataSliceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DataSlice<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DataSlice<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DataSlice");
        ds.field("logical_hash", &self.logical_hash());
        ds.field("physical_hash", &self.physical_hash());
        ds.field("offset_interval", &self.offset_interval());
        ds.field("size", &self.size());
        ds.finish()
    }
}
pub enum CheckpointOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct Checkpoint<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
    type Inner = Checkpoint<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Checkpoint<'a> {
    pub const VT_PHYSICAL_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Checkpoint { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args CheckpointArgs<'args>,
    ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
        let mut builder = CheckpointBuilder::new(_fbb);
        builder.add_size(args.size);
        if let Some(x) = args.physical_hash {
            builder.add_physical_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn physical_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Checkpoint::VT_PHYSICAL_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn size(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(Checkpoint::VT_SIZE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for Checkpoint<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "physical_hash",
                Self::VT_PHYSICAL_HASH,
                false,
            )?
            .visit_field::<u64>("size", Self::VT_SIZE, false)?
            .finish();
        Ok(())
    }
}
pub struct CheckpointArgs<'a> {
    pub physical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub size: u64,
}
impl<'a> Default for CheckpointArgs<'a> {
    #[inline]
    fn default() -> Self {
        CheckpointArgs {
            physical_hash: None,
            size: 0,
        }
    }
}

pub struct CheckpointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CheckpointBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_physical_hash(
        &mut self,
        physical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Checkpoint::VT_PHYSICAL_HASH,
            physical_hash,
        );
    }
    #[inline]
    pub fn add_size(&mut self, size: u64) {
        self.fbb_.push_slot::<u64>(Checkpoint::VT_SIZE, size, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> CheckpointBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        CheckpointBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Checkpoint<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Checkpoint");
        ds.field("physical_hash", &self.physical_hash());
        ds.field("size", &self.size());
        ds.finish()
    }
}
pub enum SourceStateOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SourceState<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceState<'a> {
    type Inner = SourceState<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SourceState<'a> {
    pub const VT_SOURCE_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_KIND: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceState { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SourceStateArgs<'args>,
    ) -> flatbuffers::WIPOffset<SourceState<'bldr>> {
        let mut builder = SourceStateBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.kind {
            builder.add_kind(x);
        }
        if let Some(x) = args.source_name {
            builder.add_source_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn source_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceState::VT_SOURCE_NAME, None)
        }
    }
    #[inline]
    pub fn kind(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceState::VT_KIND, None)
        }
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SourceState::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for SourceState<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "source_name",
                Self::VT_SOURCE_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("kind", Self::VT_KIND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct SourceStateArgs<'a> {
    pub source_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SourceStateArgs<'a> {
    #[inline]
    fn default() -> Self {
        SourceStateArgs {
            source_name: None,
            kind: None,
            value: None,
        }
    }
}

pub struct SourceStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SourceStateBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_source_name(&mut self, source_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SourceState::VT_SOURCE_NAME,
            source_name,
        );
    }
    #[inline]
    pub fn add_kind(&mut self, kind: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceState::VT_KIND, kind);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SourceState::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SourceStateBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SourceStateBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SourceState<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SourceState<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SourceState");
        ds.field("source_name", &self.source_name());
        ds.field("kind", &self.kind());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum AddDataOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct AddData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddData<'a> {
    type Inner = AddData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AddData<'a> {
    pub const VT_PREV_CHECKPOINT: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_NEW_DATA: flatbuffers::VOffsetT = 8;
    pub const VT_NEW_CHECKPOINT: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_WATERMARK: flatbuffers::VOffsetT = 12;
    pub const VT_NEW_SOURCE_STATE: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AddData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AddDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<AddData<'bldr>> {
        let mut builder = AddDataBuilder::new(_fbb);
        if let Some(x) = args.prev_offset {
            builder.add_prev_offset(x);
        }
        if let Some(x) = args.new_source_state {
            builder.add_new_source_state(x);
        }
        if let Some(x) = args.new_watermark {
            builder.add_new_watermark(x);
        }
        if let Some(x) = args.new_checkpoint {
            builder.add_new_checkpoint(x);
        }
        if let Some(x) = args.new_data {
            builder.add_new_data(x);
        }
        if let Some(x) = args.prev_checkpoint {
            builder.add_prev_checkpoint(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn prev_checkpoint(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    AddData::VT_PREV_CHECKPOINT,
                    None,
                )
        }
    }
    #[inline]
    pub fn prev_offset(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(AddData::VT_PREV_OFFSET, None) }
    }
    #[inline]
    pub fn new_data(&self) -> Option<DataSlice<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DataSlice>>(AddData::VT_NEW_DATA, None)
        }
    }
    #[inline]
    pub fn new_checkpoint(&self) -> Option<Checkpoint<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<Checkpoint>>(AddData::VT_NEW_CHECKPOINT, None)
        }
    }
    #[inline]
    pub fn new_watermark(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Timestamp>(AddData::VT_NEW_WATERMARK, None) }
    }
    #[inline]
    pub fn new_source_state(&self) -> Option<SourceState<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<SourceState>>(
                AddData::VT_NEW_SOURCE_STATE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for AddData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "prev_checkpoint",
                Self::VT_PREV_CHECKPOINT,
                false,
            )?
            .visit_field::<u64>("prev_offset", Self::VT_PREV_OFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DataSlice>>(
                "new_data",
                Self::VT_NEW_DATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Checkpoint>>(
                "new_checkpoint",
                Self::VT_NEW_CHECKPOINT,
                false,
            )?
            .visit_field::<Timestamp>("new_watermark", Self::VT_NEW_WATERMARK, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<SourceState>>(
                "new_source_state",
                Self::VT_NEW_SOURCE_STATE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct AddDataArgs<'a> {
    pub prev_checkpoint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub prev_offset: Option<u64>,
    pub new_data: Option<flatbuffers::WIPOffset<DataSlice<'a>>>,
    pub new_checkpoint: Option<flatbuffers::WIPOffset<Checkpoint<'a>>>,
    pub new_watermark: Option<&'a Timestamp>,
    pub new_source_state: Option<flatbuffers::WIPOffset<SourceState<'a>>>,
}
impl<'a> Default for AddDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        AddDataArgs {
            prev_checkpoint: None,
            prev_offset: None,
            new_data: None,
            new_checkpoint: None,
            new_watermark: None,
            new_source_state: None,
        }
    }
}

pub struct AddDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AddDataBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_prev_checkpoint(
        &mut self,
        prev_checkpoint: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AddData::VT_PREV_CHECKPOINT,
            prev_checkpoint,
        );
    }
    #[inline]
    pub fn add_prev_offset(&mut self, prev_offset: u64) {
        self.fbb_
            .push_slot_always::<u64>(AddData::VT_PREV_OFFSET, prev_offset);
    }
    #[inline]
    pub fn add_new_data(&mut self, new_data: flatbuffers::WIPOffset<DataSlice<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DataSlice>>(AddData::VT_NEW_DATA, new_data);
    }
    #[inline]
    pub fn add_new_checkpoint(&mut self, new_checkpoint: flatbuffers::WIPOffset<Checkpoint<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Checkpoint>>(
                AddData::VT_NEW_CHECKPOINT,
                new_checkpoint,
            );
    }
    #[inline]
    pub fn add_new_watermark(&mut self, new_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(AddData::VT_NEW_WATERMARK, new_watermark);
    }
    #[inline]
    pub fn add_new_source_state(
        &mut self,
        new_source_state: flatbuffers::WIPOffset<SourceState<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<SourceState>>(
                AddData::VT_NEW_SOURCE_STATE,
                new_source_state,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AddDataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AddDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AddData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AddData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AddData");
        ds.field("prev_checkpoint", &self.prev_checkpoint());
        ds.field("prev_offset", &self.prev_offset());
        ds.field("new_data", &self.new_data());
        ds.field("new_checkpoint", &self.new_checkpoint());
        ds.field("new_watermark", &self.new_watermark());
        ds.field("new_source_state", &self.new_source_state());
        ds.finish()
    }
}
pub enum ReadStepCsvOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepCsv<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepCsv<'a> {
    type Inner = ReadStepCsv<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepCsv<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SEPARATOR: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_QUOTE: flatbuffers::VOffsetT = 10;
    pub const VT_ESCAPE: flatbuffers::VOffsetT = 12;
    pub const VT_HEADER: flatbuffers::VOffsetT = 14;
    pub const VT_INFER_SCHEMA: flatbuffers::VOffsetT = 16;
    pub const VT_NULL_VALUE: flatbuffers::VOffsetT = 18;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 20;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 22;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepCsv { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepCsvArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepCsv<'bldr>> {
        let mut builder = ReadStepCsvBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.null_value {
            builder.add_null_value(x);
        }
        if let Some(x) = args.escape {
            builder.add_escape(x);
        }
        if let Some(x) = args.quote {
            builder.add_quote(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.separator {
            builder.add_separator(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.infer_schema {
            builder.add_infer_schema(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepCsv::VT_SCHEMA, None)
        }
    }
    #[inline]
    pub fn separator(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_SEPARATOR, None)
        }
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ENCODING, None)
        }
    }
    #[inline]
    pub fn quote(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_QUOTE, None)
        }
    }
    #[inline]
    pub fn escape(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ESCAPE, None)
        }
    }
    #[inline]
    pub fn header(&self) -> Option<bool> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<bool>(ReadStepCsv::VT_HEADER, None) }
    }
    #[inline]
    pub fn infer_schema(&self) -> Option<bool> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<bool>(ReadStepCsv::VT_INFER_SCHEMA, None) }
    }
    #[inline]
    pub fn null_value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NULL_VALUE, None)
        }
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_DATE_FORMAT, None)
        }
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_TIMESTAMP_FORMAT, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepCsv<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "separator",
                Self::VT_SEPARATOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("quote", Self::VT_QUOTE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("escape", Self::VT_ESCAPE, false)?
            .visit_field::<bool>("header", Self::VT_HEADER, false)?
            .visit_field::<bool>("infer_schema", Self::VT_INFER_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "null_value",
                Self::VT_NULL_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepCsvArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub separator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quote: Option<flatbuffers::WIPOffset<&'a str>>,
    pub escape: Option<flatbuffers::WIPOffset<&'a str>>,
    pub header: Option<bool>,
    pub infer_schema: Option<bool>,
    pub null_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepCsvArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepCsvArgs {
            schema: None,
            separator: None,
            encoding: None,
            quote: None,
            escape: None,
            header: None,
            infer_schema: None,
            null_value: None,
            date_format: None,
            timestamp_format: None,
        }
    }
}

pub struct ReadStepCsvBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepCsvBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_separator(&mut self, separator: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SEPARATOR, separator);
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ENCODING, encoding);
    }
    #[inline]
    pub fn add_quote(&mut self, quote: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_QUOTE, quote);
    }
    #[inline]
    pub fn add_escape(&mut self, escape: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ESCAPE, escape);
    }
    #[inline]
    pub fn add_header(&mut self, header: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_HEADER, header);
    }
    #[inline]
    pub fn add_infer_schema(&mut self, infer_schema: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_INFER_SCHEMA, infer_schema);
    }
    #[inline]
    pub fn add_null_value(&mut self, null_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NULL_VALUE, null_value);
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepCsvBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepCsvBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepCsv<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepCsv<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepCsv");
        ds.field("schema", &self.schema());
        ds.field("separator", &self.separator());
        ds.field("encoding", &self.encoding());
        ds.field("quote", &self.quote());
        ds.field("escape", &self.escape());
        ds.field("header", &self.header());
        ds.field("infer_schema", &self.infer_schema());
        ds.field("null_value", &self.null_value());
        ds.field("date_format", &self.date_format());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum ReadStepGeoJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepGeoJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepGeoJson<'a> {
    type Inner = ReadStepGeoJson<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepGeoJson<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepGeoJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepGeoJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepGeoJson<'bldr>> {
        let mut builder = ReadStepGeoJsonBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepGeoJson::VT_SCHEMA, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepGeoJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepGeoJsonArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepGeoJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepGeoJsonArgs { schema: None }
    }
}

pub struct ReadStepGeoJsonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepGeoJsonBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepGeoJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepGeoJsonBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepGeoJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepGeoJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepGeoJson<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepGeoJson");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum ReadStepEsriShapefileOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepEsriShapefile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepEsriShapefile<'a> {
    type Inner = ReadStepEsriShapefile<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepEsriShapefile<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepEsriShapefile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepEsriShapefileArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'bldr>> {
        let mut builder = ReadStepEsriShapefileBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepEsriShapefile::VT_SCHEMA, None)
        }
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepEsriShapefile::VT_SUB_PATH, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepEsriShapefile<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepEsriShapefileArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepEsriShapefileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepEsriShapefileArgs {
            schema: None,
            sub_path: None,
        }
    }
}

pub struct ReadStepEsriShapefileBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepEsriShapefileBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SCHEMA,
            schema,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepEsriShapefileBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepEsriShapefileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepEsriShapefile<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepEsriShapefile");
        ds.field("schema", &self.schema());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum ReadStepParquetOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepParquet<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepParquet<'a> {
    type Inner = ReadStepParquet<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepParquet<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepParquet { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepParquetArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepParquet<'bldr>> {
        let mut builder = ReadStepParquetBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepParquet::VT_SCHEMA, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepParquet<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepParquetArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepParquetArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepParquetArgs { schema: None }
    }
}

pub struct ReadStepParquetBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepParquetBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepParquet::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepParquetBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepParquetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepParquet<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepParquet<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepParquet");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum ReadStepJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepJson<'a> {
    type Inner = ReadStepJson<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepJson<'a> {
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 6;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 8;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 10;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepJson<'bldr>> {
        let mut builder = ReadStepJsonBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJson::VT_SUB_PATH, None)
        }
    }
    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepJson::VT_SCHEMA, None)
        }
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJson::VT_DATE_FORMAT, None)
        }
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJson::VT_ENCODING, None)
        }
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJson::VT_TIMESTAMP_FORMAT, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepJsonArgs<'a> {
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepJsonArgs {
            sub_path: None,
            schema: None,
            date_format: None,
            encoding: None,
            timestamp_format: None,
        }
    }
}

pub struct ReadStepJsonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepJsonBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJson::VT_SUB_PATH, sub_path);
    }
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJson::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJson::VT_ENCODING, encoding);
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJson::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepJsonBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepJson<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepJson");
        ds.field("sub_path", &self.sub_path());
        ds.field("schema", &self.schema());
        ds.field("date_format", &self.date_format());
        ds.field("encoding", &self.encoding());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum ReadStepNdJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepNdJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepNdJson<'a> {
    type Inner = ReadStepNdJson<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepNdJson<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepNdJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepNdJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepNdJson<'bldr>> {
        let mut builder = ReadStepNdJsonBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepNdJson::VT_SCHEMA, None)
        }
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepNdJson::VT_DATE_FORMAT, None)
        }
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepNdJson::VT_ENCODING, None)
        }
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                ReadStepNdJson::VT_TIMESTAMP_FORMAT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for ReadStepNdJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepNdJsonArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepNdJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepNdJsonArgs {
            schema: None,
            date_format: None,
            encoding: None,
            timestamp_format: None,
        }
    }
}

pub struct ReadStepNdJsonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepNdJsonBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepNdJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepNdJson::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepNdJson::VT_ENCODING, encoding);
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepNdJson::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepNdJsonBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepNdJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepNdJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepNdJson<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepNdJson");
        ds.field("schema", &self.schema());
        ds.field("date_format", &self.date_format());
        ds.field("encoding", &self.encoding());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum ReadStepNdGeoJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepNdGeoJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepNdGeoJson<'a> {
    type Inner = ReadStepNdGeoJson<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReadStepNdGeoJson<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepNdGeoJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ReadStepNdGeoJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepNdGeoJson<'bldr>> {
        let mut builder = ReadStepNdGeoJsonBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(ReadStepNdGeoJson::VT_SCHEMA, None)
        }
    }
}

impl flatbuffers::Verifiable for ReadStepNdGeoJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepNdGeoJsonArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepNdGeoJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepNdGeoJsonArgs { schema: None }
    }
}

pub struct ReadStepNdGeoJsonBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ReadStepNdGeoJsonBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepNdGeoJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ReadStepNdGeoJsonBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ReadStepNdGeoJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepNdGeoJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepNdGeoJson<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepNdGeoJson");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum SqlQueryStepOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SqlQueryStep<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqlQueryStep<'a> {
    type Inner = SqlQueryStep<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SqlQueryStep<'a> {
    pub const VT_ALIAS: flatbuffers::VOffsetT = 4;
    pub const VT_QUERY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SqlQueryStep { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SqlQueryStepArgs<'args>,
    ) -> flatbuffers::WIPOffset<SqlQueryStep<'bldr>> {
        let mut builder = SqlQueryStepBuilder::new(_fbb);
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_ALIAS, None)
        }
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_QUERY, None)
        }
    }
}

impl flatbuffers::Verifiable for SqlQueryStep<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .finish();
        Ok(())
    }
}
pub struct SqlQueryStepArgs<'a> {
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SqlQueryStepArgs<'a> {
    #[inline]
    fn default() -> Self {
        SqlQueryStepArgs {
            alias: None,
            query: None,
        }
    }
}

pub struct SqlQueryStepBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SqlQueryStepBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_ALIAS, alias);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_QUERY, query);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SqlQueryStepBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SqlQueryStepBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SqlQueryStep<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SqlQueryStep<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SqlQueryStep");
        ds.field("alias", &self.alias());
        ds.field("query", &self.query());
        ds.finish()
    }
}
pub enum TemporalTableOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TemporalTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporalTable<'a> {
    type Inner = TemporalTable<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TemporalTable<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TemporalTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TemporalTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<TemporalTable<'bldr>> {
        let mut builder = TemporalTableBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TemporalTable::VT_NAME, None)
        }
    }
    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(TemporalTable::VT_PRIMARY_KEY, None)
        }
    }
}

impl flatbuffers::Verifiable for TemporalTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct TemporalTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for TemporalTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TemporalTableArgs {
            name: None,
            primary_key: None,
        }
    }
}

pub struct TemporalTableBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TemporalTableBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TemporalTable::VT_NAME, name);
    }
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TemporalTable::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TemporalTableBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TemporalTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TemporalTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TemporalTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TemporalTable");
        ds.field("name", &self.name());
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum TransformSqlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformSql<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformSql<'a> {
    type Inner = TransformSql<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformSql<'a> {
    pub const VT_ENGINE: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_QUERY: flatbuffers::VOffsetT = 8;
    pub const VT_QUERIES: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPORAL_TABLES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformSql { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformSqlArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformSql<'bldr>> {
        let mut builder = TransformSqlBuilder::new(_fbb);
        if let Some(x) = args.temporal_tables {
            builder.add_temporal_tables(x);
        }
        if let Some(x) = args.queries {
            builder.add_queries(x);
        }
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.version {
            builder.add_version(x);
        }
        if let Some(x) = args.engine {
            builder.add_engine(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn engine(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_ENGINE, None)
        }
    }
    #[inline]
    pub fn version(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_VERSION, None)
        }
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_QUERY, None)
        }
    }
    #[inline]
    pub fn queries(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
            >>(TransformSql::VT_QUERIES, None)
        }
    }
    #[inline]
    pub fn temporal_tables(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable>>,
            >>(TransformSql::VT_TEMPORAL_TABLES, None)
        }
    }
}

impl flatbuffers::Verifiable for TransformSql<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("engine", Self::VT_ENGINE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
            >>("queries", Self::VT_QUERIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TemporalTable>>,
            >>("temporal_tables", Self::VT_TEMPORAL_TABLES, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformSqlArgs<'a> {
    pub engine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub queries: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>,
        >,
    >,
    pub temporal_tables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>,
        >,
    >,
}
impl<'a> Default for TransformSqlArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformSqlArgs {
            engine: None,
            version: None,
            query: None,
            queries: None,
            temporal_tables: None,
        }
    }
}

pub struct TransformSqlBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformSqlBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_engine(&mut self, engine: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_ENGINE, engine);
    }
    #[inline]
    pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_VERSION, version);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERY, query);
    }
    #[inline]
    pub fn add_queries(
        &mut self,
        queries: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SqlQueryStep<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERIES, queries);
    }
    #[inline]
    pub fn add_temporal_tables(
        &mut self,
        temporal_tables: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TemporalTable<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformSql::VT_TEMPORAL_TABLES,
            temporal_tables,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformSqlBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformSqlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformSql<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformSql<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformSql");
        ds.field("engine", &self.engine());
        ds.field("version", &self.version());
        ds.field("query", &self.query());
        ds.field("queries", &self.queries());
        ds.field("temporal_tables", &self.temporal_tables());
        ds.finish()
    }
}
pub enum MergeStrategyAppendOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategyAppend<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyAppend<'a> {
    type Inner = MergeStrategyAppend<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MergeStrategyAppend<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyAppend { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args MergeStrategyAppendArgs,
    ) -> flatbuffers::WIPOffset<MergeStrategyAppend<'bldr>> {
        let mut builder = MergeStrategyAppendBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for MergeStrategyAppend<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct MergeStrategyAppendArgs {}
impl<'a> Default for MergeStrategyAppendArgs {
    #[inline]
    fn default() -> Self {
        MergeStrategyAppendArgs {}
    }
}

pub struct MergeStrategyAppendBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MergeStrategyAppendBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MergeStrategyAppendBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MergeStrategyAppendBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyAppend<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategyAppend<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyAppend");
        ds.finish()
    }
}
pub enum MergeStrategyLedgerOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategyLedger<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyLedger<'a> {
    type Inner = MergeStrategyLedger<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MergeStrategyLedger<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyLedger { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MergeStrategyLedgerArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategyLedger<'bldr>> {
        let mut builder = MergeStrategyLedgerBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(MergeStrategyLedger::VT_PRIMARY_KEY, None)
        }
    }
}

impl flatbuffers::Verifiable for MergeStrategyLedger<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategyLedgerArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for MergeStrategyLedgerArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategyLedgerArgs { primary_key: None }
    }
}

pub struct MergeStrategyLedgerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MergeStrategyLedgerBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategyLedger::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MergeStrategyLedgerBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MergeStrategyLedgerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyLedger<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategyLedger<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyLedger");
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum MergeStrategySnapshotOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategySnapshot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategySnapshot<'a> {
    type Inner = MergeStrategySnapshot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MergeStrategySnapshot<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_COMPARE_COLUMNS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategySnapshot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MergeStrategySnapshotArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'bldr>> {
        let mut builder = MergeStrategySnapshotBuilder::new(_fbb);
        if let Some(x) = args.compare_columns {
            builder.add_compare_columns(x);
        }
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(MergeStrategySnapshot::VT_PRIMARY_KEY, None)
        }
    }
    #[inline]
    pub fn compare_columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(MergeStrategySnapshot::VT_COMPARE_COLUMNS, None)
        }
    }
}

impl flatbuffers::Verifiable for MergeStrategySnapshot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("compare_columns", Self::VT_COMPARE_COLUMNS, false)?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategySnapshotArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub compare_columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for MergeStrategySnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategySnapshotArgs {
            primary_key: None,
            compare_columns: None,
        }
    }
}

pub struct MergeStrategySnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MergeStrategySnapshotBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn add_compare_columns(
        &mut self,
        compare_columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_COMPARE_COLUMNS,
            compare_columns,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MergeStrategySnapshotBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MergeStrategySnapshotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategySnapshot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategySnapshot");
        ds.field("primary_key", &self.primary_key());
        ds.field("compare_columns", &self.compare_columns());
        ds.finish()
    }
}
pub enum AddPushSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct AddPushSource<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddPushSource<'a> {
    type Inner = AddPushSource<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AddPushSource<'a> {
    pub const VT_SOURCE_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_READ_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_READ: flatbuffers::VOffsetT = 8;
    pub const VT_PREPROCESS_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_PREPROCESS: flatbuffers::VOffsetT = 12;
    pub const VT_MERGE_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_MERGE: flatbuffers::VOffsetT = 16;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AddPushSource { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AddPushSourceArgs<'args>,
    ) -> flatbuffers::WIPOffset<AddPushSource<'bldr>> {
        let mut builder = AddPushSourceBuilder::new(_fbb);
        if let Some(x) = args.merge {
            builder.add_merge(x);
        }
        if let Some(x) = args.preprocess {
            builder.add_preprocess(x);
        }
        if let Some(x) = args.read {
            builder.add_read(x);
        }
        if let Some(x) = args.source_name {
            builder.add_source_name(x);
        }
        builder.add_merge_type(args.merge_type);
        builder.add_preprocess_type(args.preprocess_type);
        builder.add_read_type(args.read_type);
        builder.finish()
    }

    #[inline]
    pub fn source_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(AddPushSource::VT_SOURCE_NAME, None)
        }
    }
    #[inline]
    pub fn read_type(&self) -> ReadStep {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ReadStep>(AddPushSource::VT_READ_TYPE, Some(ReadStep::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn read(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    AddPushSource::VT_READ,
                    None,
                )
        }
    }
    #[inline]
    pub fn preprocess_type(&self) -> Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(AddPushSource::VT_PREPROCESS_TYPE, Some(Transform::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn preprocess(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    AddPushSource::VT_PREPROCESS,
                    None,
                )
        }
    }
    #[inline]
    pub fn merge_type(&self) -> MergeStrategy {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MergeStrategy>(AddPushSource::VT_MERGE_TYPE, Some(MergeStrategy::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn merge(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    AddPushSource::VT_MERGE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_csv(&self) -> Option<ReadStepCsv<'a>> {
        if self.read_type() == ReadStep::ReadStepCsv {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepCsv::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_geo_json(&self) -> Option<ReadStepGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepGeoJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepGeoJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_esri_shapefile(&self) -> Option<ReadStepEsriShapefile<'a>> {
        if self.read_type() == ReadStep::ReadStepEsriShapefile {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepEsriShapefile::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_parquet(&self) -> Option<ReadStepParquet<'a>> {
        if self.read_type() == ReadStep::ReadStepParquet {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepParquet::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_json(&self) -> Option<ReadStepJson<'a>> {
        if self.read_type() == ReadStep::ReadStepJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_nd_json(&self) -> Option<ReadStepNdJson<'a>> {
        if self.read_type() == ReadStep::ReadStepNdJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepNdJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_nd_geo_json(&self) -> Option<ReadStepNdGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepNdGeoJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepNdGeoJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn preprocess_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.preprocess_type() == Transform::TransformSql {
            self.preprocess().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformSql::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_append(&self) -> Option<MergeStrategyAppend<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyAppend {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategyAppend::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_ledger(&self) -> Option<MergeStrategyLedger<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyLedger {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategyLedger::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_snapshot(&self) -> Option<MergeStrategySnapshot<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategySnapshot {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategySnapshot::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for AddPushSource<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source_name", Self::VT_SOURCE_NAME, false)?
     .visit_union::<ReadStep, _>("read_type", Self::VT_READ_TYPE, "read", Self::VT_READ, false, |key, v, pos| {
        match key {
          ReadStep::ReadStepCsv => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepCsv>>("ReadStep::ReadStepCsv", pos),
          ReadStep::ReadStepGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepGeoJson>>("ReadStep::ReadStepGeoJson", pos),
          ReadStep::ReadStepEsriShapefile => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepEsriShapefile>>("ReadStep::ReadStepEsriShapefile", pos),
          ReadStep::ReadStepParquet => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepParquet>>("ReadStep::ReadStepParquet", pos),
          ReadStep::ReadStepJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepJson>>("ReadStep::ReadStepJson", pos),
          ReadStep::ReadStepNdJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepNdJson>>("ReadStep::ReadStepNdJson", pos),
          ReadStep::ReadStepNdGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepNdGeoJson>>("ReadStep::ReadStepNdGeoJson", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Transform, _>("preprocess_type", Self::VT_PREPROCESS_TYPE, "preprocess", Self::VT_PREPROCESS, false, |key, v, pos| {
        match key {
          Transform::TransformSql => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>("Transform::TransformSql", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MergeStrategy, _>("merge_type", Self::VT_MERGE_TYPE, "merge", Self::VT_MERGE, false, |key, v, pos| {
        match key {
          MergeStrategy::MergeStrategyAppend => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyAppend>>("MergeStrategy::MergeStrategyAppend", pos),
          MergeStrategy::MergeStrategyLedger => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyLedger>>("MergeStrategy::MergeStrategyLedger", pos),
          MergeStrategy::MergeStrategySnapshot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategySnapshot>>("MergeStrategy::MergeStrategySnapshot", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct AddPushSourceArgs<'a> {
    pub source_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub read_type: ReadStep,
    pub read: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub preprocess_type: Transform,
    pub preprocess: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub merge_type: MergeStrategy,
    pub merge: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for AddPushSourceArgs<'a> {
    #[inline]
    fn default() -> Self {
        AddPushSourceArgs {
            source_name: None,
            read_type: ReadStep::NONE,
            read: None,
            preprocess_type: Transform::NONE,
            preprocess: None,
            merge_type: MergeStrategy::NONE,
            merge: None,
        }
    }
}

pub struct AddPushSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AddPushSourceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_source_name(&mut self, source_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AddPushSource::VT_SOURCE_NAME,
            source_name,
        );
    }
    #[inline]
    pub fn add_read_type(&mut self, read_type: ReadStep) {
        self.fbb_
            .push_slot::<ReadStep>(AddPushSource::VT_READ_TYPE, read_type, ReadStep::NONE);
    }
    #[inline]
    pub fn add_read(&mut self, read: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AddPushSource::VT_READ, read);
    }
    #[inline]
    pub fn add_preprocess_type(&mut self, preprocess_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            AddPushSource::VT_PREPROCESS_TYPE,
            preprocess_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_preprocess(
        &mut self,
        preprocess: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AddPushSource::VT_PREPROCESS,
            preprocess,
        );
    }
    #[inline]
    pub fn add_merge_type(&mut self, merge_type: MergeStrategy) {
        self.fbb_.push_slot::<MergeStrategy>(
            AddPushSource::VT_MERGE_TYPE,
            merge_type,
            MergeStrategy::NONE,
        );
    }
    #[inline]
    pub fn add_merge(&mut self, merge: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AddPushSource::VT_MERGE, merge);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AddPushSourceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AddPushSourceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AddPushSource<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AddPushSource<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AddPushSource");
        ds.field("source_name", &self.source_name());
        ds.field("read_type", &self.read_type());
        match self.read_type() {
            ReadStep::ReadStepCsv => {
                if let Some(x) = self.read_as_read_step_csv() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepGeoJson => {
                if let Some(x) = self.read_as_read_step_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepEsriShapefile => {
                if let Some(x) = self.read_as_read_step_esri_shapefile() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepParquet => {
                if let Some(x) = self.read_as_read_step_parquet() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepJson => {
                if let Some(x) = self.read_as_read_step_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepNdJson => {
                if let Some(x) = self.read_as_read_step_nd_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepNdGeoJson => {
                if let Some(x) = self.read_as_read_step_nd_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("read", &x)
            }
        };
        ds.field("preprocess_type", &self.preprocess_type());
        match self.preprocess_type() {
            Transform::TransformSql => {
                if let Some(x) = self.preprocess_as_transform_sql() {
                    ds.field("preprocess", &x)
                } else {
                    ds.field(
                        "preprocess",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("preprocess", &x)
            }
        };
        ds.field("merge_type", &self.merge_type());
        match self.merge_type() {
            MergeStrategy::MergeStrategyAppend => {
                if let Some(x) = self.merge_as_merge_strategy_append() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategyLedger => {
                if let Some(x) = self.merge_as_merge_strategy_ledger() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategySnapshot => {
                if let Some(x) = self.merge_as_merge_strategy_snapshot() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("merge", &x)
            }
        };
        ds.finish()
    }
}
pub enum AttachmentEmbeddedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct AttachmentEmbedded<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttachmentEmbedded<'a> {
    type Inner = AttachmentEmbedded<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AttachmentEmbedded<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AttachmentEmbedded { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AttachmentEmbeddedArgs<'args>,
    ) -> flatbuffers::WIPOffset<AttachmentEmbedded<'bldr>> {
        let mut builder = AttachmentEmbeddedBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(AttachmentEmbedded::VT_PATH, None)
        }
    }
    #[inline]
    pub fn content(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(AttachmentEmbedded::VT_CONTENT, None)
        }
    }
}

impl flatbuffers::Verifiable for AttachmentEmbedded<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
            .finish();
        Ok(())
    }
}
pub struct AttachmentEmbeddedArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AttachmentEmbeddedArgs<'a> {
    #[inline]
    fn default() -> Self {
        AttachmentEmbeddedArgs {
            path: None,
            content: None,
        }
    }
}

pub struct AttachmentEmbeddedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AttachmentEmbeddedBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentEmbedded::VT_PATH, path);
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentEmbedded::VT_CONTENT, content);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AttachmentEmbeddedBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AttachmentEmbeddedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AttachmentEmbedded<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AttachmentEmbedded<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AttachmentEmbedded");
        ds.field("path", &self.path());
        ds.field("content", &self.content());
        ds.finish()
    }
}
pub enum AttachmentsEmbeddedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct AttachmentsEmbedded<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttachmentsEmbedded<'a> {
    type Inner = AttachmentsEmbedded<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> AttachmentsEmbedded<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AttachmentsEmbedded { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args AttachmentsEmbeddedArgs<'args>,
    ) -> flatbuffers::WIPOffset<AttachmentsEmbedded<'bldr>> {
        let mut builder = AttachmentsEmbeddedBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded>>,
            >>(AttachmentsEmbedded::VT_ITEMS, None)
        }
    }
}

impl flatbuffers::Verifiable for AttachmentsEmbedded<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AttachmentEmbedded>>,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct AttachmentsEmbeddedArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'a>>>,
        >,
    >,
}
impl<'a> Default for AttachmentsEmbeddedArgs<'a> {
    #[inline]
    fn default() -> Self {
        AttachmentsEmbeddedArgs { items: None }
    }
}

pub struct AttachmentsEmbeddedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AttachmentsEmbeddedBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentsEmbedded::VT_ITEMS, items);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> AttachmentsEmbeddedBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        AttachmentsEmbeddedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AttachmentsEmbedded<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AttachmentsEmbedded<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AttachmentsEmbedded");
        ds.field("items", &self.items());
        ds.finish()
    }
}
pub enum ExecuteTransformInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteTransformInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteTransformInput<'a> {
    type Inner = ExecuteTransformInput<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExecuteTransformInput<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_NEW_BLOCK_HASH: flatbuffers::VOffsetT = 8;
    pub const VT_PREV_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_OFFSET: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteTransformInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ExecuteTransformInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteTransformInput<'bldr>> {
        let mut builder = ExecuteTransformInputBuilder::new(_fbb);
        if let Some(x) = args.new_offset {
            builder.add_new_offset(x);
        }
        if let Some(x) = args.prev_offset {
            builder.add_prev_offset(x);
        }
        if let Some(x) = args.new_block_hash {
            builder.add_new_block_hash(x);
        }
        if let Some(x) = args.prev_block_hash {
            builder.add_prev_block_hash(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ExecuteTransformInput::VT_DATASET_ID,
                    None,
                )
        }
    }
    #[inline]
    pub fn prev_block_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ExecuteTransformInput::VT_PREV_BLOCK_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn new_block_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ExecuteTransformInput::VT_NEW_BLOCK_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn prev_offset(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExecuteTransformInput::VT_PREV_OFFSET, None)
        }
    }
    #[inline]
    pub fn new_offset(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(ExecuteTransformInput::VT_NEW_OFFSET, None)
        }
    }
}

impl flatbuffers::Verifiable for ExecuteTransformInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "prev_block_hash",
                Self::VT_PREV_BLOCK_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "new_block_hash",
                Self::VT_NEW_BLOCK_HASH,
                false,
            )?
            .visit_field::<u64>("prev_offset", Self::VT_PREV_OFFSET, false)?
            .visit_field::<u64>("new_offset", Self::VT_NEW_OFFSET, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteTransformInputArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub new_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub prev_offset: Option<u64>,
    pub new_offset: Option<u64>,
}
impl<'a> Default for ExecuteTransformInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteTransformInputArgs {
            dataset_id: None,
            prev_block_hash: None,
            new_block_hash: None,
            prev_offset: None,
            new_offset: None,
        }
    }
}

pub struct ExecuteTransformInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExecuteTransformInputBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteTransformInput::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_prev_block_hash(
        &mut self,
        prev_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteTransformInput::VT_PREV_BLOCK_HASH,
            prev_block_hash,
        );
    }
    #[inline]
    pub fn add_new_block_hash(
        &mut self,
        new_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteTransformInput::VT_NEW_BLOCK_HASH,
            new_block_hash,
        );
    }
    #[inline]
    pub fn add_prev_offset(&mut self, prev_offset: u64) {
        self.fbb_
            .push_slot_always::<u64>(ExecuteTransformInput::VT_PREV_OFFSET, prev_offset);
    }
    #[inline]
    pub fn add_new_offset(&mut self, new_offset: u64) {
        self.fbb_
            .push_slot_always::<u64>(ExecuteTransformInput::VT_NEW_OFFSET, new_offset);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ExecuteTransformInputBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ExecuteTransformInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteTransformInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteTransformInput<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteTransformInput");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("prev_block_hash", &self.prev_block_hash());
        ds.field("new_block_hash", &self.new_block_hash());
        ds.field("prev_offset", &self.prev_offset());
        ds.field("new_offset", &self.new_offset());
        ds.finish()
    }
}
pub enum ExecuteTransformOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteTransform<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteTransform<'a> {
    type Inner = ExecuteTransform<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ExecuteTransform<'a> {
    pub const VT_QUERY_INPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_CHECKPOINT: flatbuffers::VOffsetT = 6;
    pub const VT_PREV_OFFSET: flatbuffers::VOffsetT = 8;
    pub const VT_NEW_DATA: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_CHECKPOINT: flatbuffers::VOffsetT = 12;
    pub const VT_NEW_WATERMARK: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteTransform { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ExecuteTransformArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteTransform<'bldr>> {
        let mut builder = ExecuteTransformBuilder::new(_fbb);
        if let Some(x) = args.prev_offset {
            builder.add_prev_offset(x);
        }
        if let Some(x) = args.new_watermark {
            builder.add_new_watermark(x);
        }
        if let Some(x) = args.new_checkpoint {
            builder.add_new_checkpoint(x);
        }
        if let Some(x) = args.new_data {
            builder.add_new_data(x);
        }
        if let Some(x) = args.prev_checkpoint {
            builder.add_prev_checkpoint(x);
        }
        if let Some(x) = args.query_inputs {
            builder.add_query_inputs(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn query_inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteTransformInput<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteTransformInput>>,
            >>(ExecuteTransform::VT_QUERY_INPUTS, None)
        }
    }
    #[inline]
    pub fn prev_checkpoint(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    ExecuteTransform::VT_PREV_CHECKPOINT,
                    None,
                )
        }
    }
    #[inline]
    pub fn prev_offset(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(ExecuteTransform::VT_PREV_OFFSET, None) }
    }
    #[inline]
    pub fn new_data(&self) -> Option<DataSlice<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DataSlice>>(ExecuteTransform::VT_NEW_DATA, None)
        }
    }
    #[inline]
    pub fn new_checkpoint(&self) -> Option<Checkpoint<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<Checkpoint>>(
                ExecuteTransform::VT_NEW_CHECKPOINT,
                None,
            )
        }
    }
    #[inline]
    pub fn new_watermark(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Timestamp>(ExecuteTransform::VT_NEW_WATERMARK, None)
        }
    }
}

impl flatbuffers::Verifiable for ExecuteTransform<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ExecuteTransformInput>>,
            >>("query_inputs", Self::VT_QUERY_INPUTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "prev_checkpoint",
                Self::VT_PREV_CHECKPOINT,
                false,
            )?
            .visit_field::<u64>("prev_offset", Self::VT_PREV_OFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DataSlice>>(
                "new_data",
                Self::VT_NEW_DATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Checkpoint>>(
                "new_checkpoint",
                Self::VT_NEW_CHECKPOINT,
                false,
            )?
            .visit_field::<Timestamp>("new_watermark", Self::VT_NEW_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteTransformArgs<'a> {
    pub query_inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteTransformInput<'a>>>,
        >,
    >,
    pub prev_checkpoint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub prev_offset: Option<u64>,
    pub new_data: Option<flatbuffers::WIPOffset<DataSlice<'a>>>,
    pub new_checkpoint: Option<flatbuffers::WIPOffset<Checkpoint<'a>>>,
    pub new_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for ExecuteTransformArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteTransformArgs {
            query_inputs: None,
            prev_checkpoint: None,
            prev_offset: None,
            new_data: None,
            new_checkpoint: None,
            new_watermark: None,
        }
    }
}

pub struct ExecuteTransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExecuteTransformBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_query_inputs(
        &mut self,
        query_inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ExecuteTransformInput<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteTransform::VT_QUERY_INPUTS,
            query_inputs,
        );
    }
    #[inline]
    pub fn add_prev_checkpoint(
        &mut self,
        prev_checkpoint: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteTransform::VT_PREV_CHECKPOINT,
            prev_checkpoint,
        );
    }
    #[inline]
    pub fn add_prev_offset(&mut self, prev_offset: u64) {
        self.fbb_
            .push_slot_always::<u64>(ExecuteTransform::VT_PREV_OFFSET, prev_offset);
    }
    #[inline]
    pub fn add_new_data(&mut self, new_data: flatbuffers::WIPOffset<DataSlice<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DataSlice>>(
                ExecuteTransform::VT_NEW_DATA,
                new_data,
            );
    }
    #[inline]
    pub fn add_new_checkpoint(&mut self, new_checkpoint: flatbuffers::WIPOffset<Checkpoint<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Checkpoint>>(
                ExecuteTransform::VT_NEW_CHECKPOINT,
                new_checkpoint,
            );
    }
    #[inline]
    pub fn add_new_watermark(&mut self, new_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(ExecuteTransform::VT_NEW_WATERMARK, new_watermark);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> ExecuteTransformBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ExecuteTransformBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteTransform<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteTransform<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteTransform");
        ds.field("query_inputs", &self.query_inputs());
        ds.field("prev_checkpoint", &self.prev_checkpoint());
        ds.field("prev_offset", &self.prev_offset());
        ds.field("new_data", &self.new_data());
        ds.field("new_checkpoint", &self.new_checkpoint());
        ds.field("new_watermark", &self.new_watermark());
        ds.finish()
    }
}
pub enum SeedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct Seed<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Seed<'a> {
    type Inner = Seed<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Seed<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_KIND: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Seed { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SeedArgs<'args>,
    ) -> flatbuffers::WIPOffset<Seed<'bldr>> {
        let mut builder = SeedBuilder::new(_fbb);
        builder.add_dataset_kind(args.dataset_kind);
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Seed::VT_DATASET_ID,
                    None,
                )
        }
    }
    #[inline]
    pub fn dataset_kind(&self) -> DatasetKind {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DatasetKind>(Seed::VT_DATASET_KIND, Some(DatasetKind::Root))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Seed<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<DatasetKind>("dataset_kind", Self::VT_DATASET_KIND, false)?
            .finish();
        Ok(())
    }
}
pub struct SeedArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_kind: DatasetKind,
}
impl<'a> Default for SeedArgs<'a> {
    #[inline]
    fn default() -> Self {
        SeedArgs {
            dataset_id: None,
            dataset_kind: DatasetKind::Root,
        }
    }
}

pub struct SeedBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SeedBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Seed::VT_DATASET_ID, dataset_id);
    }
    #[inline]
    pub fn add_dataset_kind(&mut self, dataset_kind: DatasetKind) {
        self.fbb_
            .push_slot::<DatasetKind>(Seed::VT_DATASET_KIND, dataset_kind, DatasetKind::Root);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SeedBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SeedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Seed<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Seed<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Seed");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_kind", &self.dataset_kind());
        ds.finish()
    }
}
pub enum EventTimeSourceFromMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromMetadata<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromMetadata<'a> {
    type Inner = EventTimeSourceFromMetadata<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EventTimeSourceFromMetadata<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromMetadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args EventTimeSourceFromMetadataArgs,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'bldr>> {
        let mut builder = EventTimeSourceFromMetadataBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromMetadata<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromMetadataArgs {}
impl<'a> Default for EventTimeSourceFromMetadataArgs {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromMetadataArgs {}
    }
}

pub struct EventTimeSourceFromMetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventTimeSourceFromMetadataBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> EventTimeSourceFromMetadataBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EventTimeSourceFromMetadataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EventTimeSourceFromMetadata<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromMetadata");
        ds.finish()
    }
}
pub enum EventTimeSourceFromPathOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromPath<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromPath<'a> {
    type Inner = EventTimeSourceFromPath<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EventTimeSourceFromPath<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromPath { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EventTimeSourceFromPathArgs<'args>,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'bldr>> {
        let mut builder = EventTimeSourceFromPathBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                EventTimeSourceFromPath::VT_PATTERN,
                None,
            )
        }
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromPath<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromPathArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EventTimeSourceFromPathArgs<'a> {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromPathArgs {
            pattern: None,
            timestamp_format: None,
        }
    }
}

pub struct EventTimeSourceFromPathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventTimeSourceFromPathBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_PATTERN,
            pattern,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> EventTimeSourceFromPathBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EventTimeSourceFromPathBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EventTimeSourceFromPath<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromPath");
        ds.field("pattern", &self.pattern());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum EventTimeSourceFromSystemTimeOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromSystemTime<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromSystemTime<'a> {
    type Inner = EventTimeSourceFromSystemTime<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EventTimeSourceFromSystemTime<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromSystemTime { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args EventTimeSourceFromSystemTimeArgs,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromSystemTime<'bldr>> {
        let mut builder = EventTimeSourceFromSystemTimeBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromSystemTime<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromSystemTimeArgs {}
impl<'a> Default for EventTimeSourceFromSystemTimeArgs {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromSystemTimeArgs {}
    }
}

pub struct EventTimeSourceFromSystemTimeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EventTimeSourceFromSystemTimeBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> EventTimeSourceFromSystemTimeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EventTimeSourceFromSystemTimeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromSystemTime<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EventTimeSourceFromSystemTime<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromSystemTime");
        ds.finish()
    }
}
pub enum SourceCachingForeverOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SourceCachingForever<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceCachingForever<'a> {
    type Inner = SourceCachingForever<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SourceCachingForever<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceCachingForever { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args SourceCachingForeverArgs,
    ) -> flatbuffers::WIPOffset<SourceCachingForever<'bldr>> {
        let mut builder = SourceCachingForeverBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for SourceCachingForever<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct SourceCachingForeverArgs {}
impl<'a> Default for SourceCachingForeverArgs {
    #[inline]
    fn default() -> Self {
        SourceCachingForeverArgs {}
    }
}

pub struct SourceCachingForeverBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SourceCachingForeverBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SourceCachingForeverBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SourceCachingForeverBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SourceCachingForever<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SourceCachingForever<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SourceCachingForever");
        ds.finish()
    }
}
pub enum RequestHeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RequestHeader<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RequestHeader<'a> {
    type Inner = RequestHeader<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RequestHeader<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RequestHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RequestHeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<RequestHeader<'bldr>> {
        let mut builder = RequestHeaderBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RequestHeader::VT_NAME, None)
        }
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RequestHeader::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for RequestHeader<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct RequestHeaderArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RequestHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        RequestHeaderArgs {
            name: None,
            value: None,
        }
    }
}

pub struct RequestHeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RequestHeaderBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RequestHeader::VT_NAME, name);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RequestHeader::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RequestHeaderBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RequestHeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RequestHeader<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RequestHeader<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RequestHeader");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum FetchStepUrlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepUrl<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepUrl<'a> {
    type Inner = FetchStepUrl<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FetchStepUrl<'a> {
    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;
    pub const VT_HEADERS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepUrl { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FetchStepUrlArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepUrl<'bldr>> {
        let mut builder = FetchStepUrlBuilder::new(_fbb);
        if let Some(x) = args.headers {
            builder.add_headers(x);
        }
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.url {
            builder.add_url(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn url(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepUrl::VT_URL, None)
        }
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<EventTimeSource>(
                    FetchStepUrl::VT_EVENT_TIME_TYPE,
                    Some(EventTimeSource::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FetchStepUrl::VT_EVENT_TIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SourceCaching>(FetchStepUrl::VT_CACHE_TYPE, Some(SourceCaching::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FetchStepUrl::VT_CACHE,
                    None,
                )
        }
    }
    #[inline]
    pub fn headers(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RequestHeader<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RequestHeader>>,
            >>(FetchStepUrl::VT_HEADERS, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromMetadata::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromPath::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_system_time(
        &self,
    ) -> Option<EventTimeSourceFromSystemTime<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromSystemTime {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromSystemTime::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SourceCachingForever::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepUrl<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          EventTimeSource::EventTimeSourceFromSystemTime => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromSystemTime>>("EventTimeSource::EventTimeSourceFromSystemTime", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RequestHeader>>>>("headers", Self::VT_HEADERS, false)?
     .finish();
        Ok(())
    }
}
pub struct FetchStepUrlArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub headers: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RequestHeader<'a>>>,
        >,
    >,
}
impl<'a> Default for FetchStepUrlArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepUrlArgs {
            url: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
            headers: None,
        }
    }
}

pub struct FetchStepUrlBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FetchStepUrlBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_URL, url);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepUrl::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepUrl::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_CACHE, cache);
    }
    #[inline]
    pub fn add_headers(
        &mut self,
        headers: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RequestHeader<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_HEADERS, headers);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FetchStepUrlBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FetchStepUrlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepUrl<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepUrl<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepUrl");
        ds.field("url", &self.url());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromSystemTime => {
                if let Some(x) = self.event_time_as_event_time_source_from_system_time() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.field("headers", &self.headers());
        ds.finish()
    }
}
pub enum FetchStepFilesGlobOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepFilesGlob<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepFilesGlob<'a> {
    type Inner = FetchStepFilesGlob<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FetchStepFilesGlob<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;
    pub const VT_ORDER: flatbuffers::VOffsetT = 14;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepFilesGlob { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FetchStepFilesGlobArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'bldr>> {
        let mut builder = FetchStepFilesGlobBuilder::new(_fbb);
        if let Some(x) = args.order {
            builder.add_order(x);
        }
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepFilesGlob::VT_PATH, None)
        }
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<EventTimeSource>(
                    FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
                    Some(EventTimeSource::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FetchStepFilesGlob::VT_EVENT_TIME,
                    None,
                )
        }
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SourceCaching>(FetchStepFilesGlob::VT_CACHE_TYPE, Some(SourceCaching::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    FetchStepFilesGlob::VT_CACHE,
                    None,
                )
        }
    }
    #[inline]
    pub fn order(&self) -> Option<SourceOrdering> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromMetadata::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromPath::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_system_time(
        &self,
    ) -> Option<EventTimeSourceFromSystemTime<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromSystemTime {
            self.event_time().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { EventTimeSourceFromSystemTime::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SourceCachingForever::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepFilesGlob<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          EventTimeSource::EventTimeSourceFromSystemTime => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromSystemTime>>("EventTimeSource::EventTimeSourceFromSystemTime", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<SourceOrdering>("order", Self::VT_ORDER, false)?
     .finish();
        Ok(())
    }
}
pub struct FetchStepFilesGlobArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub order: Option<SourceOrdering>,
}
impl<'a> Default for FetchStepFilesGlobArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepFilesGlobArgs {
            path: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
            order: None,
        }
    }
}

pub struct FetchStepFilesGlobBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FetchStepFilesGlobBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_PATH, path);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepFilesGlob::VT_EVENT_TIME,
            event_time,
        );
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepFilesGlob::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_CACHE, cache);
    }
    #[inline]
    pub fn add_order(&mut self, order: SourceOrdering) {
        self.fbb_
            .push_slot_always::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, order);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FetchStepFilesGlobBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FetchStepFilesGlobBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepFilesGlob<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepFilesGlob");
        ds.field("path", &self.path());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromSystemTime => {
                if let Some(x) = self.event_time_as_event_time_source_from_system_time() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.field("order", &self.order());
        ds.finish()
    }
}
pub enum EnvVarOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct EnvVar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnvVar<'a> {
    type Inner = EnvVar<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> EnvVar<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EnvVar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args EnvVarArgs<'args>,
    ) -> flatbuffers::WIPOffset<EnvVar<'bldr>> {
        let mut builder = EnvVarBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(EnvVar::VT_NAME, None)
        }
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(EnvVar::VT_VALUE, None)
        }
    }
}

impl flatbuffers::Verifiable for EnvVar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct EnvVarArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnvVarArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnvVarArgs {
            name: None,
            value: None,
        }
    }
}

pub struct EnvVarBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> EnvVarBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvVar::VT_NAME, name);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvVar::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> EnvVarBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        EnvVarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EnvVar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EnvVar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EnvVar");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum FetchStepContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepContainer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepContainer<'a> {
    type Inner = FetchStepContainer<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FetchStepContainer<'a> {
    pub const VT_IMAGE: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 6;
    pub const VT_ARGS: flatbuffers::VOffsetT = 8;
    pub const VT_ENV: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepContainer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FetchStepContainerArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepContainer<'bldr>> {
        let mut builder = FetchStepContainerBuilder::new(_fbb);
        if let Some(x) = args.env {
            builder.add_env(x);
        }
        if let Some(x) = args.args {
            builder.add_args(x);
        }
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        if let Some(x) = args.image {
            builder.add_image(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn image(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepContainer::VT_IMAGE, None)
        }
    }
    #[inline]
    pub fn command(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(FetchStepContainer::VT_COMMAND, None)
        }
    }
    #[inline]
    pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(FetchStepContainer::VT_ARGS, None)
        }
    }
    #[inline]
    pub fn env(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar>>,
            >>(FetchStepContainer::VT_ENV, None)
        }
    }
}

impl flatbuffers::Verifiable for FetchStepContainer<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("command", Self::VT_COMMAND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("args", Self::VT_ARGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnvVar>>,
            >>("env", Self::VT_ENV, false)?
            .finish();
        Ok(())
    }
}
pub struct FetchStepContainerArgs<'a> {
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub command: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub args: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub env: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar<'a>>>>,
    >,
}
impl<'a> Default for FetchStepContainerArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepContainerArgs {
            image: None,
            command: None,
            args: None,
            env: None,
        }
    }
}

pub struct FetchStepContainerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FetchStepContainerBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_IMAGE, image);
    }
    #[inline]
    pub fn add_command(
        &mut self,
        command: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_COMMAND, command);
    }
    #[inline]
    pub fn add_args(
        &mut self,
        args: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_ARGS, args);
    }
    #[inline]
    pub fn add_env(
        &mut self,
        env: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<EnvVar<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_ENV, env);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FetchStepContainerBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FetchStepContainerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepContainer<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepContainer<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepContainer");
        ds.field("image", &self.image());
        ds.field("command", &self.command());
        ds.field("args", &self.args());
        ds.field("env", &self.env());
        ds.finish()
    }
}
pub enum MqttTopicSubscriptionOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct MqttTopicSubscription<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MqttTopicSubscription<'a> {
    type Inner = MqttTopicSubscription<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MqttTopicSubscription<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_QOS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MqttTopicSubscription { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MqttTopicSubscriptionArgs<'args>,
    ) -> flatbuffers::WIPOffset<MqttTopicSubscription<'bldr>> {
        let mut builder = MqttTopicSubscriptionBuilder::new(_fbb);
        if let Some(x) = args.qos {
            builder.add_qos(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(MqttTopicSubscription::VT_PATH, None)
        }
    }
    #[inline]
    pub fn qos(&self) -> Option<MqttQos> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MqttQos>(MqttTopicSubscription::VT_QOS, None)
        }
    }
}

impl flatbuffers::Verifiable for MqttTopicSubscription<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
            .visit_field::<MqttQos>("qos", Self::VT_QOS, false)?
            .finish();
        Ok(())
    }
}
pub struct MqttTopicSubscriptionArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub qos: Option<MqttQos>,
}
impl<'a> Default for MqttTopicSubscriptionArgs<'a> {
    #[inline]
    fn default() -> Self {
        MqttTopicSubscriptionArgs {
            path: None,
            qos: None,
        }
    }
}

pub struct MqttTopicSubscriptionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MqttTopicSubscriptionBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MqttTopicSubscription::VT_PATH, path);
    }
    #[inline]
    pub fn add_qos(&mut self, qos: MqttQos) {
        self.fbb_
            .push_slot_always::<MqttQos>(MqttTopicSubscription::VT_QOS, qos);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MqttTopicSubscriptionBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MqttTopicSubscriptionBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MqttTopicSubscription<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MqttTopicSubscription<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MqttTopicSubscription");
        ds.field("path", &self.path());
        ds.field("qos", &self.qos());
        ds.finish()
    }
}
pub enum FetchStepMqttOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepMqtt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepMqtt<'a> {
    type Inner = FetchStepMqtt<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FetchStepMqtt<'a> {
    pub const VT_HOST: flatbuffers::VOffsetT = 4;
    pub const VT_PORT: flatbuffers::VOffsetT = 6;
    pub const VT_USERNAME: flatbuffers::VOffsetT = 8;
    pub const VT_PASSWORD: flatbuffers::VOffsetT = 10;
    pub const VT_TOPICS: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepMqtt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FetchStepMqttArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepMqtt<'bldr>> {
        let mut builder = FetchStepMqttBuilder::new(_fbb);
        if let Some(x) = args.topics {
            builder.add_topics(x);
        }
        if let Some(x) = args.password {
            builder.add_password(x);
        }
        if let Some(x) = args.username {
            builder.add_username(x);
        }
        builder.add_port(args.port);
        if let Some(x) = args.host {
            builder.add_host(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn host(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepMqtt::VT_HOST, None)
        }
    }
    #[inline]
    pub fn port(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i32>(FetchStepMqtt::VT_PORT, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn username(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepMqtt::VT_USERNAME, None)
        }
    }
    #[inline]
    pub fn password(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepMqtt::VT_PASSWORD, None)
        }
    }
    #[inline]
    pub fn topics(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MqttTopicSubscription<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MqttTopicSubscription>>,
            >>(FetchStepMqtt::VT_TOPICS, None)
        }
    }
}

impl flatbuffers::Verifiable for FetchStepMqtt<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("host", Self::VT_HOST, false)?
            .visit_field::<i32>("port", Self::VT_PORT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "username",
                Self::VT_USERNAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "password",
                Self::VT_PASSWORD,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MqttTopicSubscription>>,
            >>("topics", Self::VT_TOPICS, false)?
            .finish();
        Ok(())
    }
}
pub struct FetchStepMqttArgs<'a> {
    pub host: Option<flatbuffers::WIPOffset<&'a str>>,
    pub port: i32,
    pub username: Option<flatbuffers::WIPOffset<&'a str>>,
    pub password: Option<flatbuffers::WIPOffset<&'a str>>,
    pub topics: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MqttTopicSubscription<'a>>>,
        >,
    >,
}
impl<'a> Default for FetchStepMqttArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepMqttArgs {
            host: None,
            port: 0,
            username: None,
            password: None,
            topics: None,
        }
    }
}

pub struct FetchStepMqttBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FetchStepMqttBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_host(&mut self, host: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepMqtt::VT_HOST, host);
    }
    #[inline]
    pub fn add_port(&mut self, port: i32) {
        self.fbb_.push_slot::<i32>(FetchStepMqtt::VT_PORT, port, 0);
    }
    #[inline]
    pub fn add_username(&mut self, username: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepMqtt::VT_USERNAME, username);
    }
    #[inline]
    pub fn add_password(&mut self, password: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepMqtt::VT_PASSWORD, password);
    }
    #[inline]
    pub fn add_topics(
        &mut self,
        topics: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MqttTopicSubscription<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepMqtt::VT_TOPICS, topics);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FetchStepMqttBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FetchStepMqttBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepMqtt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepMqtt<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepMqtt");
        ds.field("host", &self.host());
        ds.field("port", &self.port());
        ds.field("username", &self.username());
        ds.field("password", &self.password());
        ds.field("topics", &self.topics());
        ds.finish()
    }
}
pub enum FetchStepEthereumLogsOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepEthereumLogs<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepEthereumLogs<'a> {
    type Inner = FetchStepEthereumLogs<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> FetchStepEthereumLogs<'a> {
    pub const VT_CHAIN_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NODE_URL: flatbuffers::VOffsetT = 6;
    pub const VT_FILTER: flatbuffers::VOffsetT = 8;
    pub const VT_SIGNATURE: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepEthereumLogs { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args FetchStepEthereumLogsArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepEthereumLogs<'bldr>> {
        let mut builder = FetchStepEthereumLogsBuilder::new(_fbb);
        if let Some(x) = args.chain_id {
            builder.add_chain_id(x);
        }
        if let Some(x) = args.signature {
            builder.add_signature(x);
        }
        if let Some(x) = args.filter {
            builder.add_filter(x);
        }
        if let Some(x) = args.node_url {
            builder.add_node_url(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn chain_id(&self) -> Option<u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(FetchStepEthereumLogs::VT_CHAIN_ID, None)
        }
    }
    #[inline]
    pub fn node_url(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepEthereumLogs::VT_NODE_URL, None)
        }
    }
    #[inline]
    pub fn filter(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepEthereumLogs::VT_FILTER, None)
        }
    }
    #[inline]
    pub fn signature(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                FetchStepEthereumLogs::VT_SIGNATURE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for FetchStepEthereumLogs<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("chain_id", Self::VT_CHAIN_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "node_url",
                Self::VT_NODE_URL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("filter", Self::VT_FILTER, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "signature",
                Self::VT_SIGNATURE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct FetchStepEthereumLogsArgs<'a> {
    pub chain_id: Option<u64>,
    pub node_url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub filter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub signature: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FetchStepEthereumLogsArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepEthereumLogsArgs {
            chain_id: None,
            node_url: None,
            filter: None,
            signature: None,
        }
    }
}

pub struct FetchStepEthereumLogsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FetchStepEthereumLogsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_chain_id(&mut self, chain_id: u64) {
        self.fbb_
            .push_slot_always::<u64>(FetchStepEthereumLogs::VT_CHAIN_ID, chain_id);
    }
    #[inline]
    pub fn add_node_url(&mut self, node_url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepEthereumLogs::VT_NODE_URL,
            node_url,
        );
    }
    #[inline]
    pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepEthereumLogs::VT_FILTER,
            filter,
        );
    }
    #[inline]
    pub fn add_signature(&mut self, signature: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepEthereumLogs::VT_SIGNATURE,
            signature,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> FetchStepEthereumLogsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        FetchStepEthereumLogsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepEthereumLogs<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepEthereumLogs<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepEthereumLogs");
        ds.field("chain_id", &self.chain_id());
        ds.field("node_url", &self.node_url());
        ds.field("filter", &self.filter());
        ds.field("signature", &self.signature());
        ds.finish()
    }
}
pub enum PrepStepDecompressOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct PrepStepDecompress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepDecompress<'a> {
    type Inner = PrepStepDecompress<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PrepStepDecompress<'a> {
    pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepDecompress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PrepStepDecompressArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepDecompress<'bldr>> {
        let mut builder = PrepStepDecompressBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        builder.add_format(args.format);
        builder.finish()
    }

    #[inline]
    pub fn format(&self) -> CompressionFormat {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<CompressionFormat>(
                    PrepStepDecompress::VT_FORMAT,
                    Some(CompressionFormat::Gzip),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(PrepStepDecompress::VT_SUB_PATH, None)
        }
    }
}

impl flatbuffers::Verifiable for PrepStepDecompress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<CompressionFormat>("format", Self::VT_FORMAT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepDecompressArgs<'a> {
    pub format: CompressionFormat,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PrepStepDecompressArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepDecompressArgs {
            format: CompressionFormat::Gzip,
            sub_path: None,
        }
    }
}

pub struct PrepStepDecompressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrepStepDecompressBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_format(&mut self, format: CompressionFormat) {
        self.fbb_.push_slot::<CompressionFormat>(
            PrepStepDecompress::VT_FORMAT,
            format,
            CompressionFormat::Gzip,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PrepStepDecompress::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> PrepStepDecompressBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PrepStepDecompressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepDecompress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepDecompress<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepDecompress");
        ds.field("format", &self.format());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum PrepStepPipeOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct PrepStepPipe<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepPipe<'a> {
    type Inner = PrepStepPipe<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PrepStepPipe<'a> {
    pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepPipe { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PrepStepPipeArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepPipe<'bldr>> {
        let mut builder = PrepStepPipeBuilder::new(_fbb);
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn command(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(PrepStepPipe::VT_COMMAND, None)
        }
    }
}

impl flatbuffers::Verifiable for PrepStepPipe<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("command", Self::VT_COMMAND, false)?
            .finish();
        Ok(())
    }
}
pub struct PrepStepPipeArgs<'a> {
    pub command: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for PrepStepPipeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepPipeArgs { command: None }
    }
}

pub struct PrepStepPipeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrepStepPipeBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_command(
        &mut self,
        command: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepPipe::VT_COMMAND, command);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> PrepStepPipeBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PrepStepPipeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepPipe<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepPipe<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepPipe");
        ds.field("command", &self.command());
        ds.finish()
    }
}
pub enum PrepStepWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepStepWrapper<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepWrapper<'a> {
    type Inner = PrepStepWrapper<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PrepStepWrapper<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args PrepStepWrapperArgs,
    ) -> flatbuffers::WIPOffset<PrepStepWrapper<'bldr>> {
        let mut builder = PrepStepWrapperBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> PrepStep {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, Some(PrepStep::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    PrepStepWrapper::VT_VALUE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_decompress(&self) -> Option<PrepStepDecompress<'a>> {
        if self.value_type() == PrepStep::PrepStepDecompress {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { PrepStepDecompress::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_pipe(&self) -> Option<PrepStepPipe<'a>> {
        if self.value_type() == PrepStep::PrepStepPipe {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { PrepStepPipe::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for PrepStepWrapper<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<PrepStep, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    PrepStep::PrepStepDecompress => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepDecompress>>(
                            "PrepStep::PrepStepDecompress",
                            pos,
                        ),
                    PrepStep::PrepStepPipe => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepPipe>>(
                            "PrepStep::PrepStepPipe",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepWrapperArgs {
    pub value_type: PrepStep,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PrepStepWrapperArgs {
    #[inline]
    fn default() -> Self {
        PrepStepWrapperArgs {
            value_type: PrepStep::NONE,
            value: None,
        }
    }
}

pub struct PrepStepWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrepStepWrapperBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: PrepStep) {
        self.fbb_
            .push_slot::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, value_type, PrepStep::NONE);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepWrapper::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> PrepStepWrapperBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        PrepStepWrapperBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepWrapper<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepWrapper<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepWrapper");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            PrepStep::PrepStepDecompress => {
                if let Some(x) = self.value_as_prep_step_decompress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            PrepStep::PrepStepPipe => {
                if let Some(x) = self.value_as_prep_step_pipe() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetPollingSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetPollingSource<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetPollingSource<'a> {
    type Inner = SetPollingSource<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetPollingSource<'a> {
    pub const VT_FETCH_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FETCH: flatbuffers::VOffsetT = 6;
    pub const VT_PREPARE: flatbuffers::VOffsetT = 8;
    pub const VT_READ_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_READ: flatbuffers::VOffsetT = 12;
    pub const VT_PREPROCESS_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_PREPROCESS: flatbuffers::VOffsetT = 16;
    pub const VT_MERGE_TYPE: flatbuffers::VOffsetT = 18;
    pub const VT_MERGE: flatbuffers::VOffsetT = 20;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetPollingSource { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetPollingSourceArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetPollingSource<'bldr>> {
        let mut builder = SetPollingSourceBuilder::new(_fbb);
        if let Some(x) = args.merge {
            builder.add_merge(x);
        }
        if let Some(x) = args.preprocess {
            builder.add_preprocess(x);
        }
        if let Some(x) = args.read {
            builder.add_read(x);
        }
        if let Some(x) = args.prepare {
            builder.add_prepare(x);
        }
        if let Some(x) = args.fetch {
            builder.add_fetch(x);
        }
        builder.add_merge_type(args.merge_type);
        builder.add_preprocess_type(args.preprocess_type);
        builder.add_read_type(args.read_type);
        builder.add_fetch_type(args.fetch_type);
        builder.finish()
    }

    #[inline]
    pub fn fetch_type(&self) -> FetchStep {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<FetchStep>(SetPollingSource::VT_FETCH_TYPE, Some(FetchStep::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn fetch(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetPollingSource::VT_FETCH,
                    None,
                )
        }
    }
    #[inline]
    pub fn prepare(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper>>,
            >>(SetPollingSource::VT_PREPARE, None)
        }
    }
    #[inline]
    pub fn read_type(&self) -> ReadStep {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ReadStep>(SetPollingSource::VT_READ_TYPE, Some(ReadStep::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn read(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetPollingSource::VT_READ,
                    None,
                )
        }
    }
    #[inline]
    pub fn preprocess_type(&self) -> Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(SetPollingSource::VT_PREPROCESS_TYPE, Some(Transform::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn preprocess(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetPollingSource::VT_PREPROCESS,
                    None,
                )
        }
    }
    #[inline]
    pub fn merge_type(&self) -> MergeStrategy {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MergeStrategy>(SetPollingSource::VT_MERGE_TYPE, Some(MergeStrategy::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn merge(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetPollingSource::VT_MERGE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_url(&self) -> Option<FetchStepUrl<'a>> {
        if self.fetch_type() == FetchStep::FetchStepUrl {
            self.fetch().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FetchStepUrl::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_files_glob(&self) -> Option<FetchStepFilesGlob<'a>> {
        if self.fetch_type() == FetchStep::FetchStepFilesGlob {
            self.fetch().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FetchStepFilesGlob::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_container(&self) -> Option<FetchStepContainer<'a>> {
        if self.fetch_type() == FetchStep::FetchStepContainer {
            self.fetch().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FetchStepContainer::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_mqtt(&self) -> Option<FetchStepMqtt<'a>> {
        if self.fetch_type() == FetchStep::FetchStepMqtt {
            self.fetch().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FetchStepMqtt::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_ethereum_logs(&self) -> Option<FetchStepEthereumLogs<'a>> {
        if self.fetch_type() == FetchStep::FetchStepEthereumLogs {
            self.fetch().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { FetchStepEthereumLogs::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_csv(&self) -> Option<ReadStepCsv<'a>> {
        if self.read_type() == ReadStep::ReadStepCsv {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepCsv::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_geo_json(&self) -> Option<ReadStepGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepGeoJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepGeoJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_esri_shapefile(&self) -> Option<ReadStepEsriShapefile<'a>> {
        if self.read_type() == ReadStep::ReadStepEsriShapefile {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepEsriShapefile::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_parquet(&self) -> Option<ReadStepParquet<'a>> {
        if self.read_type() == ReadStep::ReadStepParquet {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepParquet::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_json(&self) -> Option<ReadStepJson<'a>> {
        if self.read_type() == ReadStep::ReadStepJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_nd_json(&self) -> Option<ReadStepNdJson<'a>> {
        if self.read_type() == ReadStep::ReadStepNdJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepNdJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_nd_geo_json(&self) -> Option<ReadStepNdGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepNdGeoJson {
            self.read().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ReadStepNdGeoJson::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn preprocess_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.preprocess_type() == Transform::TransformSql {
            self.preprocess().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformSql::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_append(&self) -> Option<MergeStrategyAppend<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyAppend {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategyAppend::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_ledger(&self) -> Option<MergeStrategyLedger<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyLedger {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategyLedger::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_snapshot(&self) -> Option<MergeStrategySnapshot<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategySnapshot {
            self.merge().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { MergeStrategySnapshot::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetPollingSource<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<FetchStep, _>("fetch_type", Self::VT_FETCH_TYPE, "fetch", Self::VT_FETCH, false, |key, v, pos| {
        match key {
          FetchStep::FetchStepUrl => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepUrl>>("FetchStep::FetchStepUrl", pos),
          FetchStep::FetchStepFilesGlob => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepFilesGlob>>("FetchStep::FetchStepFilesGlob", pos),
          FetchStep::FetchStepContainer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepContainer>>("FetchStep::FetchStepContainer", pos),
          FetchStep::FetchStepMqtt => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepMqtt>>("FetchStep::FetchStepMqtt", pos),
          FetchStep::FetchStepEthereumLogs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepEthereumLogs>>("FetchStep::FetchStepEthereumLogs", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PrepStepWrapper>>>>("prepare", Self::VT_PREPARE, false)?
     .visit_union::<ReadStep, _>("read_type", Self::VT_READ_TYPE, "read", Self::VT_READ, false, |key, v, pos| {
        match key {
          ReadStep::ReadStepCsv => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepCsv>>("ReadStep::ReadStepCsv", pos),
          ReadStep::ReadStepGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepGeoJson>>("ReadStep::ReadStepGeoJson", pos),
          ReadStep::ReadStepEsriShapefile => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepEsriShapefile>>("ReadStep::ReadStepEsriShapefile", pos),
          ReadStep::ReadStepParquet => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepParquet>>("ReadStep::ReadStepParquet", pos),
          ReadStep::ReadStepJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepJson>>("ReadStep::ReadStepJson", pos),
          ReadStep::ReadStepNdJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepNdJson>>("ReadStep::ReadStepNdJson", pos),
          ReadStep::ReadStepNdGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepNdGeoJson>>("ReadStep::ReadStepNdGeoJson", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Transform, _>("preprocess_type", Self::VT_PREPROCESS_TYPE, "preprocess", Self::VT_PREPROCESS, false, |key, v, pos| {
        match key {
          Transform::TransformSql => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>("Transform::TransformSql", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MergeStrategy, _>("merge_type", Self::VT_MERGE_TYPE, "merge", Self::VT_MERGE, false, |key, v, pos| {
        match key {
          MergeStrategy::MergeStrategyAppend => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyAppend>>("MergeStrategy::MergeStrategyAppend", pos),
          MergeStrategy::MergeStrategyLedger => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyLedger>>("MergeStrategy::MergeStrategyLedger", pos),
          MergeStrategy::MergeStrategySnapshot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategySnapshot>>("MergeStrategy::MergeStrategySnapshot", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct SetPollingSourceArgs<'a> {
    pub fetch_type: FetchStep,
    pub fetch: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub prepare: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>,
        >,
    >,
    pub read_type: ReadStep,
    pub read: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub preprocess_type: Transform,
    pub preprocess: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub merge_type: MergeStrategy,
    pub merge: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetPollingSourceArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetPollingSourceArgs {
            fetch_type: FetchStep::NONE,
            fetch: None,
            prepare: None,
            read_type: ReadStep::NONE,
            read: None,
            preprocess_type: Transform::NONE,
            preprocess: None,
            merge_type: MergeStrategy::NONE,
            merge: None,
        }
    }
}

pub struct SetPollingSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetPollingSourceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fetch_type(&mut self, fetch_type: FetchStep) {
        self.fbb_.push_slot::<FetchStep>(
            SetPollingSource::VT_FETCH_TYPE,
            fetch_type,
            FetchStep::NONE,
        );
    }
    #[inline]
    pub fn add_fetch(&mut self, fetch: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_FETCH, fetch);
    }
    #[inline]
    pub fn add_prepare(
        &mut self,
        prepare: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PrepStepWrapper<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_PREPARE, prepare);
    }
    #[inline]
    pub fn add_read_type(&mut self, read_type: ReadStep) {
        self.fbb_
            .push_slot::<ReadStep>(SetPollingSource::VT_READ_TYPE, read_type, ReadStep::NONE);
    }
    #[inline]
    pub fn add_read(&mut self, read: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_READ, read);
    }
    #[inline]
    pub fn add_preprocess_type(&mut self, preprocess_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            SetPollingSource::VT_PREPROCESS_TYPE,
            preprocess_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_preprocess(
        &mut self,
        preprocess: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetPollingSource::VT_PREPROCESS,
            preprocess,
        );
    }
    #[inline]
    pub fn add_merge_type(&mut self, merge_type: MergeStrategy) {
        self.fbb_.push_slot::<MergeStrategy>(
            SetPollingSource::VT_MERGE_TYPE,
            merge_type,
            MergeStrategy::NONE,
        );
    }
    #[inline]
    pub fn add_merge(&mut self, merge: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_MERGE, merge);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SetPollingSourceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetPollingSourceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetPollingSource<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetPollingSource<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetPollingSource");
        ds.field("fetch_type", &self.fetch_type());
        match self.fetch_type() {
            FetchStep::FetchStepUrl => {
                if let Some(x) = self.fetch_as_fetch_step_url() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepFilesGlob => {
                if let Some(x) = self.fetch_as_fetch_step_files_glob() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepContainer => {
                if let Some(x) = self.fetch_as_fetch_step_container() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepMqtt => {
                if let Some(x) = self.fetch_as_fetch_step_mqtt() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepEthereumLogs => {
                if let Some(x) = self.fetch_as_fetch_step_ethereum_logs() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("fetch", &x)
            }
        };
        ds.field("prepare", &self.prepare());
        ds.field("read_type", &self.read_type());
        match self.read_type() {
            ReadStep::ReadStepCsv => {
                if let Some(x) = self.read_as_read_step_csv() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepGeoJson => {
                if let Some(x) = self.read_as_read_step_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepEsriShapefile => {
                if let Some(x) = self.read_as_read_step_esri_shapefile() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepParquet => {
                if let Some(x) = self.read_as_read_step_parquet() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepJson => {
                if let Some(x) = self.read_as_read_step_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepNdJson => {
                if let Some(x) = self.read_as_read_step_nd_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepNdGeoJson => {
                if let Some(x) = self.read_as_read_step_nd_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("read", &x)
            }
        };
        ds.field("preprocess_type", &self.preprocess_type());
        match self.preprocess_type() {
            Transform::TransformSql => {
                if let Some(x) = self.preprocess_as_transform_sql() {
                    ds.field("preprocess", &x)
                } else {
                    ds.field(
                        "preprocess",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("preprocess", &x)
            }
        };
        ds.field("merge_type", &self.merge_type());
        match self.merge_type() {
            MergeStrategy::MergeStrategyAppend => {
                if let Some(x) = self.merge_as_merge_strategy_append() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategyLedger => {
                if let Some(x) = self.merge_as_merge_strategy_ledger() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategySnapshot => {
                if let Some(x) = self.merge_as_merge_strategy_snapshot() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("merge", &x)
            }
        };
        ds.finish()
    }
}
pub enum TransformInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformInput<'a> {
    type Inner = TransformInput<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformInput<'a> {
    pub const VT_DATASET_REF: flatbuffers::VOffsetT = 4;
    pub const VT_ALIAS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformInput<'bldr>> {
        let mut builder = TransformInputBuilder::new(_fbb);
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        if let Some(x) = args.dataset_ref {
            builder.add_dataset_ref(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_ref(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformInput::VT_DATASET_REF, None)
        }
    }
    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformInput::VT_ALIAS, None)
        }
    }
}

impl flatbuffers::Verifiable for TransformInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_ref",
                Self::VT_DATASET_REF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformInputArgs<'a> {
    pub dataset_ref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransformInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformInputArgs {
            dataset_ref: None,
            alias: None,
        }
    }
}

pub struct TransformInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformInputBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dataset_ref(&mut self, dataset_ref: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformInput::VT_DATASET_REF,
            dataset_ref,
        );
    }
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformInput::VT_ALIAS, alias);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformInputBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformInput<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformInput");
        ds.field("dataset_ref", &self.dataset_ref());
        ds.field("alias", &self.alias());
        ds.finish()
    }
}
pub enum SetTransformOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetTransform<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetTransform<'a> {
    type Inner = SetTransform<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetTransform<'a> {
    pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetTransform { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetTransformArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetTransform<'bldr>> {
        let mut builder = SetTransformBuilder::new(_fbb);
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput>>,
            >>(SetTransform::VT_INPUTS, None)
        }
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(SetTransform::VT_TRANSFORM_TYPE, Some(Transform::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetTransform::VT_TRANSFORM,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformSql::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetTransform<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransformInput>>,
            >>("inputs", Self::VT_INPUTS, false)?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct SetTransformArgs<'a> {
    pub inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput<'a>>>,
        >,
    >,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetTransformArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetTransformArgs {
            inputs: None,
            transform_type: Transform::NONE,
            transform: None,
        }
    }
}

pub struct SetTransformBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetTransformBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransformInput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetTransform::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            SetTransform::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetTransform::VT_TRANSFORM, transform);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SetTransformBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetTransformBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetTransform<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetTransform<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetTransform");
        ds.field("inputs", &self.inputs());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetVocabOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetVocab<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetVocab<'a> {
    type Inner = SetVocab<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetVocab<'a> {
    pub const VT_OFFSET_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION_TYPE_COLUMN: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 8;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetVocab { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetVocabArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetVocab<'bldr>> {
        let mut builder = SetVocabBuilder::new(_fbb);
        if let Some(x) = args.event_time_column {
            builder.add_event_time_column(x);
        }
        if let Some(x) = args.system_time_column {
            builder.add_system_time_column(x);
        }
        if let Some(x) = args.operation_type_column {
            builder.add_operation_type_column(x);
        }
        if let Some(x) = args.offset_column {
            builder.add_offset_column(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn offset_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_OFFSET_COLUMN, None)
        }
    }
    #[inline]
    pub fn operation_type_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_OPERATION_TYPE_COLUMN, None)
        }
    }
    #[inline]
    pub fn system_time_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_SYSTEM_TIME_COLUMN, None)
        }
    }
    #[inline]
    pub fn event_time_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_EVENT_TIME_COLUMN, None)
        }
    }
}

impl flatbuffers::Verifiable for SetVocab<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "offset_column",
                Self::VT_OFFSET_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "operation_type_column",
                Self::VT_OPERATION_TYPE_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "system_time_column",
                Self::VT_SYSTEM_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "event_time_column",
                Self::VT_EVENT_TIME_COLUMN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SetVocabArgs<'a> {
    pub offset_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation_type_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetVocabArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetVocabArgs {
            offset_column: None,
            operation_type_column: None,
            system_time_column: None,
            event_time_column: None,
        }
    }
}

pub struct SetVocabBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetVocabBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_offset_column(&mut self, offset_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_OFFSET_COLUMN,
            offset_column,
        );
    }
    #[inline]
    pub fn add_operation_type_column(
        &mut self,
        operation_type_column: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_OPERATION_TYPE_COLUMN,
            operation_type_column,
        );
    }
    #[inline]
    pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_SYSTEM_TIME_COLUMN,
            system_time_column,
        );
    }
    #[inline]
    pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_EVENT_TIME_COLUMN,
            event_time_column,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetVocabBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetVocabBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetVocab<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetVocab<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetVocab");
        ds.field("offset_column", &self.offset_column());
        ds.field("operation_type_column", &self.operation_type_column());
        ds.field("system_time_column", &self.system_time_column());
        ds.field("event_time_column", &self.event_time_column());
        ds.finish()
    }
}
pub enum SetAttachmentsOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetAttachments<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetAttachments<'a> {
    type Inner = SetAttachments<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetAttachments<'a> {
    pub const VT_ATTACHMENTS_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ATTACHMENTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetAttachments { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetAttachmentsArgs,
    ) -> flatbuffers::WIPOffset<SetAttachments<'bldr>> {
        let mut builder = SetAttachmentsBuilder::new(_fbb);
        if let Some(x) = args.attachments {
            builder.add_attachments(x);
        }
        builder.add_attachments_type(args.attachments_type);
        builder.finish()
    }

    #[inline]
    pub fn attachments_type(&self) -> Attachments {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Attachments>(SetAttachments::VT_ATTACHMENTS_TYPE, Some(Attachments::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn attachments(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SetAttachments::VT_ATTACHMENTS,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attachments_as_attachments_embedded(&self) -> Option<AttachmentsEmbedded<'a>> {
        if self.attachments_type() == Attachments::AttachmentsEmbedded {
            self.attachments().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AttachmentsEmbedded::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetAttachments<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Attachments, _>(
                "attachments_type",
                Self::VT_ATTACHMENTS_TYPE,
                "attachments",
                Self::VT_ATTACHMENTS,
                false,
                |key, v, pos| match key {
                    Attachments::AttachmentsEmbedded => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AttachmentsEmbedded>>(
                            "Attachments::AttachmentsEmbedded",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct SetAttachmentsArgs {
    pub attachments_type: Attachments,
    pub attachments: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetAttachmentsArgs {
    #[inline]
    fn default() -> Self {
        SetAttachmentsArgs {
            attachments_type: Attachments::NONE,
            attachments: None,
        }
    }
}

pub struct SetAttachmentsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetAttachmentsBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_attachments_type(&mut self, attachments_type: Attachments) {
        self.fbb_.push_slot::<Attachments>(
            SetAttachments::VT_ATTACHMENTS_TYPE,
            attachments_type,
            Attachments::NONE,
        );
    }
    #[inline]
    pub fn add_attachments(
        &mut self,
        attachments: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetAttachments::VT_ATTACHMENTS,
            attachments,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SetAttachmentsBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetAttachmentsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetAttachments<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetAttachments<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetAttachments");
        ds.field("attachments_type", &self.attachments_type());
        match self.attachments_type() {
            Attachments::AttachmentsEmbedded => {
                if let Some(x) = self.attachments_as_attachments_embedded() {
                    ds.field("attachments", &x)
                } else {
                    ds.field(
                        "attachments",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attachments", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetInfo<'a> {
    type Inner = SetInfo<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetInfo<'a> {
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 4;
    pub const VT_KEYWORDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetInfo<'bldr>> {
        let mut builder = SetInfoBuilder::new(_fbb);
        if let Some(x) = args.keywords {
            builder.add_keywords(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetInfo::VT_DESCRIPTION, None)
        }
    }
    #[inline]
    pub fn keywords(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(SetInfo::VT_KEYWORDS, None)
        }
    }
}

impl flatbuffers::Verifiable for SetInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("keywords", Self::VT_KEYWORDS, false)?
            .finish();
        Ok(())
    }
}
pub struct SetInfoArgs<'a> {
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keywords: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for SetInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetInfoArgs {
            description: None,
            keywords: None,
        }
    }
}

pub struct SetInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetInfoBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetInfo::VT_DESCRIPTION, description);
    }
    #[inline]
    pub fn add_keywords(
        &mut self,
        keywords: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetInfo::VT_KEYWORDS, keywords);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SetInfoBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetInfo");
        ds.field("description", &self.description());
        ds.field("keywords", &self.keywords());
        ds.finish()
    }
}
pub enum SetLicenseOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetLicense<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetLicense<'a> {
    type Inner = SetLicense<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetLicense<'a> {
    pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SPDX_ID: flatbuffers::VOffsetT = 8;
    pub const VT_WEBSITE_URL: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetLicense { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetLicenseArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetLicense<'bldr>> {
        let mut builder = SetLicenseBuilder::new(_fbb);
        if let Some(x) = args.website_url {
            builder.add_website_url(x);
        }
        if let Some(x) = args.spdx_id {
            builder.add_spdx_id(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.short_name {
            builder.add_short_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn short_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_SHORT_NAME, None)
        }
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_NAME, None)
        }
    }
    #[inline]
    pub fn spdx_id(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_SPDX_ID, None)
        }
    }
    #[inline]
    pub fn website_url(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_WEBSITE_URL, None)
        }
    }
}

impl flatbuffers::Verifiable for SetLicense<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "short_name",
                Self::VT_SHORT_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spdx_id", Self::VT_SPDX_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "website_url",
                Self::VT_WEBSITE_URL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SetLicenseArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spdx_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub website_url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetLicenseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetLicenseArgs {
            short_name: None,
            name: None,
            spdx_id: None,
            website_url: None,
        }
    }
}

pub struct SetLicenseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetLicenseBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_SHORT_NAME, short_name);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_NAME, name);
    }
    #[inline]
    pub fn add_spdx_id(&mut self, spdx_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_SPDX_ID, spdx_id);
    }
    #[inline]
    pub fn add_website_url(&mut self, website_url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_WEBSITE_URL, website_url);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SetLicenseBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetLicenseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetLicense<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetLicense<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetLicense");
        ds.field("short_name", &self.short_name());
        ds.field("name", &self.name());
        ds.field("spdx_id", &self.spdx_id());
        ds.field("website_url", &self.website_url());
        ds.finish()
    }
}
pub enum SetDataSchemaOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct SetDataSchema<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetDataSchema<'a> {
    type Inner = SetDataSchema<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SetDataSchema<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetDataSchema { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SetDataSchemaArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetDataSchema<'bldr>> {
        let mut builder = SetDataSchemaBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    SetDataSchema::VT_SCHEMA,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for SetDataSchema<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "schema",
                Self::VT_SCHEMA,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SetDataSchemaArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for SetDataSchemaArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetDataSchemaArgs { schema: None }
    }
}

pub struct SetDataSchemaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SetDataSchemaBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetDataSchema::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SetDataSchemaBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SetDataSchemaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetDataSchema<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetDataSchema<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetDataSchema");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum DisablePushSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct DisablePushSource<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DisablePushSource<'a> {
    type Inner = DisablePushSource<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DisablePushSource<'a> {
    pub const VT_SOURCE_NAME: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DisablePushSource { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DisablePushSourceArgs<'args>,
    ) -> flatbuffers::WIPOffset<DisablePushSource<'bldr>> {
        let mut builder = DisablePushSourceBuilder::new(_fbb);
        if let Some(x) = args.source_name {
            builder.add_source_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn source_name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DisablePushSource::VT_SOURCE_NAME, None)
        }
    }
}

impl flatbuffers::Verifiable for DisablePushSource<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "source_name",
                Self::VT_SOURCE_NAME,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DisablePushSourceArgs<'a> {
    pub source_name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DisablePushSourceArgs<'a> {
    #[inline]
    fn default() -> Self {
        DisablePushSourceArgs { source_name: None }
    }
}

pub struct DisablePushSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DisablePushSourceBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_source_name(&mut self, source_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DisablePushSource::VT_SOURCE_NAME,
            source_name,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DisablePushSourceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DisablePushSourceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DisablePushSource<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DisablePushSource<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DisablePushSource");
        ds.field("source_name", &self.source_name());
        ds.finish()
    }
}
pub enum DisablePollingSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct DisablePollingSource<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DisablePollingSource<'a> {
    type Inner = DisablePollingSource<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DisablePollingSource<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DisablePollingSource { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args DisablePollingSourceArgs,
    ) -> flatbuffers::WIPOffset<DisablePollingSource<'bldr>> {
        let mut builder = DisablePollingSourceBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for DisablePollingSource<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct DisablePollingSourceArgs {}
impl<'a> Default for DisablePollingSourceArgs {
    #[inline]
    fn default() -> Self {
        DisablePollingSourceArgs {}
    }
}

pub struct DisablePollingSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DisablePollingSourceBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DisablePollingSourceBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DisablePollingSourceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DisablePollingSource<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DisablePollingSource<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DisablePollingSource");
        ds.finish()
    }
}
pub enum MetadataEventWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MetadataEventWrapper<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataEventWrapper<'a> {
    type Inner = MetadataEventWrapper<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MetadataEventWrapper<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataEventWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MetadataEventWrapperArgs,
    ) -> flatbuffers::WIPOffset<MetadataEventWrapper<'bldr>> {
        let mut builder = MetadataEventWrapperBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> MetadataEvent {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MetadataEvent>(
                    MetadataEventWrapper::VT_VALUE_TYPE,
                    Some(MetadataEvent::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MetadataEventWrapper::VT_VALUE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_add_data(&self) -> Option<AddData<'a>> {
        if self.value_type() == MetadataEvent::AddData {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AddData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_transform(&self) -> Option<ExecuteTransform<'a>> {
        if self.value_type() == MetadataEvent::ExecuteTransform {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ExecuteTransform::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_seed(&self) -> Option<Seed<'a>> {
        if self.value_type() == MetadataEvent::Seed {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Seed::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_polling_source(&self) -> Option<SetPollingSource<'a>> {
        if self.value_type() == MetadataEvent::SetPollingSource {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetPollingSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_transform(&self) -> Option<SetTransform<'a>> {
        if self.value_type() == MetadataEvent::SetTransform {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetTransform::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_vocab(&self) -> Option<SetVocab<'a>> {
        if self.value_type() == MetadataEvent::SetVocab {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetVocab::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_attachments(&self) -> Option<SetAttachments<'a>> {
        if self.value_type() == MetadataEvent::SetAttachments {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetAttachments::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_info(&self) -> Option<SetInfo<'a>> {
        if self.value_type() == MetadataEvent::SetInfo {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetInfo::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_license(&self) -> Option<SetLicense<'a>> {
        if self.value_type() == MetadataEvent::SetLicense {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetLicense::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_set_data_schema(&self) -> Option<SetDataSchema<'a>> {
        if self.value_type() == MetadataEvent::SetDataSchema {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetDataSchema::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_add_push_source(&self) -> Option<AddPushSource<'a>> {
        if self.value_type() == MetadataEvent::AddPushSource {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AddPushSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_disable_push_source(&self) -> Option<DisablePushSource<'a>> {
        if self.value_type() == MetadataEvent::DisablePushSource {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DisablePushSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_disable_polling_source(&self) -> Option<DisablePollingSource<'a>> {
        if self.value_type() == MetadataEvent::DisablePollingSource {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DisablePollingSource::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for MetadataEventWrapper<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<MetadataEvent, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    MetadataEvent::AddData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AddData>>(
                            "MetadataEvent::AddData",
                            pos,
                        ),
                    MetadataEvent::ExecuteTransform => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteTransform>>(
                            "MetadataEvent::ExecuteTransform",
                            pos,
                        ),
                    MetadataEvent::Seed => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Seed>>(
                            "MetadataEvent::Seed",
                            pos,
                        ),
                    MetadataEvent::SetPollingSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetPollingSource>>(
                            "MetadataEvent::SetPollingSource",
                            pos,
                        ),
                    MetadataEvent::SetTransform => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetTransform>>(
                            "MetadataEvent::SetTransform",
                            pos,
                        ),
                    MetadataEvent::SetVocab => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetVocab>>(
                            "MetadataEvent::SetVocab",
                            pos,
                        ),
                    MetadataEvent::SetAttachments => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetAttachments>>(
                            "MetadataEvent::SetAttachments",
                            pos,
                        ),
                    MetadataEvent::SetInfo => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetInfo>>(
                            "MetadataEvent::SetInfo",
                            pos,
                        ),
                    MetadataEvent::SetLicense => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetLicense>>(
                            "MetadataEvent::SetLicense",
                            pos,
                        ),
                    MetadataEvent::SetDataSchema => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetDataSchema>>(
                            "MetadataEvent::SetDataSchema",
                            pos,
                        ),
                    MetadataEvent::AddPushSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AddPushSource>>(
                            "MetadataEvent::AddPushSource",
                            pos,
                        ),
                    MetadataEvent::DisablePushSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<DisablePushSource>>(
                            "MetadataEvent::DisablePushSource",
                            pos,
                        ),
                    MetadataEvent::DisablePollingSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<DisablePollingSource>>(
                            "MetadataEvent::DisablePollingSource",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct MetadataEventWrapperArgs {
    pub value_type: MetadataEvent,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MetadataEventWrapperArgs {
    #[inline]
    fn default() -> Self {
        MetadataEventWrapperArgs {
            value_type: MetadataEvent::NONE,
            value: None,
        }
    }
}

pub struct MetadataEventWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataEventWrapperBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: MetadataEvent) {
        self.fbb_.push_slot::<MetadataEvent>(
            MetadataEventWrapper::VT_VALUE_TYPE,
            value_type,
            MetadataEvent::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataEventWrapper::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MetadataEventWrapperBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MetadataEventWrapperBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MetadataEventWrapper<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MetadataEventWrapper<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MetadataEventWrapper");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            MetadataEvent::AddData => {
                if let Some(x) = self.value_as_add_data() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::ExecuteTransform => {
                if let Some(x) = self.value_as_execute_transform() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::Seed => {
                if let Some(x) = self.value_as_seed() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetPollingSource => {
                if let Some(x) = self.value_as_set_polling_source() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetTransform => {
                if let Some(x) = self.value_as_set_transform() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetVocab => {
                if let Some(x) = self.value_as_set_vocab() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetAttachments => {
                if let Some(x) = self.value_as_set_attachments() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetInfo => {
                if let Some(x) = self.value_as_set_info() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetLicense => {
                if let Some(x) = self.value_as_set_license() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetDataSchema => {
                if let Some(x) = self.value_as_set_data_schema() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::AddPushSource => {
                if let Some(x) = self.value_as_add_push_source() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::DisablePushSource => {
                if let Some(x) = self.value_as_disable_push_source() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::DisablePollingSource => {
                if let Some(x) = self.value_as_disable_polling_source() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum DatasetSnapshotOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct DatasetSnapshot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSnapshot<'a> {
    type Inner = DatasetSnapshot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DatasetSnapshot<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_KIND: flatbuffers::VOffsetT = 6;
    pub const VT_METADATA: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSnapshot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DatasetSnapshotArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetSnapshot<'bldr>> {
        let mut builder = DatasetSnapshotBuilder::new(_fbb);
        if let Some(x) = args.metadata {
            builder.add_metadata(x);
        }
        builder.add_kind(args.kind);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DatasetSnapshot::VT_NAME, None)
        }
    }
    #[inline]
    pub fn kind(&self) -> DatasetKind {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DatasetKind>(DatasetSnapshot::VT_KIND, Some(DatasetKind::Root))
                .unwrap()
        }
    }
    #[inline]
    pub fn metadata(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataEventWrapper<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataEventWrapper>>,
            >>(DatasetSnapshot::VT_METADATA, None)
        }
    }
}

impl flatbuffers::Verifiable for DatasetSnapshot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<DatasetKind>("kind", Self::VT_KIND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MetadataEventWrapper>>,
            >>("metadata", Self::VT_METADATA, false)?
            .finish();
        Ok(())
    }
}
pub struct DatasetSnapshotArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: DatasetKind,
    pub metadata: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MetadataEventWrapper<'a>>>,
        >,
    >,
}
impl<'a> Default for DatasetSnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSnapshotArgs {
            name: None,
            kind: DatasetKind::Root,
            metadata: None,
        }
    }
}

pub struct DatasetSnapshotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DatasetSnapshotBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_NAME, name);
    }
    #[inline]
    pub fn add_kind(&mut self, kind: DatasetKind) {
        self.fbb_
            .push_slot::<DatasetKind>(DatasetSnapshot::VT_KIND, kind, DatasetKind::Root);
    }
    #[inline]
    pub fn add_metadata(
        &mut self,
        metadata: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<MetadataEventWrapper<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_METADATA, metadata);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DatasetSnapshotBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DatasetSnapshotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSnapshot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DatasetSnapshot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DatasetSnapshot");
        ds.field("name", &self.name());
        ds.field("kind", &self.kind());
        ds.field("metadata", &self.metadata());
        ds.finish()
    }
}
pub enum DatasetVocabularyOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct DatasetVocabulary<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetVocabulary<'a> {
    type Inner = DatasetVocabulary<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DatasetVocabulary<'a> {
    pub const VT_OFFSET_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION_TYPE_COLUMN: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 8;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetVocabulary { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DatasetVocabularyArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetVocabulary<'bldr>> {
        let mut builder = DatasetVocabularyBuilder::new(_fbb);
        if let Some(x) = args.event_time_column {
            builder.add_event_time_column(x);
        }
        if let Some(x) = args.system_time_column {
            builder.add_system_time_column(x);
        }
        if let Some(x) = args.operation_type_column {
            builder.add_operation_type_column(x);
        }
        if let Some(x) = args.offset_column {
            builder.add_offset_column(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn offset_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                DatasetVocabulary::VT_OFFSET_COLUMN,
                None,
            )
        }
    }
    #[inline]
    pub fn operation_type_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                DatasetVocabulary::VT_OPERATION_TYPE_COLUMN,
                None,
            )
        }
    }
    #[inline]
    pub fn system_time_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
                None,
            )
        }
    }
    #[inline]
    pub fn event_time_column(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                DatasetVocabulary::VT_EVENT_TIME_COLUMN,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for DatasetVocabulary<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "offset_column",
                Self::VT_OFFSET_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "operation_type_column",
                Self::VT_OPERATION_TYPE_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "system_time_column",
                Self::VT_SYSTEM_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "event_time_column",
                Self::VT_EVENT_TIME_COLUMN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DatasetVocabularyArgs<'a> {
    pub offset_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation_type_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DatasetVocabularyArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetVocabularyArgs {
            offset_column: None,
            operation_type_column: None,
            system_time_column: None,
            event_time_column: None,
        }
    }
}

pub struct DatasetVocabularyBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DatasetVocabularyBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_offset_column(&mut self, offset_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_OFFSET_COLUMN,
            offset_column,
        );
    }
    #[inline]
    pub fn add_operation_type_column(
        &mut self,
        operation_type_column: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_OPERATION_TYPE_COLUMN,
            operation_type_column,
        );
    }
    #[inline]
    pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
            system_time_column,
        );
    }
    #[inline]
    pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_EVENT_TIME_COLUMN,
            event_time_column,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> DatasetVocabularyBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DatasetVocabularyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetVocabulary<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DatasetVocabulary<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DatasetVocabulary");
        ds.field("offset_column", &self.offset_column());
        ds.field("operation_type_column", &self.operation_type_column());
        ds.field("system_time_column", &self.system_time_column());
        ds.field("event_time_column", &self.event_time_column());
        ds.finish()
    }
}
pub enum ManifestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct Manifest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
    type Inner = Manifest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Manifest<'a> {
    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Manifest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ManifestArgs<'args>,
    ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
        let mut builder = ManifestBuilder::new(_fbb);
        builder.add_kind(args.kind);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    #[inline]
    pub fn kind(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i64>(Manifest::VT_KIND, Some(0)).unwrap() }
    }
    #[inline]
    pub fn version(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(Manifest::VT_VERSION, Some(0)).unwrap() }
    }
    #[inline]
    pub fn content(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Manifest::VT_CONTENT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for Manifest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("kind", Self::VT_KIND, false)?
            .visit_field::<i32>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "content",
                Self::VT_CONTENT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ManifestArgs<'a> {
    pub kind: i64,
    pub version: i32,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ManifestArgs<'a> {
    #[inline]
    fn default() -> Self {
        ManifestArgs {
            kind: 0,
            version: 0,
            content: None,
        }
    }
}

pub struct ManifestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ManifestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_kind(&mut self, kind: i64) {
        self.fbb_.push_slot::<i64>(Manifest::VT_KIND, kind, 0);
    }
    #[inline]
    pub fn add_version(&mut self, version: i32) {
        self.fbb_.push_slot::<i32>(Manifest::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_CONTENT, content);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ManifestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ManifestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Manifest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Manifest");
        ds.field("kind", &self.kind());
        ds.field("version", &self.version());
        ds.field("content", &self.content());
        ds.finish()
    }
}
pub enum MetadataBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct MetadataBlock<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataBlock<'a> {
    type Inner = MetadataBlock<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> MetadataBlock<'a> {
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 8;
    pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_EVENT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataBlock { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args MetadataBlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<MetadataBlock<'bldr>> {
        let mut builder = MetadataBlockBuilder::new(_fbb);
        builder.add_sequence_number(args.sequence_number);
        if let Some(x) = args.event {
            builder.add_event(x);
        }
        if let Some(x) = args.prev_block_hash {
            builder.add_prev_block_hash(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        builder.add_event_type(args.event_type);
        builder.finish()
    }

    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Timestamp>(MetadataBlock::VT_SYSTEM_TIME, None)
        }
    }
    #[inline]
    pub fn prev_block_hash(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    MetadataBlock::VT_PREV_BLOCK_HASH,
                    None,
                )
        }
    }
    #[inline]
    pub fn sequence_number(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(MetadataBlock::VT_SEQUENCE_NUMBER, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn event_type(&self) -> MetadataEvent {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<MetadataEvent>(MetadataBlock::VT_EVENT_TYPE, Some(MetadataEvent::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    MetadataBlock::VT_EVENT,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_add_data(&self) -> Option<AddData<'a>> {
        if self.event_type() == MetadataEvent::AddData {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AddData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_execute_transform(&self) -> Option<ExecuteTransform<'a>> {
        if self.event_type() == MetadataEvent::ExecuteTransform {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ExecuteTransform::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_seed(&self) -> Option<Seed<'a>> {
        if self.event_type() == MetadataEvent::Seed {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Seed::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_polling_source(&self) -> Option<SetPollingSource<'a>> {
        if self.event_type() == MetadataEvent::SetPollingSource {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetPollingSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_transform(&self) -> Option<SetTransform<'a>> {
        if self.event_type() == MetadataEvent::SetTransform {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetTransform::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_vocab(&self) -> Option<SetVocab<'a>> {
        if self.event_type() == MetadataEvent::SetVocab {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetVocab::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_attachments(&self) -> Option<SetAttachments<'a>> {
        if self.event_type() == MetadataEvent::SetAttachments {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetAttachments::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_info(&self) -> Option<SetInfo<'a>> {
        if self.event_type() == MetadataEvent::SetInfo {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetInfo::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_license(&self) -> Option<SetLicense<'a>> {
        if self.event_type() == MetadataEvent::SetLicense {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetLicense::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_data_schema(&self) -> Option<SetDataSchema<'a>> {
        if self.event_type() == MetadataEvent::SetDataSchema {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { SetDataSchema::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_add_push_source(&self) -> Option<AddPushSource<'a>> {
        if self.event_type() == MetadataEvent::AddPushSource {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { AddPushSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_disable_push_source(&self) -> Option<DisablePushSource<'a>> {
        if self.event_type() == MetadataEvent::DisablePushSource {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DisablePushSource::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_disable_polling_source(&self) -> Option<DisablePollingSource<'a>> {
        if self.event_type() == MetadataEvent::DisablePollingSource {
            self.event().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DisablePollingSource::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for MetadataBlock<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "prev_block_hash",
                Self::VT_PREV_BLOCK_HASH,
                false,
            )?
            .visit_field::<u64>("sequence_number", Self::VT_SEQUENCE_NUMBER, false)?
            .visit_union::<MetadataEvent, _>(
                "event_type",
                Self::VT_EVENT_TYPE,
                "event",
                Self::VT_EVENT,
                false,
                |key, v, pos| match key {
                    MetadataEvent::AddData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AddData>>(
                            "MetadataEvent::AddData",
                            pos,
                        ),
                    MetadataEvent::ExecuteTransform => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteTransform>>(
                            "MetadataEvent::ExecuteTransform",
                            pos,
                        ),
                    MetadataEvent::Seed => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Seed>>(
                            "MetadataEvent::Seed",
                            pos,
                        ),
                    MetadataEvent::SetPollingSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetPollingSource>>(
                            "MetadataEvent::SetPollingSource",
                            pos,
                        ),
                    MetadataEvent::SetTransform => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetTransform>>(
                            "MetadataEvent::SetTransform",
                            pos,
                        ),
                    MetadataEvent::SetVocab => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetVocab>>(
                            "MetadataEvent::SetVocab",
                            pos,
                        ),
                    MetadataEvent::SetAttachments => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetAttachments>>(
                            "MetadataEvent::SetAttachments",
                            pos,
                        ),
                    MetadataEvent::SetInfo => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetInfo>>(
                            "MetadataEvent::SetInfo",
                            pos,
                        ),
                    MetadataEvent::SetLicense => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetLicense>>(
                            "MetadataEvent::SetLicense",
                            pos,
                        ),
                    MetadataEvent::SetDataSchema => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetDataSchema>>(
                            "MetadataEvent::SetDataSchema",
                            pos,
                        ),
                    MetadataEvent::AddPushSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AddPushSource>>(
                            "MetadataEvent::AddPushSource",
                            pos,
                        ),
                    MetadataEvent::DisablePushSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<DisablePushSource>>(
                            "MetadataEvent::DisablePushSource",
                            pos,
                        ),
                    MetadataEvent::DisablePollingSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<DisablePollingSource>>(
                            "MetadataEvent::DisablePollingSource",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct MetadataBlockArgs<'a> {
    pub system_time: Option<&'a Timestamp>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub sequence_number: u64,
    pub event_type: MetadataEvent,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MetadataBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataBlockArgs {
            system_time: None,
            prev_block_hash: None,
            sequence_number: 0,
            event_type: MetadataEvent::NONE,
            event: None,
        }
    }
}

pub struct MetadataBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataBlockBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(MetadataBlock::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_prev_block_hash(
        &mut self,
        prev_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MetadataBlock::VT_PREV_BLOCK_HASH,
            prev_block_hash,
        );
    }
    #[inline]
    pub fn add_sequence_number(&mut self, sequence_number: u64) {
        self.fbb_
            .push_slot::<u64>(MetadataBlock::VT_SEQUENCE_NUMBER, sequence_number, 0);
    }
    #[inline]
    pub fn add_event_type(&mut self, event_type: MetadataEvent) {
        self.fbb_.push_slot::<MetadataEvent>(
            MetadataBlock::VT_EVENT_TYPE,
            event_type,
            MetadataEvent::NONE,
        );
    }
    #[inline]
    pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_EVENT, event);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> MetadataBlockBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        MetadataBlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MetadataBlock<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MetadataBlock<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MetadataBlock");
        ds.field("system_time", &self.system_time());
        ds.field("prev_block_hash", &self.prev_block_hash());
        ds.field("sequence_number", &self.sequence_number());
        ds.field("event_type", &self.event_type());
        match self.event_type() {
            MetadataEvent::AddData => {
                if let Some(x) = self.event_as_add_data() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::ExecuteTransform => {
                if let Some(x) = self.event_as_execute_transform() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::Seed => {
                if let Some(x) = self.event_as_seed() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetPollingSource => {
                if let Some(x) = self.event_as_set_polling_source() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetTransform => {
                if let Some(x) = self.event_as_set_transform() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetVocab => {
                if let Some(x) = self.event_as_set_vocab() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetAttachments => {
                if let Some(x) = self.event_as_set_attachments() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetInfo => {
                if let Some(x) = self.event_as_set_info() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetLicense => {
                if let Some(x) = self.event_as_set_license() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetDataSchema => {
                if let Some(x) = self.event_as_set_data_schema() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::AddPushSource => {
                if let Some(x) = self.event_as_add_push_source() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::DisablePushSource => {
                if let Some(x) = self.event_as_disable_push_source() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::DisablePollingSource => {
                if let Some(x) = self.event_as_disable_polling_source() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event", &x)
            }
        };
        ds.finish()
    }
}
pub enum RawQueryRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryRequest<'a> {
    type Inner = RawQueryRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryRequest<'a> {
    pub const VT_INPUT_DATA_PATHS: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUT_DATA_PATH: flatbuffers::VOffsetT = 10;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RawQueryRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<RawQueryRequest<'bldr>> {
        let mut builder = RawQueryRequestBuilder::new(_fbb);
        if let Some(x) = args.output_data_path {
            builder.add_output_data_path(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.input_data_paths {
            builder.add_input_data_paths(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn input_data_paths(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(RawQueryRequest::VT_INPUT_DATA_PATHS, None)
        }
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(RawQueryRequest::VT_TRANSFORM_TYPE, Some(Transform::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    RawQueryRequest::VT_TRANSFORM,
                    None,
                )
        }
    }
    #[inline]
    pub fn output_data_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                RawQueryRequest::VT_OUTPUT_DATA_PATH,
                None,
            )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformSql::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for RawQueryRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("input_data_paths", Self::VT_INPUT_DATA_PATHS, false)?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "output_data_path",
                Self::VT_OUTPUT_DATA_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct RawQueryRequestArgs<'a> {
    pub input_data_paths: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub output_data_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RawQueryRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        RawQueryRequestArgs {
            input_data_paths: None,
            transform_type: Transform::NONE,
            transform: None,
            output_data_path: None,
        }
    }
}

pub struct RawQueryRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_input_data_paths(
        &mut self,
        input_data_paths: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryRequest::VT_INPUT_DATA_PATHS,
            input_data_paths,
        );
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            RawQueryRequest::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryRequest::VT_TRANSFORM,
            transform,
        );
    }
    #[inline]
    pub fn add_output_data_path(&mut self, output_data_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryRequest::VT_OUTPUT_DATA_PATH,
            output_data_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryRequest");
        ds.field("input_data_paths", &self.input_data_paths());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.field("output_data_path", &self.output_data_path());
        ds.finish()
    }
}
pub enum RawQueryResponseProgressOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryResponseProgress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryResponseProgress<'a> {
    type Inner = RawQueryResponseProgress<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryResponseProgress<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryResponseProgress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args RawQueryResponseProgressArgs,
    ) -> flatbuffers::WIPOffset<RawQueryResponseProgress<'bldr>> {
        let mut builder = RawQueryResponseProgressBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for RawQueryResponseProgress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct RawQueryResponseProgressArgs {}
impl<'a> Default for RawQueryResponseProgressArgs {
    #[inline]
    fn default() -> Self {
        RawQueryResponseProgressArgs {}
    }
}

pub struct RawQueryResponseProgressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryResponseProgressBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryResponseProgressBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryResponseProgressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryResponseProgress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryResponseProgress<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryResponseProgress");
        ds.finish()
    }
}
pub enum RawQueryResponseSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryResponseSuccess<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryResponseSuccess<'a> {
    type Inner = RawQueryResponseSuccess<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryResponseSuccess<'a> {
    pub const VT_NUM_RECORDS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryResponseSuccess { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RawQueryResponseSuccessArgs,
    ) -> flatbuffers::WIPOffset<RawQueryResponseSuccess<'bldr>> {
        let mut builder = RawQueryResponseSuccessBuilder::new(_fbb);
        builder.add_num_records(args.num_records);
        builder.finish()
    }

    #[inline]
    pub fn num_records(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(RawQueryResponseSuccess::VT_NUM_RECORDS, Some(0))
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for RawQueryResponseSuccess<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("num_records", Self::VT_NUM_RECORDS, false)?
            .finish();
        Ok(())
    }
}
pub struct RawQueryResponseSuccessArgs {
    pub num_records: u64,
}
impl<'a> Default for RawQueryResponseSuccessArgs {
    #[inline]
    fn default() -> Self {
        RawQueryResponseSuccessArgs { num_records: 0 }
    }
}

pub struct RawQueryResponseSuccessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryResponseSuccessBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_num_records(&mut self, num_records: u64) {
        self.fbb_
            .push_slot::<u64>(RawQueryResponseSuccess::VT_NUM_RECORDS, num_records, 0);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryResponseSuccessBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryResponseSuccessBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryResponseSuccess<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryResponseSuccess<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryResponseSuccess");
        ds.field("num_records", &self.num_records());
        ds.finish()
    }
}
pub enum RawQueryResponseInvalidQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryResponseInvalidQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryResponseInvalidQuery<'a> {
    type Inner = RawQueryResponseInvalidQuery<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryResponseInvalidQuery<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryResponseInvalidQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RawQueryResponseInvalidQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<RawQueryResponseInvalidQuery<'bldr>> {
        let mut builder = RawQueryResponseInvalidQueryBuilder::new(_fbb);
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                RawQueryResponseInvalidQuery::VT_MESSAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for RawQueryResponseInvalidQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct RawQueryResponseInvalidQueryArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RawQueryResponseInvalidQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        RawQueryResponseInvalidQueryArgs { message: None }
    }
}

pub struct RawQueryResponseInvalidQueryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryResponseInvalidQueryBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryResponseInvalidQuery::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryResponseInvalidQueryBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryResponseInvalidQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryResponseInvalidQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryResponseInvalidQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryResponseInvalidQuery");
        ds.field("message", &self.message());
        ds.finish()
    }
}
pub enum RawQueryResponseInternalErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryResponseInternalError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryResponseInternalError<'a> {
    type Inner = RawQueryResponseInternalError<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryResponseInternalError<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
    pub const VT_BACKTRACE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryResponseInternalError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RawQueryResponseInternalErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<RawQueryResponseInternalError<'bldr>> {
        let mut builder = RawQueryResponseInternalErrorBuilder::new(_fbb);
        if let Some(x) = args.backtrace {
            builder.add_backtrace(x);
        }
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                RawQueryResponseInternalError::VT_MESSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn backtrace(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                RawQueryResponseInternalError::VT_BACKTRACE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for RawQueryResponseInternalError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backtrace",
                Self::VT_BACKTRACE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct RawQueryResponseInternalErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backtrace: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for RawQueryResponseInternalErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        RawQueryResponseInternalErrorArgs {
            message: None,
            backtrace: None,
        }
    }
}

pub struct RawQueryResponseInternalErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryResponseInternalErrorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryResponseInternalError::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn add_backtrace(&mut self, backtrace: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            RawQueryResponseInternalError::VT_BACKTRACE,
            backtrace,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryResponseInternalErrorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryResponseInternalErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryResponseInternalError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryResponseInternalError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryResponseInternalError");
        ds.field("message", &self.message());
        ds.field("backtrace", &self.backtrace());
        ds.finish()
    }
}
pub enum RawQueryResponseRootOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct RawQueryResponseRoot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RawQueryResponseRoot<'a> {
    type Inner = RawQueryResponseRoot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RawQueryResponseRoot<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RawQueryResponseRoot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args RawQueryResponseRootArgs,
    ) -> flatbuffers::WIPOffset<RawQueryResponseRoot<'bldr>> {
        let mut builder = RawQueryResponseRootBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> RawQueryResponse {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<RawQueryResponse>(
                    RawQueryResponseRoot::VT_VALUE_TYPE,
                    Some(RawQueryResponse::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    RawQueryResponseRoot::VT_VALUE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_raw_query_response_progress(&self) -> Option<RawQueryResponseProgress<'a>> {
        if self.value_type() == RawQueryResponse::RawQueryResponseProgress {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RawQueryResponseProgress::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_raw_query_response_success(&self) -> Option<RawQueryResponseSuccess<'a>> {
        if self.value_type() == RawQueryResponse::RawQueryResponseSuccess {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RawQueryResponseSuccess::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_raw_query_response_invalid_query(
        &self,
    ) -> Option<RawQueryResponseInvalidQuery<'a>> {
        if self.value_type() == RawQueryResponse::RawQueryResponseInvalidQuery {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RawQueryResponseInvalidQuery::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_raw_query_response_internal_error(
        &self,
    ) -> Option<RawQueryResponseInternalError<'a>> {
        if self.value_type() == RawQueryResponse::RawQueryResponseInternalError {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { RawQueryResponseInternalError::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for RawQueryResponseRoot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<RawQueryResponse, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          RawQueryResponse::RawQueryResponseProgress => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RawQueryResponseProgress>>("RawQueryResponse::RawQueryResponseProgress", pos),
          RawQueryResponse::RawQueryResponseSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RawQueryResponseSuccess>>("RawQueryResponse::RawQueryResponseSuccess", pos),
          RawQueryResponse::RawQueryResponseInvalidQuery => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RawQueryResponseInvalidQuery>>("RawQueryResponse::RawQueryResponseInvalidQuery", pos),
          RawQueryResponse::RawQueryResponseInternalError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RawQueryResponseInternalError>>("RawQueryResponse::RawQueryResponseInternalError", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct RawQueryResponseRootArgs {
    pub value_type: RawQueryResponse,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RawQueryResponseRootArgs {
    #[inline]
    fn default() -> Self {
        RawQueryResponseRootArgs {
            value_type: RawQueryResponse::NONE,
            value: None,
        }
    }
}

pub struct RawQueryResponseRootBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RawQueryResponseRootBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: RawQueryResponse) {
        self.fbb_.push_slot::<RawQueryResponse>(
            RawQueryResponseRoot::VT_VALUE_TYPE,
            value_type,
            RawQueryResponse::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RawQueryResponseRoot::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> RawQueryResponseRootBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        RawQueryResponseRootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RawQueryResponseRoot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RawQueryResponseRoot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RawQueryResponseRoot");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            RawQueryResponse::RawQueryResponseProgress => {
                if let Some(x) = self.value_as_raw_query_response_progress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RawQueryResponse::RawQueryResponseSuccess => {
                if let Some(x) = self.value_as_raw_query_response_success() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RawQueryResponse::RawQueryResponseInvalidQuery => {
                if let Some(x) = self.value_as_raw_query_response_invalid_query() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            RawQueryResponse::RawQueryResponseInternalError => {
                if let Some(x) = self.value_as_raw_query_response_internal_error() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum WatermarkOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct Watermark<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Watermark<'a> {
    type Inner = Watermark<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Watermark<'a> {
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Watermark { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args WatermarkArgs<'args>,
    ) -> flatbuffers::WIPOffset<Watermark<'bldr>> {
        let mut builder = WatermarkBuilder::new(_fbb);
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Timestamp>(Watermark::VT_SYSTEM_TIME, None) }
    }
    #[inline]
    pub fn event_time(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<Timestamp>(Watermark::VT_EVENT_TIME, None) }
    }
}

impl flatbuffers::Verifiable for Watermark<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<Timestamp>("event_time", Self::VT_EVENT_TIME, false)?
            .finish();
        Ok(())
    }
}
pub struct WatermarkArgs<'a> {
    pub system_time: Option<&'a Timestamp>,
    pub event_time: Option<&'a Timestamp>,
}
impl<'a> Default for WatermarkArgs<'a> {
    #[inline]
    fn default() -> Self {
        WatermarkArgs {
            system_time: None,
            event_time: None,
        }
    }
}

pub struct WatermarkBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WatermarkBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_event_time(&mut self, event_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WatermarkBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        WatermarkBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Watermark<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Watermark<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Watermark");
        ds.field("system_time", &self.system_time());
        ds.field("event_time", &self.event_time());
        ds.finish()
    }
}
pub enum TransformRequestInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformRequestInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformRequestInput<'a> {
    type Inner = TransformRequestInput<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformRequestInput<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_ALIAS: flatbuffers::VOffsetT = 6;
    pub const VT_QUERY_ALIAS: flatbuffers::VOffsetT = 8;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 10;
    pub const VT_OFFSET_INTERVAL: flatbuffers::VOffsetT = 12;
    pub const VT_DATA_PATHS: flatbuffers::VOffsetT = 14;
    pub const VT_SCHEMA_FILE: flatbuffers::VOffsetT = 16;
    pub const VT_EXPLICIT_WATERMARKS: flatbuffers::VOffsetT = 18;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformRequestInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformRequestInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformRequestInput<'bldr>> {
        let mut builder = TransformRequestInputBuilder::new(_fbb);
        if let Some(x) = args.explicit_watermarks {
            builder.add_explicit_watermarks(x);
        }
        if let Some(x) = args.schema_file {
            builder.add_schema_file(x);
        }
        if let Some(x) = args.data_paths {
            builder.add_data_paths(x);
        }
        if let Some(x) = args.offset_interval {
            builder.add_offset_interval(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.query_alias {
            builder.add_query_alias(x);
        }
        if let Some(x) = args.dataset_alias {
            builder.add_dataset_alias(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    TransformRequestInput::VT_DATASET_ID,
                    None,
                )
        }
    }
    #[inline]
    pub fn dataset_alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformRequestInput::VT_DATASET_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn query_alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformRequestInput::VT_QUERY_ALIAS,
                None,
            )
        }
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                    TransformRequestInput::VT_VOCAB,
                    None,
                )
        }
    }
    #[inline]
    pub fn offset_interval(&self) -> Option<OffsetInterval<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                    TransformRequestInput::VT_OFFSET_INTERVAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn data_paths(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
            >>(TransformRequestInput::VT_DATA_PATHS, None)
        }
    }
    #[inline]
    pub fn schema_file(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformRequestInput::VT_SCHEMA_FILE,
                None,
            )
        }
    }
    #[inline]
    pub fn explicit_watermarks(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark>>,
            >>(TransformRequestInput::VT_EXPLICIT_WATERMARKS, None)
        }
    }
}

impl flatbuffers::Verifiable for TransformRequestInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_alias",
                Self::VT_DATASET_ALIAS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "query_alias",
                Self::VT_QUERY_ALIAS,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "offset_interval",
                Self::VT_OFFSET_INTERVAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("data_paths", Self::VT_DATA_PATHS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "schema_file",
                Self::VT_SCHEMA_FILE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Watermark>>,
            >>("explicit_watermarks", Self::VT_EXPLICIT_WATERMARKS, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformRequestInputArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query_alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub offset_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub data_paths: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub schema_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub explicit_watermarks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>,
        >,
    >,
}
impl<'a> Default for TransformRequestInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformRequestInputArgs {
            dataset_id: None,
            dataset_alias: None,
            query_alias: None,
            vocab: None,
            offset_interval: None,
            data_paths: None,
            schema_file: None,
            explicit_watermarks: None,
        }
    }
}

pub struct TransformRequestInputBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformRequestInputBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_dataset_alias(&mut self, dataset_alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_DATASET_ALIAS,
            dataset_alias,
        );
    }
    #[inline]
    pub fn add_query_alias(&mut self, query_alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_QUERY_ALIAS,
            query_alias,
        );
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                TransformRequestInput::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_offset_interval(
        &mut self,
        offset_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                TransformRequestInput::VT_OFFSET_INTERVAL,
                offset_interval,
            );
    }
    #[inline]
    pub fn add_data_paths(
        &mut self,
        data_paths: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_DATA_PATHS,
            data_paths,
        );
    }
    #[inline]
    pub fn add_schema_file(&mut self, schema_file: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_SCHEMA_FILE,
            schema_file,
        );
    }
    #[inline]
    pub fn add_explicit_watermarks(
        &mut self,
        explicit_watermarks: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Watermark<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequestInput::VT_EXPLICIT_WATERMARKS,
            explicit_watermarks,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformRequestInputBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformRequestInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformRequestInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformRequestInput<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformRequestInput");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_alias", &self.dataset_alias());
        ds.field("query_alias", &self.query_alias());
        ds.field("vocab", &self.vocab());
        ds.field("offset_interval", &self.offset_interval());
        ds.field("data_paths", &self.data_paths());
        ds.field("schema_file", &self.schema_file());
        ds.field("explicit_watermarks", &self.explicit_watermarks());
        ds.finish()
    }
}
pub enum TransformRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformRequest<'a> {
    type Inner = TransformRequest<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformRequest<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_ALIAS: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 10;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 14;
    pub const VT_QUERY_INPUTS: flatbuffers::VOffsetT = 16;
    pub const VT_NEXT_OFFSET: flatbuffers::VOffsetT = 18;
    pub const VT_PREV_CHECKPOINT_PATH: flatbuffers::VOffsetT = 20;
    pub const VT_NEW_CHECKPOINT_PATH: flatbuffers::VOffsetT = 22;
    pub const VT_NEW_DATA_PATH: flatbuffers::VOffsetT = 24;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformRequest<'bldr>> {
        let mut builder = TransformRequestBuilder::new(_fbb);
        builder.add_next_offset(args.next_offset);
        if let Some(x) = args.new_data_path {
            builder.add_new_data_path(x);
        }
        if let Some(x) = args.new_checkpoint_path {
            builder.add_new_checkpoint_path(x);
        }
        if let Some(x) = args.prev_checkpoint_path {
            builder.add_prev_checkpoint_path(x);
        }
        if let Some(x) = args.query_inputs {
            builder.add_query_inputs(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        if let Some(x) = args.dataset_alias {
            builder.add_dataset_alias(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    TransformRequest::VT_DATASET_ID,
                    None,
                )
        }
    }
    #[inline]
    pub fn dataset_alias(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformRequest::VT_DATASET_ALIAS, None)
        }
    }
    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Timestamp>(TransformRequest::VT_SYSTEM_TIME, None)
        }
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                    TransformRequest::VT_VOCAB,
                    None,
                )
        }
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Transform>(TransformRequest::VT_TRANSFORM_TYPE, Some(Transform::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TransformRequest::VT_TRANSFORM,
                    None,
                )
        }
    }
    #[inline]
    pub fn query_inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformRequestInput<'a>>>>
    {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformRequestInput>>,
            >>(TransformRequest::VT_QUERY_INPUTS, None)
        }
    }
    #[inline]
    pub fn next_offset(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<u64>(TransformRequest::VT_NEXT_OFFSET, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn prev_checkpoint_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformRequest::VT_PREV_CHECKPOINT_PATH,
                None,
            )
        }
    }
    #[inline]
    pub fn new_checkpoint_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformRequest::VT_NEW_CHECKPOINT_PATH,
                None,
            )
        }
    }
    #[inline]
    pub fn new_data_path(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TransformRequest::VT_NEW_DATA_PATH, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformSql::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for TransformRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_alias",
                Self::VT_DATASET_ALIAS,
                false,
            )?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransformRequestInput>>,
            >>("query_inputs", Self::VT_QUERY_INPUTS, false)?
            .visit_field::<u64>("next_offset", Self::VT_NEXT_OFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prev_checkpoint_path",
                Self::VT_PREV_CHECKPOINT_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "new_checkpoint_path",
                Self::VT_NEW_CHECKPOINT_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "new_data_path",
                Self::VT_NEW_DATA_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TransformRequestArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system_time: Option<&'a Timestamp>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub query_inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformRequestInput<'a>>>,
        >,
    >,
    pub next_offset: u64,
    pub prev_checkpoint_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub new_checkpoint_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub new_data_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransformRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformRequestArgs {
            dataset_id: None,
            dataset_alias: None,
            system_time: None,
            vocab: None,
            transform_type: Transform::NONE,
            transform: None,
            query_inputs: None,
            next_offset: 0,
            prev_checkpoint_path: None,
            new_checkpoint_path: None,
            new_data_path: None,
        }
    }
}

pub struct TransformRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformRequestBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_dataset_alias(&mut self, dataset_alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_DATASET_ALIAS,
            dataset_alias,
        );
    }
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(TransformRequest::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                TransformRequest::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            TransformRequest::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_TRANSFORM,
            transform,
        );
    }
    #[inline]
    pub fn add_query_inputs(
        &mut self,
        query_inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransformRequestInput<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_QUERY_INPUTS,
            query_inputs,
        );
    }
    #[inline]
    pub fn add_next_offset(&mut self, next_offset: u64) {
        self.fbb_
            .push_slot::<u64>(TransformRequest::VT_NEXT_OFFSET, next_offset, 0);
    }
    #[inline]
    pub fn add_prev_checkpoint_path(
        &mut self,
        prev_checkpoint_path: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_PREV_CHECKPOINT_PATH,
            prev_checkpoint_path,
        );
    }
    #[inline]
    pub fn add_new_checkpoint_path(
        &mut self,
        new_checkpoint_path: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_NEW_CHECKPOINT_PATH,
            new_checkpoint_path,
        );
    }
    #[inline]
    pub fn add_new_data_path(&mut self, new_data_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformRequest::VT_NEW_DATA_PATH,
            new_data_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformRequestBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformRequest");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_alias", &self.dataset_alias());
        ds.field("system_time", &self.system_time());
        ds.field("vocab", &self.vocab());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.field("query_inputs", &self.query_inputs());
        ds.field("next_offset", &self.next_offset());
        ds.field("prev_checkpoint_path", &self.prev_checkpoint_path());
        ds.field("new_checkpoint_path", &self.new_checkpoint_path());
        ds.field("new_data_path", &self.new_data_path());
        ds.finish()
    }
}
pub enum TransformResponseProgressOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformResponseProgress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformResponseProgress<'a> {
    type Inner = TransformResponseProgress<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformResponseProgress<'a> {
    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformResponseProgress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        _args: &'args TransformResponseProgressArgs,
    ) -> flatbuffers::WIPOffset<TransformResponseProgress<'bldr>> {
        let mut builder = TransformResponseProgressBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for TransformResponseProgress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct TransformResponseProgressArgs {}
impl<'a> Default for TransformResponseProgressArgs {
    #[inline]
    fn default() -> Self {
        TransformResponseProgressArgs {}
    }
}

pub struct TransformResponseProgressBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformResponseProgressBuilder<'a, 'b, A> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformResponseProgressBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformResponseProgressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformResponseProgress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformResponseProgress<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformResponseProgress");
        ds.finish()
    }
}
pub enum TransformResponseSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformResponseSuccess<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformResponseSuccess<'a> {
    type Inner = TransformResponseSuccess<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformResponseSuccess<'a> {
    pub const VT_NEW_OFFSET_INTERVAL: flatbuffers::VOffsetT = 4;
    pub const VT_NEW_WATERMARK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformResponseSuccess { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformResponseSuccessArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformResponseSuccess<'bldr>> {
        let mut builder = TransformResponseSuccessBuilder::new(_fbb);
        if let Some(x) = args.new_watermark {
            builder.add_new_watermark(x);
        }
        if let Some(x) = args.new_offset_interval {
            builder.add_new_offset_interval(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn new_offset_interval(&self) -> Option<OffsetInterval<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                    TransformResponseSuccess::VT_NEW_OFFSET_INTERVAL,
                    None,
                )
        }
    }
    #[inline]
    pub fn new_watermark(&self) -> Option<&'a Timestamp> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Timestamp>(TransformResponseSuccess::VT_NEW_WATERMARK, None)
        }
    }
}

impl flatbuffers::Verifiable for TransformResponseSuccess<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "new_offset_interval",
                Self::VT_NEW_OFFSET_INTERVAL,
                false,
            )?
            .visit_field::<Timestamp>("new_watermark", Self::VT_NEW_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformResponseSuccessArgs<'a> {
    pub new_offset_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub new_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for TransformResponseSuccessArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformResponseSuccessArgs {
            new_offset_interval: None,
            new_watermark: None,
        }
    }
}

pub struct TransformResponseSuccessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformResponseSuccessBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_new_offset_interval(
        &mut self,
        new_offset_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                TransformResponseSuccess::VT_NEW_OFFSET_INTERVAL,
                new_offset_interval,
            );
    }
    #[inline]
    pub fn add_new_watermark(&mut self, new_watermark: &Timestamp) {
        self.fbb_.push_slot_always::<&Timestamp>(
            TransformResponseSuccess::VT_NEW_WATERMARK,
            new_watermark,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformResponseSuccessBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformResponseSuccessBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformResponseSuccess<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformResponseSuccess<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformResponseSuccess");
        ds.field("new_offset_interval", &self.new_offset_interval());
        ds.field("new_watermark", &self.new_watermark());
        ds.finish()
    }
}
pub enum TransformResponseInvalidQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformResponseInvalidQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformResponseInvalidQuery<'a> {
    type Inner = TransformResponseInvalidQuery<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformResponseInvalidQuery<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformResponseInvalidQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformResponseInvalidQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformResponseInvalidQuery<'bldr>> {
        let mut builder = TransformResponseInvalidQueryBuilder::new(_fbb);
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformResponseInvalidQuery::VT_MESSAGE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for TransformResponseInvalidQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformResponseInvalidQueryArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransformResponseInvalidQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformResponseInvalidQueryArgs { message: None }
    }
}

pub struct TransformResponseInvalidQueryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformResponseInvalidQueryBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformResponseInvalidQuery::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformResponseInvalidQueryBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformResponseInvalidQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformResponseInvalidQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformResponseInvalidQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformResponseInvalidQuery");
        ds.field("message", &self.message());
        ds.finish()
    }
}
pub enum TransformResponseInternalErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformResponseInternalError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformResponseInternalError<'a> {
    type Inner = TransformResponseInternalError<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformResponseInternalError<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
    pub const VT_BACKTRACE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformResponseInternalError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformResponseInternalErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformResponseInternalError<'bldr>> {
        let mut builder = TransformResponseInternalErrorBuilder::new(_fbb);
        if let Some(x) = args.backtrace {
            builder.add_backtrace(x);
        }
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformResponseInternalError::VT_MESSAGE,
                None,
            )
        }
    }
    #[inline]
    pub fn backtrace(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
                TransformResponseInternalError::VT_BACKTRACE,
                None,
            )
        }
    }
}

impl flatbuffers::Verifiable for TransformResponseInternalError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backtrace",
                Self::VT_BACKTRACE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TransformResponseInternalErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backtrace: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransformResponseInternalErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformResponseInternalErrorArgs {
            message: None,
            backtrace: None,
        }
    }
}

pub struct TransformResponseInternalErrorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformResponseInternalErrorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformResponseInternalError::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn add_backtrace(&mut self, backtrace: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformResponseInternalError::VT_BACKTRACE,
            backtrace,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformResponseInternalErrorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformResponseInternalErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformResponseInternalError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformResponseInternalError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformResponseInternalError");
        ds.field("message", &self.message());
        ds.field("backtrace", &self.backtrace());
        ds.finish()
    }
}
pub enum TransformResponseRootOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
pub struct TransformResponseRoot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformResponseRoot<'a> {
    type Inner = TransformResponseRoot<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TransformResponseRoot<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformResponseRoot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args TransformResponseRootArgs,
    ) -> flatbuffers::WIPOffset<TransformResponseRoot<'bldr>> {
        let mut builder = TransformResponseRootBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> TransformResponse {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<TransformResponse>(
                    TransformResponseRoot::VT_VALUE_TYPE,
                    Some(TransformResponse::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    TransformResponseRoot::VT_VALUE,
                    None,
                )
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_transform_response_progress(&self) -> Option<TransformResponseProgress<'a>> {
        if self.value_type() == TransformResponse::TransformResponseProgress {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformResponseProgress::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_transform_response_success(&self) -> Option<TransformResponseSuccess<'a>> {
        if self.value_type() == TransformResponse::TransformResponseSuccess {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformResponseSuccess::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_transform_response_invalid_query(
        &self,
    ) -> Option<TransformResponseInvalidQuery<'a>> {
        if self.value_type() == TransformResponse::TransformResponseInvalidQuery {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformResponseInvalidQuery::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_transform_response_internal_error(
        &self,
    ) -> Option<TransformResponseInternalError<'a>> {
        if self.value_type() == TransformResponse::TransformResponseInternalError {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TransformResponseInternalError::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for TransformResponseRoot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<TransformResponse, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          TransformResponse::TransformResponseProgress => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformResponseProgress>>("TransformResponse::TransformResponseProgress", pos),
          TransformResponse::TransformResponseSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformResponseSuccess>>("TransformResponse::TransformResponseSuccess", pos),
          TransformResponse::TransformResponseInvalidQuery => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformResponseInvalidQuery>>("TransformResponse::TransformResponseInvalidQuery", pos),
          TransformResponse::TransformResponseInternalError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformResponseInternalError>>("TransformResponse::TransformResponseInternalError", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct TransformResponseRootArgs {
    pub value_type: TransformResponse,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for TransformResponseRootArgs {
    #[inline]
    fn default() -> Self {
        TransformResponseRootArgs {
            value_type: TransformResponse::NONE,
            value: None,
        }
    }
}

pub struct TransformResponseRootBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransformResponseRootBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: TransformResponse) {
        self.fbb_.push_slot::<TransformResponse>(
            TransformResponseRoot::VT_VALUE_TYPE,
            value_type,
            TransformResponse::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformResponseRoot::VT_VALUE, value);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> TransformResponseRootBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        TransformResponseRootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformResponseRoot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformResponseRoot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformResponseRoot");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            TransformResponse::TransformResponseProgress => {
                if let Some(x) = self.value_as_transform_response_progress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TransformResponse::TransformResponseSuccess => {
                if let Some(x) = self.value_as_transform_response_success() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TransformResponse::TransformResponseInvalidQuery => {
                if let Some(x) = self.value_as_transform_response_invalid_query() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            TransformResponse::TransformResponseInternalError => {
                if let Some(x) = self.value_as_transform_response_internal_error() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
