// Copyright Kamu Data, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EVENT_TIME_SOURCE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EVENT_TIME_SOURCE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TIME_SOURCE: [EventTimeSource; 3] = [
    EventTimeSource::NONE,
    EventTimeSource::EventTimeSourceFromMetadata,
    EventTimeSource::EventTimeSourceFromPath,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventTimeSource(pub u8);
#[allow(non_upper_case_globals)]
impl EventTimeSource {
    pub const NONE: Self = Self(0);
    pub const EventTimeSourceFromMetadata: Self = Self(1);
    pub const EventTimeSourceFromPath: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EventTimeSourceFromMetadata,
        Self::EventTimeSourceFromPath,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EventTimeSourceFromMetadata => Some("EventTimeSourceFromMetadata"),
            Self::EventTimeSourceFromPath => Some("EventTimeSourceFromPath"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for EventTimeSource {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for EventTimeSource {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for EventTimeSource {
    type Output = EventTimeSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for EventTimeSource {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for EventTimeSource {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for EventTimeSource {}
pub struct EventTimeSourceUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_CACHING: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_CACHING: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_CACHING: [SourceCaching; 2] =
    [SourceCaching::NONE, SourceCaching::SourceCachingForever];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceCaching(pub u8);
#[allow(non_upper_case_globals)]
impl SourceCaching {
    pub const NONE: Self = Self(0);
    pub const SourceCachingForever: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SourceCachingForever];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SourceCachingForever => Some("SourceCachingForever"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for SourceCaching {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceCaching {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for SourceCaching {
    type Output = SourceCaching;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for SourceCaching {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceCaching {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceCaching {}
pub struct SourceCachingUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_ORDERING: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_ORDERING: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_ORDERING: [SourceOrdering; 2] =
    [SourceOrdering::ByEventTime, SourceOrdering::ByName];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceOrdering(pub i32);
#[allow(non_upper_case_globals)]
impl SourceOrdering {
    pub const ByEventTime: Self = Self(0);
    pub const ByName: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ByEventTime, Self::ByName];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ByEventTime => Some("ByEventTime"),
            Self::ByName => Some("ByName"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for SourceOrdering {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceOrdering {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for SourceOrdering {
    type Output = SourceOrdering;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for SourceOrdering {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i32::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i32::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceOrdering {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceOrdering {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_FETCH_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_FETCH_STEP: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FETCH_STEP: [FetchStep; 3] = [
    FetchStep::NONE,
    FetchStep::FetchStepUrl,
    FetchStep::FetchStepFilesGlob,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FetchStep(pub u8);
#[allow(non_upper_case_globals)]
impl FetchStep {
    pub const NONE: Self = Self(0);
    pub const FetchStepUrl: Self = Self(1);
    pub const FetchStepFilesGlob: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::FetchStepUrl, Self::FetchStepFilesGlob];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FetchStepUrl => Some("FetchStepUrl"),
            Self::FetchStepFilesGlob => Some("FetchStepFilesGlob"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for FetchStep {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for FetchStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for FetchStep {
    type Output = FetchStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for FetchStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for FetchStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for FetchStep {}
pub struct FetchStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COMPRESSION_FORMAT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COMPRESSION_FORMAT: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPRESSION_FORMAT: [CompressionFormat; 2] =
    [CompressionFormat::Gzip, CompressionFormat::Zip];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CompressionFormat(pub i32);
#[allow(non_upper_case_globals)]
impl CompressionFormat {
    pub const Gzip: Self = Self(0);
    pub const Zip: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Gzip, Self::Zip];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Gzip => Some("Gzip"),
            Self::Zip => Some("Zip"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for CompressionFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CompressionFormat {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for CompressionFormat {
    type Output = CompressionFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for CompressionFormat {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i32::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i32::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CompressionFormat {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CompressionFormat {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PREP_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PREP_STEP: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PREP_STEP: [PrepStep; 3] = [
    PrepStep::NONE,
    PrepStep::PrepStepDecompress,
    PrepStep::PrepStepPipe,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PrepStep(pub u8);
#[allow(non_upper_case_globals)]
impl PrepStep {
    pub const NONE: Self = Self(0);
    pub const PrepStepDecompress: Self = Self(1);
    pub const PrepStepPipe: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::PrepStepDecompress, Self::PrepStepPipe];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PrepStepDecompress => Some("PrepStepDecompress"),
            Self::PrepStepPipe => Some("PrepStepPipe"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for PrepStep {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PrepStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for PrepStep {
    type Output = PrepStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for PrepStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PrepStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PrepStep {}
pub struct PrepStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_READ_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_READ_STEP: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_READ_STEP: [ReadStep; 5] = [
    ReadStep::NONE,
    ReadStep::ReadStepCsv,
    ReadStep::ReadStepJsonLines,
    ReadStep::ReadStepGeoJson,
    ReadStep::ReadStepEsriShapefile,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReadStep(pub u8);
#[allow(non_upper_case_globals)]
impl ReadStep {
    pub const NONE: Self = Self(0);
    pub const ReadStepCsv: Self = Self(1);
    pub const ReadStepJsonLines: Self = Self(2);
    pub const ReadStepGeoJson: Self = Self(3);
    pub const ReadStepEsriShapefile: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ReadStepCsv,
        Self::ReadStepJsonLines,
        Self::ReadStepGeoJson,
        Self::ReadStepEsriShapefile,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ReadStepCsv => Some("ReadStepCsv"),
            Self::ReadStepJsonLines => Some("ReadStepJsonLines"),
            Self::ReadStepGeoJson => Some("ReadStepGeoJson"),
            Self::ReadStepEsriShapefile => Some("ReadStepEsriShapefile"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for ReadStep {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ReadStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ReadStep {
    type Output = ReadStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ReadStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ReadStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ReadStep {}
pub struct ReadStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TRANSFORM: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TRANSFORM: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM: [Transform; 2] = [Transform::NONE, Transform::TransformSql];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Transform(pub u8);
#[allow(non_upper_case_globals)]
impl Transform {
    pub const NONE: Self = Self(0);
    pub const TransformSql: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TransformSql];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TransformSql => Some("TransformSql"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for Transform {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for Transform {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
pub struct TransformUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MERGE_STRATEGY: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MERGE_STRATEGY: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MERGE_STRATEGY: [MergeStrategy; 4] = [
    MergeStrategy::NONE,
    MergeStrategy::MergeStrategyAppend,
    MergeStrategy::MergeStrategyLedger,
    MergeStrategy::MergeStrategySnapshot,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MergeStrategy(pub u8);
#[allow(non_upper_case_globals)]
impl MergeStrategy {
    pub const NONE: Self = Self(0);
    pub const MergeStrategyAppend: Self = Self(1);
    pub const MergeStrategyLedger: Self = Self(2);
    pub const MergeStrategySnapshot: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MergeStrategyAppend,
        Self::MergeStrategyLedger,
        Self::MergeStrategySnapshot,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MergeStrategyAppend => Some("MergeStrategyAppend"),
            Self::MergeStrategyLedger => Some("MergeStrategyLedger"),
            Self::MergeStrategySnapshot => Some("MergeStrategySnapshot"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for MergeStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MergeStrategy {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for MergeStrategy {
    type Output = MergeStrategy;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for MergeStrategy {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MergeStrategy {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MergeStrategy {}
pub struct MergeStrategyUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATASET_SOURCE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATASET_SOURCE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATASET_SOURCE: [DatasetSource; 3] = [
    DatasetSource::NONE,
    DatasetSource::DatasetSourceRoot,
    DatasetSource::DatasetSourceDerivative,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DatasetSource(pub u8);
#[allow(non_upper_case_globals)]
impl DatasetSource {
    pub const NONE: Self = Self(0);
    pub const DatasetSourceRoot: Self = Self(1);
    pub const DatasetSourceDerivative: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::DatasetSourceRoot,
        Self::DatasetSourceDerivative,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::DatasetSourceRoot => Some("DatasetSourceRoot"),
            Self::DatasetSourceDerivative => Some("DatasetSourceDerivative"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for DatasetSource {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DatasetSource {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for DatasetSource {
    type Output = DatasetSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for DatasetSource {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DatasetSource {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DatasetSource {}
pub struct DatasetSourceUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EXECUTE_QUERY_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EXECUTE_QUERY_RESPONSE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXECUTE_QUERY_RESPONSE: [ExecuteQueryResponse; 5] = [
    ExecuteQueryResponse::NONE,
    ExecuteQueryResponse::ExecuteQueryResponseProgress,
    ExecuteQueryResponse::ExecuteQueryResponseSuccess,
    ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery,
    ExecuteQueryResponse::ExecuteQueryResponseInternalError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExecuteQueryResponse(pub u8);
#[allow(non_upper_case_globals)]
impl ExecuteQueryResponse {
    pub const NONE: Self = Self(0);
    pub const ExecuteQueryResponseProgress: Self = Self(1);
    pub const ExecuteQueryResponseSuccess: Self = Self(2);
    pub const ExecuteQueryResponseInvalidQuery: Self = Self(3);
    pub const ExecuteQueryResponseInternalError: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ExecuteQueryResponseProgress,
        Self::ExecuteQueryResponseSuccess,
        Self::ExecuteQueryResponseInvalidQuery,
        Self::ExecuteQueryResponseInternalError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ExecuteQueryResponseProgress => Some("ExecuteQueryResponseProgress"),
            Self::ExecuteQueryResponseSuccess => Some("ExecuteQueryResponseSuccess"),
            Self::ExecuteQueryResponseInvalidQuery => Some("ExecuteQueryResponseInvalidQuery"),
            Self::ExecuteQueryResponseInternalError => Some("ExecuteQueryResponseInternalError"),
            _ => None,
        }
    }
}
impl std::fmt::Debug for ExecuteQueryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponse {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ExecuteQueryResponse {
    type Output = ExecuteQueryResponse;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ExecuteQueryResponse {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ExecuteQueryResponse {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ExecuteQueryResponse {}
pub struct ExecuteQueryResponseUnionTableOffset {}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// struct Timestamp, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Timestamp(pub [u8; 16]);
impl Default for Timestamp {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl std::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Timestamp")
            .field("year", &self.year())
            .field("ordinal", &self.ordinal())
            .field("seconds_from_midnight", &self.seconds_from_midnight())
            .field("nanoseconds", &self.nanoseconds())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Timestamp>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Timestamp {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}
impl<'a> Timestamp {
    #[allow(clippy::too_many_arguments)]
    pub fn new(year: i32, ordinal: u16, seconds_from_midnight: u32, nanoseconds: u32) -> Self {
        let mut s = Self([0; 16]);
        s.set_year(year);
        s.set_ordinal(ordinal);
        s.set_seconds_from_midnight(seconds_from_midnight);
        s.set_nanoseconds(nanoseconds);
        s
    }

    pub fn year(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<i32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<i32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_year(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const i32 as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<i32>(),
            );
        }
    }

    pub fn ordinal(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<u16>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u16>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_ordinal(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u16 as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<u16>(),
            );
        }
    }

    pub fn seconds_from_midnight(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<u32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_seconds_from_midnight(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u32 as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<u32>(),
            );
        }
    }

    pub fn nanoseconds(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<u32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_nanoseconds(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u32 as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<u32>(),
            );
        }
    }
}

pub enum BlockIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct BlockInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockInterval<'a> {
    type Inner = BlockInterval<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BlockInterval<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockIntervalArgs<'args>,
    ) -> flatbuffers::WIPOffset<BlockInterval<'bldr>> {
        let mut builder = BlockIntervalBuilder::new(_fbb);
        if let Some(x) = args.end {
            builder.add_end(x);
        }
        if let Some(x) = args.start {
            builder.add_start(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                BlockInterval::VT_START,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn end(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                BlockInterval::VT_END,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

impl flatbuffers::Verifiable for BlockInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "start",
                Self::VT_START,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "end",
                Self::VT_END,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct BlockIntervalArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub end: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BlockIntervalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockIntervalArgs {
            start: None,
            end: None,
        }
    }
}
pub struct BlockIntervalBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockIntervalBuilder<'a, 'b> {
    #[inline]
    pub fn add_start(&mut self, start: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockInterval::VT_START, start);
    }
    #[inline]
    pub fn add_end(&mut self, end: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockInterval::VT_END, end);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockIntervalBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BlockInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for BlockInterval<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("BlockInterval");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum EventTimeSourceFromMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromMetadata<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromMetadata<'a> {
    type Inner = EventTimeSourceFromMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EventTimeSourceFromMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromMetadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args EventTimeSourceFromMetadataArgs,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'bldr>> {
        let mut builder = EventTimeSourceFromMetadataBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromMetadata<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromMetadataArgs {}
impl<'a> Default for EventTimeSourceFromMetadataArgs {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromMetadataArgs {}
    }
}
pub struct EventTimeSourceFromMetadataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromMetadataBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> EventTimeSourceFromMetadataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EventTimeSourceFromMetadataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for EventTimeSourceFromMetadata<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromMetadata");
        ds.finish()
    }
}
pub enum EventTimeSourceFromPathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventTimeSourceFromPath<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromPath<'a> {
    type Inner = EventTimeSourceFromPath<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EventTimeSourceFromPath<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromPath { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EventTimeSourceFromPathArgs<'args>,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'bldr>> {
        let mut builder = EventTimeSourceFromPathBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EventTimeSourceFromPath::VT_PATTERN, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
            None,
        )
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromPath<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromPathArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EventTimeSourceFromPathArgs<'a> {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromPathArgs {
            pattern: None,
            timestamp_format: None,
        }
    }
}
pub struct EventTimeSourceFromPathBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromPathBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_PATTERN,
            pattern,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> EventTimeSourceFromPathBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EventTimeSourceFromPathBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for EventTimeSourceFromPath<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromPath");
        ds.field("pattern", &self.pattern());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum SourceCachingForeverOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SourceCachingForever<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceCachingForever<'a> {
    type Inner = SourceCachingForever<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SourceCachingForever<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceCachingForever { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args SourceCachingForeverArgs,
    ) -> flatbuffers::WIPOffset<SourceCachingForever<'bldr>> {
        let mut builder = SourceCachingForeverBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for SourceCachingForever<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct SourceCachingForeverArgs {}
impl<'a> Default for SourceCachingForeverArgs {
    #[inline]
    fn default() -> Self {
        SourceCachingForeverArgs {}
    }
}
pub struct SourceCachingForeverBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SourceCachingForeverBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> SourceCachingForeverBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SourceCachingForeverBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SourceCachingForever<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for SourceCachingForever<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("SourceCachingForever");
        ds.finish()
    }
}
pub enum FetchStepUrlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepUrl<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepUrl<'a> {
    type Inner = FetchStepUrl<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FetchStepUrl<'a> {
    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepUrl { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepUrlArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepUrl<'bldr>> {
        let mut builder = FetchStepUrlBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.url {
            builder.add_url(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn url(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepUrl::VT_URL, None)
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        self._tab
            .get::<EventTimeSource>(
                FetchStepUrl::VT_EVENT_TIME_TYPE,
                Some(EventTimeSource::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepUrl::VT_EVENT_TIME,
                None,
            )
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        self._tab
            .get::<SourceCaching>(FetchStepUrl::VT_CACHE_TYPE, Some(SourceCaching::NONE))
            .unwrap()
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepUrl::VT_CACHE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time()
                .map(EventTimeSourceFromMetadata::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time()
                .map(EventTimeSourceFromPath::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(SourceCachingForever::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepUrl<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct FetchStepUrlArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FetchStepUrlArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepUrlArgs {
            url: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
        }
    }
}
pub struct FetchStepUrlBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepUrlBuilder<'a, 'b> {
    #[inline]
    pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_URL, url);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepUrl::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepUrl::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_CACHE, cache);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FetchStepUrlBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FetchStepUrlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepUrl<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for FetchStepUrl<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("FetchStepUrl");
        ds.field("url", &self.url());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.finish()
    }
}
pub enum FetchStepFilesGlobOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FetchStepFilesGlob<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepFilesGlob<'a> {
    type Inner = FetchStepFilesGlob<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FetchStepFilesGlob<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;
    pub const VT_ORDER: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepFilesGlob { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepFilesGlobArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'bldr>> {
        let mut builder = FetchStepFilesGlobBuilder::new(_fbb);
        if let Some(x) = args.order {
            builder.add_order(x);
        }
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepFilesGlob::VT_PATH, None)
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        self._tab
            .get::<EventTimeSource>(
                FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
                Some(EventTimeSource::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepFilesGlob::VT_EVENT_TIME,
                None,
            )
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        self._tab
            .get::<SourceCaching>(FetchStepFilesGlob::VT_CACHE_TYPE, Some(SourceCaching::NONE))
            .unwrap()
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepFilesGlob::VT_CACHE,
                None,
            )
    }
    #[inline]
    pub fn order(&self) -> Option<SourceOrdering> {
        self._tab
            .get::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time()
                .map(EventTimeSourceFromMetadata::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time()
                .map(EventTimeSourceFromPath::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(SourceCachingForever::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepFilesGlob<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<SourceOrdering>("order", Self::VT_ORDER, false)?
     .finish();
        Ok(())
    }
}
pub struct FetchStepFilesGlobArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub order: Option<SourceOrdering>,
}
impl<'a> Default for FetchStepFilesGlobArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepFilesGlobArgs {
            path: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
            order: None,
        }
    }
}
pub struct FetchStepFilesGlobBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepFilesGlobBuilder<'a, 'b> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_PATH, path);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepFilesGlob::VT_EVENT_TIME,
            event_time,
        );
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepFilesGlob::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_CACHE, cache);
    }
    #[inline]
    pub fn add_order(&mut self, order: SourceOrdering) {
        self.fbb_
            .push_slot_always::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, order);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> FetchStepFilesGlobBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FetchStepFilesGlobBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for FetchStepFilesGlob<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("FetchStepFilesGlob");
        ds.field("path", &self.path());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.field("order", &self.order());
        ds.finish()
    }
}
pub enum PrepStepDecompressOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepStepDecompress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepDecompress<'a> {
    type Inner = PrepStepDecompress<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepDecompress<'a> {
    pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepDecompress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepDecompressArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepDecompress<'bldr>> {
        let mut builder = PrepStepDecompressBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        builder.add_format(args.format);
        builder.finish()
    }

    #[inline]
    pub fn format(&self) -> CompressionFormat {
        self._tab
            .get::<CompressionFormat>(PrepStepDecompress::VT_FORMAT, Some(CompressionFormat::Gzip))
            .unwrap()
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(PrepStepDecompress::VT_SUB_PATH, None)
    }
}

impl flatbuffers::Verifiable for PrepStepDecompress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<CompressionFormat>("format", Self::VT_FORMAT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepDecompressArgs<'a> {
    pub format: CompressionFormat,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PrepStepDecompressArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepDecompressArgs {
            format: CompressionFormat::Gzip,
            sub_path: None,
        }
    }
}
pub struct PrepStepDecompressBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepDecompressBuilder<'a, 'b> {
    #[inline]
    pub fn add_format(&mut self, format: CompressionFormat) {
        self.fbb_.push_slot::<CompressionFormat>(
            PrepStepDecompress::VT_FORMAT,
            format,
            CompressionFormat::Gzip,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PrepStepDecompress::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> PrepStepDecompressBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepDecompressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepDecompress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for PrepStepDecompress<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("PrepStepDecompress");
        ds.field("format", &self.format());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum PrepStepPipeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepStepPipe<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepPipe<'a> {
    type Inner = PrepStepPipe<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepPipe<'a> {
    pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepPipe { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepPipeArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepPipe<'bldr>> {
        let mut builder = PrepStepPipeBuilder::new(_fbb);
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn command(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(PrepStepPipe::VT_COMMAND, None)
    }
}

impl flatbuffers::Verifiable for PrepStepPipe<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("command", Self::VT_COMMAND, false)?
            .finish();
        Ok(())
    }
}
pub struct PrepStepPipeArgs<'a> {
    pub command: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for PrepStepPipeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepPipeArgs { command: None }
    }
}
pub struct PrepStepPipeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepPipeBuilder<'a, 'b> {
    #[inline]
    pub fn add_command(
        &mut self,
        command: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepPipe::VT_COMMAND, command);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepPipeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepPipeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepPipe<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for PrepStepPipe<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("PrepStepPipe");
        ds.field("command", &self.command());
        ds.finish()
    }
}
pub enum ReadStepCsvOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepCsv<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepCsv<'a> {
    type Inner = ReadStepCsv<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepCsv<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SEPARATOR: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_QUOTE: flatbuffers::VOffsetT = 10;
    pub const VT_ESCAPE: flatbuffers::VOffsetT = 12;
    pub const VT_COMMENT: flatbuffers::VOffsetT = 14;
    pub const VT_HEADER: flatbuffers::VOffsetT = 16;
    pub const VT_ENFORCE_SCHEMA: flatbuffers::VOffsetT = 18;
    pub const VT_INFER_SCHEMA: flatbuffers::VOffsetT = 20;
    pub const VT_IGNORE_LEADING_WHITE_SPACE: flatbuffers::VOffsetT = 22;
    pub const VT_IGNORE_TRAILING_WHITE_SPACE: flatbuffers::VOffsetT = 24;
    pub const VT_NULL_VALUE: flatbuffers::VOffsetT = 26;
    pub const VT_EMPTY_VALUE: flatbuffers::VOffsetT = 28;
    pub const VT_NAN_VALUE: flatbuffers::VOffsetT = 30;
    pub const VT_POSITIVE_INF: flatbuffers::VOffsetT = 32;
    pub const VT_NEGATIVE_INF: flatbuffers::VOffsetT = 34;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 36;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 38;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 40;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepCsv { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepCsvArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepCsv<'bldr>> {
        let mut builder = ReadStepCsvBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.negative_inf {
            builder.add_negative_inf(x);
        }
        if let Some(x) = args.positive_inf {
            builder.add_positive_inf(x);
        }
        if let Some(x) = args.nan_value {
            builder.add_nan_value(x);
        }
        if let Some(x) = args.empty_value {
            builder.add_empty_value(x);
        }
        if let Some(x) = args.null_value {
            builder.add_null_value(x);
        }
        if let Some(x) = args.comment {
            builder.add_comment(x);
        }
        if let Some(x) = args.escape {
            builder.add_escape(x);
        }
        if let Some(x) = args.quote {
            builder.add_quote(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.separator {
            builder.add_separator(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.multi_line {
            builder.add_multi_line(x);
        }
        if let Some(x) = args.ignore_trailing_white_space {
            builder.add_ignore_trailing_white_space(x);
        }
        if let Some(x) = args.ignore_leading_white_space {
            builder.add_ignore_leading_white_space(x);
        }
        if let Some(x) = args.infer_schema {
            builder.add_infer_schema(x);
        }
        if let Some(x) = args.enforce_schema {
            builder.add_enforce_schema(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepCsv::VT_SCHEMA, None)
    }
    #[inline]
    pub fn separator(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_SEPARATOR, None)
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ENCODING, None)
    }
    #[inline]
    pub fn quote(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_QUOTE, None)
    }
    #[inline]
    pub fn escape(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ESCAPE, None)
    }
    #[inline]
    pub fn comment(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_COMMENT, None)
    }
    #[inline]
    pub fn header(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_HEADER, None)
    }
    #[inline]
    pub fn enforce_schema(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, None)
    }
    #[inline]
    pub fn infer_schema(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_INFER_SCHEMA, None)
    }
    #[inline]
    pub fn ignore_leading_white_space(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE, None)
    }
    #[inline]
    pub fn ignore_trailing_white_space(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE, None)
    }
    #[inline]
    pub fn null_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NULL_VALUE, None)
    }
    #[inline]
    pub fn empty_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_EMPTY_VALUE, None)
    }
    #[inline]
    pub fn nan_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NAN_VALUE, None)
    }
    #[inline]
    pub fn positive_inf(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_POSITIVE_INF, None)
    }
    #[inline]
    pub fn negative_inf(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NEGATIVE_INF, None)
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_DATE_FORMAT, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_TIMESTAMP_FORMAT, None)
    }
    #[inline]
    pub fn multi_line(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_MULTI_LINE, None)
    }
}

impl flatbuffers::Verifiable for ReadStepCsv<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "separator",
                Self::VT_SEPARATOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("quote", Self::VT_QUOTE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("escape", Self::VT_ESCAPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
            .visit_field::<bool>("header", Self::VT_HEADER, false)?
            .visit_field::<bool>("enforce_schema", Self::VT_ENFORCE_SCHEMA, false)?
            .visit_field::<bool>("infer_schema", Self::VT_INFER_SCHEMA, false)?
            .visit_field::<bool>(
                "ignore_leading_white_space",
                Self::VT_IGNORE_LEADING_WHITE_SPACE,
                false,
            )?
            .visit_field::<bool>(
                "ignore_trailing_white_space",
                Self::VT_IGNORE_TRAILING_WHITE_SPACE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "null_value",
                Self::VT_NULL_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "empty_value",
                Self::VT_EMPTY_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nan_value",
                Self::VT_NAN_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "positive_inf",
                Self::VT_POSITIVE_INF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "negative_inf",
                Self::VT_NEGATIVE_INF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .visit_field::<bool>("multi_line", Self::VT_MULTI_LINE, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepCsvArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub separator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quote: Option<flatbuffers::WIPOffset<&'a str>>,
    pub escape: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub header: Option<bool>,
    pub enforce_schema: Option<bool>,
    pub infer_schema: Option<bool>,
    pub ignore_leading_white_space: Option<bool>,
    pub ignore_trailing_white_space: Option<bool>,
    pub null_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub empty_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nan_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub positive_inf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub negative_inf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multi_line: Option<bool>,
}
impl<'a> Default for ReadStepCsvArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepCsvArgs {
            schema: None,
            separator: None,
            encoding: None,
            quote: None,
            escape: None,
            comment: None,
            header: None,
            enforce_schema: None,
            infer_schema: None,
            ignore_leading_white_space: None,
            ignore_trailing_white_space: None,
            null_value: None,
            empty_value: None,
            nan_value: None,
            positive_inf: None,
            negative_inf: None,
            date_format: None,
            timestamp_format: None,
            multi_line: None,
        }
    }
}
pub struct ReadStepCsvBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepCsvBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_separator(&mut self, separator: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SEPARATOR, separator);
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ENCODING, encoding);
    }
    #[inline]
    pub fn add_quote(&mut self, quote: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_QUOTE, quote);
    }
    #[inline]
    pub fn add_escape(&mut self, escape: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ESCAPE, escape);
    }
    #[inline]
    pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_COMMENT, comment);
    }
    #[inline]
    pub fn add_header(&mut self, header: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_HEADER, header);
    }
    #[inline]
    pub fn add_enforce_schema(&mut self, enforce_schema: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, enforce_schema);
    }
    #[inline]
    pub fn add_infer_schema(&mut self, infer_schema: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_INFER_SCHEMA, infer_schema);
    }
    #[inline]
    pub fn add_ignore_leading_white_space(&mut self, ignore_leading_white_space: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE,
            ignore_leading_white_space,
        );
    }
    #[inline]
    pub fn add_ignore_trailing_white_space(&mut self, ignore_trailing_white_space: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE,
            ignore_trailing_white_space,
        );
    }
    #[inline]
    pub fn add_null_value(&mut self, null_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NULL_VALUE, null_value);
    }
    #[inline]
    pub fn add_empty_value(&mut self, empty_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_EMPTY_VALUE,
            empty_value,
        );
    }
    #[inline]
    pub fn add_nan_value(&mut self, nan_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NAN_VALUE, nan_value);
    }
    #[inline]
    pub fn add_positive_inf(&mut self, positive_inf: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_POSITIVE_INF,
            positive_inf,
        );
    }
    #[inline]
    pub fn add_negative_inf(&mut self, negative_inf: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_NEGATIVE_INF,
            negative_inf,
        );
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn add_multi_line(&mut self, multi_line: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_MULTI_LINE, multi_line);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepCsvBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepCsvBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepCsv<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ReadStepCsv<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ReadStepCsv");
        ds.field("schema", &self.schema());
        ds.field("separator", &self.separator());
        ds.field("encoding", &self.encoding());
        ds.field("quote", &self.quote());
        ds.field("escape", &self.escape());
        ds.field("comment", &self.comment());
        ds.field("header", &self.header());
        ds.field("enforce_schema", &self.enforce_schema());
        ds.field("infer_schema", &self.infer_schema());
        ds.field(
            "ignore_leading_white_space",
            &self.ignore_leading_white_space(),
        );
        ds.field(
            "ignore_trailing_white_space",
            &self.ignore_trailing_white_space(),
        );
        ds.field("null_value", &self.null_value());
        ds.field("empty_value", &self.empty_value());
        ds.field("nan_value", &self.nan_value());
        ds.field("positive_inf", &self.positive_inf());
        ds.field("negative_inf", &self.negative_inf());
        ds.field("date_format", &self.date_format());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.field("multi_line", &self.multi_line());
        ds.finish()
    }
}
pub enum ReadStepJsonLinesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepJsonLines<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepJsonLines<'a> {
    type Inner = ReadStepJsonLines<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepJsonLines<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 10;
    pub const VT_PRIMITIVES_AS_STRING: flatbuffers::VOffsetT = 12;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepJsonLines { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepJsonLinesArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepJsonLines<'bldr>> {
        let mut builder = ReadStepJsonLinesBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.primitives_as_string {
            builder.add_primitives_as_string(x);
        }
        if let Some(x) = args.multi_line {
            builder.add_multi_line(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepJsonLines::VT_SCHEMA, None)
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_DATE_FORMAT, None)
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_ENCODING, None)
    }
    #[inline]
    pub fn multi_line(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepJsonLines::VT_MULTI_LINE, None)
    }
    #[inline]
    pub fn primitives_as_string(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepJsonLines::VT_PRIMITIVES_AS_STRING, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_TIMESTAMP_FORMAT, None)
    }
}

impl flatbuffers::Verifiable for ReadStepJsonLines<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<bool>("multi_line", Self::VT_MULTI_LINE, false)?
            .visit_field::<bool>("primitives_as_string", Self::VT_PRIMITIVES_AS_STRING, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepJsonLinesArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multi_line: Option<bool>,
    pub primitives_as_string: Option<bool>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepJsonLinesArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepJsonLinesArgs {
            schema: None,
            date_format: None,
            encoding: None,
            multi_line: None,
            primitives_as_string: None,
            timestamp_format: None,
        }
    }
}
pub struct ReadStepJsonLinesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepJsonLinesBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_ENCODING,
            encoding,
        );
    }
    #[inline]
    pub fn add_multi_line(&mut self, multi_line: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepJsonLines::VT_MULTI_LINE, multi_line);
    }
    #[inline]
    pub fn add_primitives_as_string(&mut self, primitives_as_string: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepJsonLines::VT_PRIMITIVES_AS_STRING,
            primitives_as_string,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ReadStepJsonLinesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepJsonLinesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepJsonLines<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ReadStepJsonLines<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ReadStepJsonLines");
        ds.field("schema", &self.schema());
        ds.field("date_format", &self.date_format());
        ds.field("encoding", &self.encoding());
        ds.field("multi_line", &self.multi_line());
        ds.field("primitives_as_string", &self.primitives_as_string());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum ReadStepGeoJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepGeoJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepGeoJson<'a> {
    type Inner = ReadStepGeoJson<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepGeoJson<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepGeoJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepGeoJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepGeoJson<'bldr>> {
        let mut builder = ReadStepGeoJsonBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepGeoJson::VT_SCHEMA, None)
    }
}

impl flatbuffers::Verifiable for ReadStepGeoJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepGeoJsonArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepGeoJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepGeoJsonArgs { schema: None }
    }
}
pub struct ReadStepGeoJsonBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepGeoJsonBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepGeoJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepGeoJsonBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepGeoJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepGeoJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ReadStepGeoJson<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ReadStepGeoJson");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum ReadStepEsriShapefileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepEsriShapefile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepEsriShapefile<'a> {
    type Inner = ReadStepEsriShapefile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepEsriShapefile<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepEsriShapefile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepEsriShapefileArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'bldr>> {
        let mut builder = ReadStepEsriShapefileBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepEsriShapefile::VT_SCHEMA, None)
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepEsriShapefile::VT_SUB_PATH, None)
    }
}

impl flatbuffers::Verifiable for ReadStepEsriShapefile<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepEsriShapefileArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepEsriShapefileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepEsriShapefileArgs {
            schema: None,
            sub_path: None,
        }
    }
}
pub struct ReadStepEsriShapefileBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepEsriShapefileBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SCHEMA,
            schema,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ReadStepEsriShapefileBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepEsriShapefileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ReadStepEsriShapefile<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ReadStepEsriShapefile");
        ds.field("schema", &self.schema());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum SqlQueryStepOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SqlQueryStep<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqlQueryStep<'a> {
    type Inner = SqlQueryStep<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SqlQueryStep<'a> {
    pub const VT_ALIAS: flatbuffers::VOffsetT = 4;
    pub const VT_QUERY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SqlQueryStep { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SqlQueryStepArgs<'args>,
    ) -> flatbuffers::WIPOffset<SqlQueryStep<'bldr>> {
        let mut builder = SqlQueryStepBuilder::new(_fbb);
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_ALIAS, None)
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_QUERY, None)
    }
}

impl flatbuffers::Verifiable for SqlQueryStep<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .finish();
        Ok(())
    }
}
pub struct SqlQueryStepArgs<'a> {
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SqlQueryStepArgs<'a> {
    #[inline]
    fn default() -> Self {
        SqlQueryStepArgs {
            alias: None,
            query: None,
        }
    }
}
pub struct SqlQueryStepBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqlQueryStepBuilder<'a, 'b> {
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_ALIAS, alias);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_QUERY, query);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqlQueryStepBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SqlQueryStepBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SqlQueryStep<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for SqlQueryStep<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("SqlQueryStep");
        ds.field("alias", &self.alias());
        ds.field("query", &self.query());
        ds.finish()
    }
}
pub enum TemporalTableOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TemporalTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporalTable<'a> {
    type Inner = TemporalTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TemporalTable<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TemporalTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TemporalTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<TemporalTable<'bldr>> {
        let mut builder = TemporalTableBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TemporalTable::VT_ID, None)
    }
    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(TemporalTable::VT_PRIMARY_KEY, None)
    }
}

impl flatbuffers::Verifiable for TemporalTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct TemporalTableArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for TemporalTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TemporalTableArgs {
            id: None,
            primary_key: None,
        }
    }
}
pub struct TemporalTableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TemporalTableBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TemporalTable::VT_ID, id);
    }
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TemporalTable::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TemporalTableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TemporalTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TemporalTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TemporalTable<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TemporalTable");
        ds.field("id", &self.id());
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum TransformSqlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TransformSql<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformSql<'a> {
    type Inner = TransformSql<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TransformSql<'a> {
    pub const VT_ENGINE: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_QUERY: flatbuffers::VOffsetT = 8;
    pub const VT_QUERIES: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPORAL_TABLES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformSql { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransformSqlArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformSql<'bldr>> {
        let mut builder = TransformSqlBuilder::new(_fbb);
        if let Some(x) = args.temporal_tables {
            builder.add_temporal_tables(x);
        }
        if let Some(x) = args.queries {
            builder.add_queries(x);
        }
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.version {
            builder.add_version(x);
        }
        if let Some(x) = args.engine {
            builder.add_engine(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn engine(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_ENGINE, None)
    }
    #[inline]
    pub fn version(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_VERSION, None)
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_QUERY, None)
    }
    #[inline]
    pub fn queries(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
        >>(TransformSql::VT_QUERIES, None)
    }
    #[inline]
    pub fn temporal_tables(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable>>,
        >>(TransformSql::VT_TEMPORAL_TABLES, None)
    }
}

impl flatbuffers::Verifiable for TransformSql<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("engine", Self::VT_ENGINE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
            >>("queries", Self::VT_QUERIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TemporalTable>>,
            >>("temporal_tables", Self::VT_TEMPORAL_TABLES, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformSqlArgs<'a> {
    pub engine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub queries: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>,
        >,
    >,
    pub temporal_tables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>,
        >,
    >,
}
impl<'a> Default for TransformSqlArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformSqlArgs {
            engine: None,
            version: None,
            query: None,
            queries: None,
            temporal_tables: None,
        }
    }
}
pub struct TransformSqlBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformSqlBuilder<'a, 'b> {
    #[inline]
    pub fn add_engine(&mut self, engine: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_ENGINE, engine);
    }
    #[inline]
    pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_VERSION, version);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERY, query);
    }
    #[inline]
    pub fn add_queries(
        &mut self,
        queries: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SqlQueryStep<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERIES, queries);
    }
    #[inline]
    pub fn add_temporal_tables(
        &mut self,
        temporal_tables: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TemporalTable<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformSql::VT_TEMPORAL_TABLES,
            temporal_tables,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformSqlBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransformSqlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformSql<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for TransformSql<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("TransformSql");
        ds.field("engine", &self.engine());
        ds.field("version", &self.version());
        ds.field("query", &self.query());
        ds.field("queries", &self.queries());
        ds.field("temporal_tables", &self.temporal_tables());
        ds.finish()
    }
}
pub enum MergeStrategyAppendOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategyAppend<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyAppend<'a> {
    type Inner = MergeStrategyAppend<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategyAppend<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyAppend { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MergeStrategyAppendArgs,
    ) -> flatbuffers::WIPOffset<MergeStrategyAppend<'bldr>> {
        let mut builder = MergeStrategyAppendBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for MergeStrategyAppend<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct MergeStrategyAppendArgs {}
impl<'a> Default for MergeStrategyAppendArgs {
    #[inline]
    fn default() -> Self {
        MergeStrategyAppendArgs {}
    }
}
pub struct MergeStrategyAppendBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyAppendBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategyAppendBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategyAppendBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyAppend<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for MergeStrategyAppend<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyAppend");
        ds.finish()
    }
}
pub enum MergeStrategyLedgerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MergeStrategyLedger<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyLedger<'a> {
    type Inner = MergeStrategyLedger<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategyLedger<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyLedger { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategyLedgerArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategyLedger<'bldr>> {
        let mut builder = MergeStrategyLedgerBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategyLedger::VT_PRIMARY_KEY, None)
    }
}

impl flatbuffers::Verifiable for MergeStrategyLedger<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategyLedgerArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for MergeStrategyLedgerArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategyLedgerArgs { primary_key: None }
    }
}
pub struct MergeStrategyLedgerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyLedgerBuilder<'a, 'b> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategyLedger::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategyLedgerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategyLedgerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyLedger<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for MergeStrategyLedger<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyLedger");
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum MergeStrategySnapshotOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MergeStrategySnapshot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategySnapshot<'a> {
    type Inner = MergeStrategySnapshot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategySnapshot<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_COMPARE_COLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_OBSERVATION_COLUMN: flatbuffers::VOffsetT = 8;
    pub const VT_OBSV_ADDED: flatbuffers::VOffsetT = 10;
    pub const VT_OBSV_CHANGED: flatbuffers::VOffsetT = 12;
    pub const VT_OBSV_REMOVED: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategySnapshot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategySnapshotArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'bldr>> {
        let mut builder = MergeStrategySnapshotBuilder::new(_fbb);
        if let Some(x) = args.obsv_removed {
            builder.add_obsv_removed(x);
        }
        if let Some(x) = args.obsv_changed {
            builder.add_obsv_changed(x);
        }
        if let Some(x) = args.obsv_added {
            builder.add_obsv_added(x);
        }
        if let Some(x) = args.observation_column {
            builder.add_observation_column(x);
        }
        if let Some(x) = args.compare_columns {
            builder.add_compare_columns(x);
        }
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategySnapshot::VT_PRIMARY_KEY, None)
    }
    #[inline]
    pub fn compare_columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategySnapshot::VT_COMPARE_COLUMNS, None)
    }
    #[inline]
    pub fn observation_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            MergeStrategySnapshot::VT_OBSERVATION_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn obsv_added(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_ADDED, None)
    }
    #[inline]
    pub fn obsv_changed(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_CHANGED, None)
    }
    #[inline]
    pub fn obsv_removed(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_REMOVED, None)
    }
}

impl flatbuffers::Verifiable for MergeStrategySnapshot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("compare_columns", Self::VT_COMPARE_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "observation_column",
                Self::VT_OBSERVATION_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_added",
                Self::VT_OBSV_ADDED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_changed",
                Self::VT_OBSV_CHANGED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_removed",
                Self::VT_OBSV_REMOVED,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategySnapshotArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub compare_columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub observation_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_added: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_changed: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_removed: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MergeStrategySnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategySnapshotArgs {
            primary_key: None,
            compare_columns: None,
            observation_column: None,
            obsv_added: None,
            obsv_changed: None,
            obsv_removed: None,
        }
    }
}
pub struct MergeStrategySnapshotBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategySnapshotBuilder<'a, 'b> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn add_compare_columns(
        &mut self,
        compare_columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_COMPARE_COLUMNS,
            compare_columns,
        );
    }
    #[inline]
    pub fn add_observation_column(&mut self, observation_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSERVATION_COLUMN,
            observation_column,
        );
    }
    #[inline]
    pub fn add_obsv_added(&mut self, obsv_added: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_ADDED,
            obsv_added,
        );
    }
    #[inline]
    pub fn add_obsv_changed(&mut self, obsv_changed: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_CHANGED,
            obsv_changed,
        );
    }
    #[inline]
    pub fn add_obsv_removed(&mut self, obsv_removed: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_REMOVED,
            obsv_removed,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategySnapshotBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategySnapshotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for MergeStrategySnapshot<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategySnapshot");
        ds.field("primary_key", &self.primary_key());
        ds.field("compare_columns", &self.compare_columns());
        ds.field("observation_column", &self.observation_column());
        ds.field("obsv_added", &self.obsv_added());
        ds.field("obsv_changed", &self.obsv_changed());
        ds.field("obsv_removed", &self.obsv_removed());
        ds.finish()
    }
}
pub enum PrepStepWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct PrepStepWrapper<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepWrapper<'a> {
    type Inner = PrepStepWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepWrapper<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepWrapperArgs,
    ) -> flatbuffers::WIPOffset<PrepStepWrapper<'bldr>> {
        let mut builder = PrepStepWrapperBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> PrepStep {
        self._tab
            .get::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, Some(PrepStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                PrepStepWrapper::VT_VALUE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_decompress(&self) -> Option<PrepStepDecompress<'a>> {
        if self.value_type() == PrepStep::PrepStepDecompress {
            self.value().map(PrepStepDecompress::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_pipe(&self) -> Option<PrepStepPipe<'a>> {
        if self.value_type() == PrepStep::PrepStepPipe {
            self.value().map(PrepStepPipe::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for PrepStepWrapper<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<PrepStep, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    PrepStep::PrepStepDecompress => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepDecompress>>(
                            "PrepStep::PrepStepDecompress",
                            pos,
                        ),
                    PrepStep::PrepStepPipe => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepPipe>>(
                            "PrepStep::PrepStepPipe",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepWrapperArgs {
    pub value_type: PrepStep,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PrepStepWrapperArgs {
    #[inline]
    fn default() -> Self {
        PrepStepWrapperArgs {
            value_type: PrepStep::NONE,
            value: None,
        }
    }
}
pub struct PrepStepWrapperBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepWrapperBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: PrepStep) {
        self.fbb_
            .push_slot::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, value_type, PrepStep::NONE);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepWrapper::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepWrapperBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepWrapperBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepWrapper<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for PrepStepWrapper<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("PrepStepWrapper");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            PrepStep::PrepStepDecompress => {
                if let Some(x) = self.value_as_prep_step_decompress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            PrepStep::PrepStepPipe => {
                if let Some(x) = self.value_as_prep_step_pipe() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum DatasetSourceRootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DatasetSourceRoot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSourceRoot<'a> {
    type Inner = DatasetSourceRoot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatasetSourceRoot<'a> {
    pub const VT_FETCH_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FETCH: flatbuffers::VOffsetT = 6;
    pub const VT_PREPARE: flatbuffers::VOffsetT = 8;
    pub const VT_READ_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_READ: flatbuffers::VOffsetT = 12;
    pub const VT_PREPROCESS_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_PREPROCESS: flatbuffers::VOffsetT = 16;
    pub const VT_MERGE_TYPE: flatbuffers::VOffsetT = 18;
    pub const VT_MERGE: flatbuffers::VOffsetT = 20;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSourceRoot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSourceRootArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetSourceRoot<'bldr>> {
        let mut builder = DatasetSourceRootBuilder::new(_fbb);
        if let Some(x) = args.merge {
            builder.add_merge(x);
        }
        if let Some(x) = args.preprocess {
            builder.add_preprocess(x);
        }
        if let Some(x) = args.read {
            builder.add_read(x);
        }
        if let Some(x) = args.prepare {
            builder.add_prepare(x);
        }
        if let Some(x) = args.fetch {
            builder.add_fetch(x);
        }
        builder.add_merge_type(args.merge_type);
        builder.add_preprocess_type(args.preprocess_type);
        builder.add_read_type(args.read_type);
        builder.add_fetch_type(args.fetch_type);
        builder.finish()
    }

    #[inline]
    pub fn fetch_type(&self) -> FetchStep {
        self._tab
            .get::<FetchStep>(DatasetSourceRoot::VT_FETCH_TYPE, Some(FetchStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn fetch(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSourceRoot::VT_FETCH,
                None,
            )
    }
    #[inline]
    pub fn prepare(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper>>,
        >>(DatasetSourceRoot::VT_PREPARE, None)
    }
    #[inline]
    pub fn read_type(&self) -> ReadStep {
        self._tab
            .get::<ReadStep>(DatasetSourceRoot::VT_READ_TYPE, Some(ReadStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn read(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSourceRoot::VT_READ,
                None,
            )
    }
    #[inline]
    pub fn preprocess_type(&self) -> Transform {
        self._tab
            .get::<Transform>(DatasetSourceRoot::VT_PREPROCESS_TYPE, Some(Transform::NONE))
            .unwrap()
    }
    #[inline]
    pub fn preprocess(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSourceRoot::VT_PREPROCESS,
                None,
            )
    }
    #[inline]
    pub fn merge_type(&self) -> MergeStrategy {
        self._tab
            .get::<MergeStrategy>(DatasetSourceRoot::VT_MERGE_TYPE, Some(MergeStrategy::NONE))
            .unwrap()
    }
    #[inline]
    pub fn merge(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSourceRoot::VT_MERGE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_url(&self) -> Option<FetchStepUrl<'a>> {
        if self.fetch_type() == FetchStep::FetchStepUrl {
            self.fetch().map(FetchStepUrl::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_files_glob(&self) -> Option<FetchStepFilesGlob<'a>> {
        if self.fetch_type() == FetchStep::FetchStepFilesGlob {
            self.fetch().map(FetchStepFilesGlob::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_csv(&self) -> Option<ReadStepCsv<'a>> {
        if self.read_type() == ReadStep::ReadStepCsv {
            self.read().map(ReadStepCsv::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_json_lines(&self) -> Option<ReadStepJsonLines<'a>> {
        if self.read_type() == ReadStep::ReadStepJsonLines {
            self.read().map(ReadStepJsonLines::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_geo_json(&self) -> Option<ReadStepGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepGeoJson {
            self.read().map(ReadStepGeoJson::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_esri_shapefile(&self) -> Option<ReadStepEsriShapefile<'a>> {
        if self.read_type() == ReadStep::ReadStepEsriShapefile {
            self.read().map(ReadStepEsriShapefile::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn preprocess_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.preprocess_type() == Transform::TransformSql {
            self.preprocess().map(TransformSql::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_append(&self) -> Option<MergeStrategyAppend<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyAppend {
            self.merge().map(MergeStrategyAppend::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_ledger(&self) -> Option<MergeStrategyLedger<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyLedger {
            self.merge().map(MergeStrategyLedger::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_snapshot(&self) -> Option<MergeStrategySnapshot<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategySnapshot {
            self.merge().map(MergeStrategySnapshot::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for DatasetSourceRoot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<FetchStep, _>("fetch_type", Self::VT_FETCH_TYPE, "fetch", Self::VT_FETCH, false, |key, v, pos| {
        match key {
          FetchStep::FetchStepUrl => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepUrl>>("FetchStep::FetchStepUrl", pos),
          FetchStep::FetchStepFilesGlob => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepFilesGlob>>("FetchStep::FetchStepFilesGlob", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PrepStepWrapper>>>>("prepare", Self::VT_PREPARE, false)?
     .visit_union::<ReadStep, _>("read_type", Self::VT_READ_TYPE, "read", Self::VT_READ, false, |key, v, pos| {
        match key {
          ReadStep::ReadStepCsv => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepCsv>>("ReadStep::ReadStepCsv", pos),
          ReadStep::ReadStepJsonLines => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepJsonLines>>("ReadStep::ReadStepJsonLines", pos),
          ReadStep::ReadStepGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepGeoJson>>("ReadStep::ReadStepGeoJson", pos),
          ReadStep::ReadStepEsriShapefile => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepEsriShapefile>>("ReadStep::ReadStepEsriShapefile", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Transform, _>("preprocess_type", Self::VT_PREPROCESS_TYPE, "preprocess", Self::VT_PREPROCESS, false, |key, v, pos| {
        match key {
          Transform::TransformSql => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>("Transform::TransformSql", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MergeStrategy, _>("merge_type", Self::VT_MERGE_TYPE, "merge", Self::VT_MERGE, false, |key, v, pos| {
        match key {
          MergeStrategy::MergeStrategyAppend => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyAppend>>("MergeStrategy::MergeStrategyAppend", pos),
          MergeStrategy::MergeStrategyLedger => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyLedger>>("MergeStrategy::MergeStrategyLedger", pos),
          MergeStrategy::MergeStrategySnapshot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategySnapshot>>("MergeStrategy::MergeStrategySnapshot", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct DatasetSourceRootArgs<'a> {
    pub fetch_type: FetchStep,
    pub fetch: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub prepare: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>,
        >,
    >,
    pub read_type: ReadStep,
    pub read: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub preprocess_type: Transform,
    pub preprocess: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub merge_type: MergeStrategy,
    pub merge: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DatasetSourceRootArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSourceRootArgs {
            fetch_type: FetchStep::NONE,
            fetch: None,
            prepare: None,
            read_type: ReadStep::NONE,
            read: None,
            preprocess_type: Transform::NONE,
            preprocess: None,
            merge_type: MergeStrategy::NONE,
            merge: None,
        }
    }
}
pub struct DatasetSourceRootBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSourceRootBuilder<'a, 'b> {
    #[inline]
    pub fn add_fetch_type(&mut self, fetch_type: FetchStep) {
        self.fbb_.push_slot::<FetchStep>(
            DatasetSourceRoot::VT_FETCH_TYPE,
            fetch_type,
            FetchStep::NONE,
        );
    }
    #[inline]
    pub fn add_fetch(&mut self, fetch: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_FETCH, fetch);
    }
    #[inline]
    pub fn add_prepare(
        &mut self,
        prepare: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PrepStepWrapper<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_PREPARE, prepare);
    }
    #[inline]
    pub fn add_read_type(&mut self, read_type: ReadStep) {
        self.fbb_
            .push_slot::<ReadStep>(DatasetSourceRoot::VT_READ_TYPE, read_type, ReadStep::NONE);
    }
    #[inline]
    pub fn add_read(&mut self, read: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_READ, read);
    }
    #[inline]
    pub fn add_preprocess_type(&mut self, preprocess_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            DatasetSourceRoot::VT_PREPROCESS_TYPE,
            preprocess_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_preprocess(
        &mut self,
        preprocess: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetSourceRoot::VT_PREPROCESS,
            preprocess,
        );
    }
    #[inline]
    pub fn add_merge_type(&mut self, merge_type: MergeStrategy) {
        self.fbb_.push_slot::<MergeStrategy>(
            DatasetSourceRoot::VT_MERGE_TYPE,
            merge_type,
            MergeStrategy::NONE,
        );
    }
    #[inline]
    pub fn add_merge(&mut self, merge: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSourceRoot::VT_MERGE, merge);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DatasetSourceRootBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatasetSourceRootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSourceRoot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for DatasetSourceRoot<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("DatasetSourceRoot");
        ds.field("fetch_type", &self.fetch_type());
        match self.fetch_type() {
            FetchStep::FetchStepUrl => {
                if let Some(x) = self.fetch_as_fetch_step_url() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepFilesGlob => {
                if let Some(x) = self.fetch_as_fetch_step_files_glob() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("fetch", &x)
            }
        };
        ds.field("prepare", &self.prepare());
        ds.field("read_type", &self.read_type());
        match self.read_type() {
            ReadStep::ReadStepCsv => {
                if let Some(x) = self.read_as_read_step_csv() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepJsonLines => {
                if let Some(x) = self.read_as_read_step_json_lines() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepGeoJson => {
                if let Some(x) = self.read_as_read_step_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepEsriShapefile => {
                if let Some(x) = self.read_as_read_step_esri_shapefile() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("read", &x)
            }
        };
        ds.field("preprocess_type", &self.preprocess_type());
        match self.preprocess_type() {
            Transform::TransformSql => {
                if let Some(x) = self.preprocess_as_transform_sql() {
                    ds.field("preprocess", &x)
                } else {
                    ds.field(
                        "preprocess",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("preprocess", &x)
            }
        };
        ds.field("merge_type", &self.merge_type());
        match self.merge_type() {
            MergeStrategy::MergeStrategyAppend => {
                if let Some(x) = self.merge_as_merge_strategy_append() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategyLedger => {
                if let Some(x) = self.merge_as_merge_strategy_ledger() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategySnapshot => {
                if let Some(x) = self.merge_as_merge_strategy_snapshot() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("merge", &x)
            }
        };
        ds.finish()
    }
}
pub enum DatasetSourceDerivativeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DatasetSourceDerivative<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSourceDerivative<'a> {
    type Inner = DatasetSourceDerivative<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatasetSourceDerivative<'a> {
    pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSourceDerivative { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSourceDerivativeArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetSourceDerivative<'bldr>> {
        let mut builder = DatasetSourceDerivativeBuilder::new(_fbb);
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(DatasetSourceDerivative::VT_INPUTS, None)
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        self._tab
            .get::<Transform>(
                DatasetSourceDerivative::VT_TRANSFORM_TYPE,
                Some(Transform::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSourceDerivative::VT_TRANSFORM,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(TransformSql::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for DatasetSourceDerivative<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("inputs", Self::VT_INPUTS, false)?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct DatasetSourceDerivativeArgs<'a> {
    pub inputs: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DatasetSourceDerivativeArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSourceDerivativeArgs {
            inputs: None,
            transform_type: Transform::NONE,
            transform: None,
        }
    }
}
pub struct DatasetSourceDerivativeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSourceDerivativeBuilder<'a, 'b> {
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetSourceDerivative::VT_INPUTS,
            inputs,
        );
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            DatasetSourceDerivative::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetSourceDerivative::VT_TRANSFORM,
            transform,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DatasetSourceDerivativeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatasetSourceDerivativeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSourceDerivative<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for DatasetSourceDerivative<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("DatasetSourceDerivative");
        ds.field("inputs", &self.inputs());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.finish()
    }
}
pub enum DatasetVocabularyOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DatasetVocabulary<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetVocabulary<'a> {
    type Inner = DatasetVocabulary<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatasetVocabulary<'a> {
    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET_COLUMN: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetVocabulary { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetVocabularyArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetVocabulary<'bldr>> {
        let mut builder = DatasetVocabularyBuilder::new(_fbb);
        if let Some(x) = args.offset_column {
            builder.add_offset_column(x);
        }
        if let Some(x) = args.event_time_column {
            builder.add_event_time_column(x);
        }
        if let Some(x) = args.system_time_column {
            builder.add_system_time_column(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn event_time_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            DatasetVocabulary::VT_EVENT_TIME_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn offset_column(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DatasetVocabulary::VT_OFFSET_COLUMN, None)
    }
}

impl flatbuffers::Verifiable for DatasetVocabulary<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "system_time_column",
                Self::VT_SYSTEM_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "event_time_column",
                Self::VT_EVENT_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "offset_column",
                Self::VT_OFFSET_COLUMN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DatasetVocabularyArgs<'a> {
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offset_column: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DatasetVocabularyArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetVocabularyArgs {
            system_time_column: None,
            event_time_column: None,
            offset_column: None,
        }
    }
}
pub struct DatasetVocabularyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetVocabularyBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
            system_time_column,
        );
    }
    #[inline]
    pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_EVENT_TIME_COLUMN,
            event_time_column,
        );
    }
    #[inline]
    pub fn add_offset_column(&mut self, offset_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_OFFSET_COLUMN,
            offset_column,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DatasetVocabularyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatasetVocabularyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetVocabulary<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for DatasetVocabulary<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("DatasetVocabulary");
        ds.field("system_time_column", &self.system_time_column());
        ds.field("event_time_column", &self.event_time_column());
        ds.field("offset_column", &self.offset_column());
        ds.finish()
    }
}
pub enum DatasetSnapshotOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DatasetSnapshot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetSnapshot<'a> {
    type Inner = DatasetSnapshot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatasetSnapshot<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetSnapshot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetSnapshotArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetSnapshot<'bldr>> {
        let mut builder = DatasetSnapshotBuilder::new(_fbb);
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.source {
            builder.add_source(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.add_source_type(args.source_type);
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DatasetSnapshot::VT_ID, None)
    }
    #[inline]
    pub fn source_type(&self) -> DatasetSource {
        self._tab
            .get::<DatasetSource>(DatasetSnapshot::VT_SOURCE_TYPE, Some(DatasetSource::NONE))
            .unwrap()
    }
    #[inline]
    pub fn source(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                DatasetSnapshot::VT_SOURCE,
                None,
            )
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(DatasetSnapshot::VT_VOCAB, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn source_as_dataset_source_root(&self) -> Option<DatasetSourceRoot<'a>> {
        if self.source_type() == DatasetSource::DatasetSourceRoot {
            self.source().map(DatasetSourceRoot::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn source_as_dataset_source_derivative(&self) -> Option<DatasetSourceDerivative<'a>> {
        if self.source_type() == DatasetSource::DatasetSourceDerivative {
            self.source().map(DatasetSourceDerivative::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for DatasetSnapshot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_union::<DatasetSource, _>("source_type", Self::VT_SOURCE_TYPE, "source", Self::VT_SOURCE, false, |key, v, pos| {
        match key {
          DatasetSource::DatasetSourceRoot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DatasetSourceRoot>>("DatasetSource::DatasetSourceRoot", pos),
          DatasetSource::DatasetSourceDerivative => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DatasetSourceDerivative>>("DatasetSource::DatasetSourceDerivative", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>("vocab", Self::VT_VOCAB, false)?
     .finish();
        Ok(())
    }
}
pub struct DatasetSnapshotArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source_type: DatasetSource,
    pub source: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
}
impl<'a> Default for DatasetSnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetSnapshotArgs {
            id: None,
            source_type: DatasetSource::NONE,
            source: None,
            vocab: None,
        }
    }
}
pub struct DatasetSnapshotBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetSnapshotBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_ID, id);
    }
    #[inline]
    pub fn add_source_type(&mut self, source_type: DatasetSource) {
        self.fbb_.push_slot::<DatasetSource>(
            DatasetSnapshot::VT_SOURCE_TYPE,
            source_type,
            DatasetSource::NONE,
        );
    }
    #[inline]
    pub fn add_source(&mut self, source: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DatasetSnapshot::VT_SOURCE, source);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                DatasetSnapshot::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DatasetSnapshotBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatasetSnapshotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetSnapshot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for DatasetSnapshot<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("DatasetSnapshot");
        ds.field("id", &self.id());
        ds.field("source_type", &self.source_type());
        match self.source_type() {
            DatasetSource::DatasetSourceRoot => {
                if let Some(x) = self.source_as_dataset_source_root() {
                    ds.field("source", &x)
                } else {
                    ds.field(
                        "source",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            DatasetSource::DatasetSourceDerivative => {
                if let Some(x) = self.source_as_dataset_source_derivative() {
                    ds.field("source", &x)
                } else {
                    ds.field(
                        "source",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("source", &x)
            }
        };
        ds.field("vocab", &self.vocab());
        ds.finish()
    }
}
pub enum OffsetIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct OffsetInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OffsetInterval<'a> {
    type Inner = OffsetInterval<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> OffsetInterval<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OffsetInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OffsetIntervalArgs,
    ) -> flatbuffers::WIPOffset<OffsetInterval<'bldr>> {
        let mut builder = OffsetIntervalBuilder::new(_fbb);
        builder.add_end(args.end);
        builder.add_start(args.start);
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> i64 {
        self._tab
            .get::<i64>(OffsetInterval::VT_START, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn end(&self) -> i64 {
        self._tab
            .get::<i64>(OffsetInterval::VT_END, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for OffsetInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("start", Self::VT_START, false)?
            .visit_field::<i64>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct OffsetIntervalArgs {
    pub start: i64,
    pub end: i64,
}
impl<'a> Default for OffsetIntervalArgs {
    #[inline]
    fn default() -> Self {
        OffsetIntervalArgs { start: 0, end: 0 }
    }
}
pub struct OffsetIntervalBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OffsetIntervalBuilder<'a, 'b> {
    #[inline]
    pub fn add_start(&mut self, start: i64) {
        self.fbb_
            .push_slot::<i64>(OffsetInterval::VT_START, start, 0);
    }
    #[inline]
    pub fn add_end(&mut self, end: i64) {
        self.fbb_.push_slot::<i64>(OffsetInterval::VT_END, end, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OffsetIntervalBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OffsetIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OffsetInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for OffsetInterval<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("OffsetInterval");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum WatermarkOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct Watermark<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Watermark<'a> {
    type Inner = Watermark<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Watermark<'a> {
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Watermark { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WatermarkArgs<'args>,
    ) -> flatbuffers::WIPOffset<Watermark<'bldr>> {
        let mut builder = WatermarkBuilder::new(_fbb);
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab.get::<Timestamp>(Watermark::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn event_time(&self) -> Option<&'a Timestamp> {
        self._tab.get::<Timestamp>(Watermark::VT_EVENT_TIME, None)
    }
}

impl flatbuffers::Verifiable for Watermark<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<Timestamp>("event_time", Self::VT_EVENT_TIME, false)?
            .finish();
        Ok(())
    }
}
pub struct WatermarkArgs<'a> {
    pub system_time: Option<&'a Timestamp>,
    pub event_time: Option<&'a Timestamp>,
}
impl<'a> Default for WatermarkArgs<'a> {
    #[inline]
    fn default() -> Self {
        WatermarkArgs {
            system_time: None,
            event_time: None,
        }
    }
}
pub struct WatermarkBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WatermarkBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_event_time(&mut self, event_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WatermarkBuilder<'a, 'b> {
        let start = _fbb.start_table();
        WatermarkBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Watermark<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for Watermark<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("Watermark");
        ds.field("system_time", &self.system_time());
        ds.field("event_time", &self.event_time());
        ds.finish()
    }
}
pub enum QueryInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct QueryInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryInput<'a> {
    type Inner = QueryInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> QueryInput<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 6;
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 8;
    pub const VT_DATA_PATHS: flatbuffers::VOffsetT = 10;
    pub const VT_SCHEMA_FILE: flatbuffers::VOffsetT = 12;
    pub const VT_EXPLICIT_WATERMARKS: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        QueryInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args QueryInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<QueryInput<'bldr>> {
        let mut builder = QueryInputBuilder::new(_fbb);
        if let Some(x) = args.explicit_watermarks {
            builder.add_explicit_watermarks(x);
        }
        if let Some(x) = args.schema_file {
            builder.add_schema_file(x);
        }
        if let Some(x) = args.data_paths {
            builder.add_data_paths(x);
        }
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(QueryInput::VT_DATASET_ID, None)
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(QueryInput::VT_VOCAB, None)
    }
    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(QueryInput::VT_DATA_INTERVAL, None)
    }
    #[inline]
    pub fn data_paths(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(QueryInput::VT_DATA_PATHS, None)
    }
    #[inline]
    pub fn schema_file(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(QueryInput::VT_SCHEMA_FILE, None)
    }
    #[inline]
    pub fn explicit_watermarks(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark>>,
        >>(QueryInput::VT_EXPLICIT_WATERMARKS, None)
    }
}

impl flatbuffers::Verifiable for QueryInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("data_paths", Self::VT_DATA_PATHS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "schema_file",
                Self::VT_SCHEMA_FILE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Watermark>>,
            >>("explicit_watermarks", Self::VT_EXPLICIT_WATERMARKS, false)?
            .finish();
        Ok(())
    }
}
pub struct QueryInputArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub data_paths: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub schema_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub explicit_watermarks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>,
        >,
    >,
}
impl<'a> Default for QueryInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        QueryInputArgs {
            dataset_id: None,
            vocab: None,
            data_interval: None,
            data_paths: None,
            schema_file: None,
            explicit_watermarks: None,
        }
    }
}
pub struct QueryInputBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryInputBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(&mut self, dataset_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(QueryInput::VT_DATASET_ID, dataset_id);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                QueryInput::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                QueryInput::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn add_data_paths(
        &mut self,
        data_paths: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(QueryInput::VT_DATA_PATHS, data_paths);
    }
    #[inline]
    pub fn add_schema_file(&mut self, schema_file: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(QueryInput::VT_SCHEMA_FILE, schema_file);
    }
    #[inline]
    pub fn add_explicit_watermarks(
        &mut self,
        explicit_watermarks: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Watermark<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            QueryInput::VT_EXPLICIT_WATERMARKS,
            explicit_watermarks,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryInputBuilder<'a, 'b> {
        let start = _fbb.start_table();
        QueryInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<QueryInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for QueryInput<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("QueryInput");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("vocab", &self.vocab());
        ds.field("data_interval", &self.data_interval());
        ds.field("data_paths", &self.data_paths());
        ds.field("schema_file", &self.schema_file());
        ds.field("explicit_watermarks", &self.explicit_watermarks());
        ds.finish()
    }
}
pub enum ExecuteQueryRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQueryRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryRequest<'a> {
    type Inner = ExecuteQueryRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryRequest<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 10;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 12;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 14;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 16;
    pub const VT_PREV_CHECKPOINT_DIR: flatbuffers::VOffsetT = 18;
    pub const VT_NEW_CHECKPOINT_DIR: flatbuffers::VOffsetT = 20;
    pub const VT_OUT_DATA_PATH: flatbuffers::VOffsetT = 22;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryRequest<'bldr>> {
        let mut builder = ExecuteQueryRequestBuilder::new(_fbb);
        builder.add_offset(args.offset);
        if let Some(x) = args.out_data_path {
            builder.add_out_data_path(x);
        }
        if let Some(x) = args.new_checkpoint_dir {
            builder.add_new_checkpoint_dir(x);
        }
        if let Some(x) = args.prev_checkpoint_dir {
            builder.add_prev_checkpoint_dir(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryRequest::VT_DATASET_ID, None)
    }
    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(ExecuteQueryRequest::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn offset(&self) -> i64 {
        self._tab
            .get::<i64>(ExecuteQueryRequest::VT_OFFSET, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                ExecuteQueryRequest::VT_VOCAB,
                None,
            )
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        self._tab
            .get::<Transform>(
                ExecuteQueryRequest::VT_TRANSFORM_TYPE,
                Some(Transform::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ExecuteQueryRequest::VT_TRANSFORM,
                None,
            )
    }
    #[inline]
    pub fn inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QueryInput<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QueryInput>>,
        >>(ExecuteQueryRequest::VT_INPUTS, None)
    }
    #[inline]
    pub fn prev_checkpoint_dir(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryRequest::VT_PREV_CHECKPOINT_DIR,
            None,
        )
    }
    #[inline]
    pub fn new_checkpoint_dir(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryRequest::VT_NEW_CHECKPOINT_DIR,
            None,
        )
    }
    #[inline]
    pub fn out_data_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryRequest::VT_OUT_DATA_PATH, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(TransformSql::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ExecuteQueryRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<i64>("offset", Self::VT_OFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<QueryInput>>,
            >>("inputs", Self::VT_INPUTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prev_checkpoint_dir",
                Self::VT_PREV_CHECKPOINT_DIR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "new_checkpoint_dir",
                Self::VT_NEW_CHECKPOINT_DIR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "out_data_path",
                Self::VT_OUT_DATA_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryRequestArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system_time: Option<&'a Timestamp>,
    pub offset: i64,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<QueryInput<'a>>>,
        >,
    >,
    pub prev_checkpoint_dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub new_checkpoint_dir: Option<flatbuffers::WIPOffset<&'a str>>,
    pub out_data_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryRequestArgs {
            dataset_id: None,
            system_time: None,
            offset: 0,
            vocab: None,
            transform_type: Transform::NONE,
            transform: None,
            inputs: None,
            prev_checkpoint_dir: None,
            new_checkpoint_dir: None,
            out_data_path: None,
        }
    }
}
pub struct ExecuteQueryRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(&mut self, dataset_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(ExecuteQueryRequest::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_offset(&mut self, offset: i64) {
        self.fbb_
            .push_slot::<i64>(ExecuteQueryRequest::VT_OFFSET, offset, 0);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                ExecuteQueryRequest::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            ExecuteQueryRequest::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_TRANSFORM,
            transform,
        );
    }
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<QueryInput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ExecuteQueryRequest::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_prev_checkpoint_dir(
        &mut self,
        prev_checkpoint_dir: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_PREV_CHECKPOINT_DIR,
            prev_checkpoint_dir,
        );
    }
    #[inline]
    pub fn add_new_checkpoint_dir(&mut self, new_checkpoint_dir: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_NEW_CHECKPOINT_DIR,
            new_checkpoint_dir,
        );
    }
    #[inline]
    pub fn add_out_data_path(&mut self, out_data_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_OUT_DATA_PATH,
            out_data_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryRequest");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("system_time", &self.system_time());
        ds.field("offset", &self.offset());
        ds.field("vocab", &self.vocab());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.field("prev_checkpoint_dir", &self.prev_checkpoint_dir());
        ds.field("new_checkpoint_dir", &self.new_checkpoint_dir());
        ds.field("out_data_path", &self.out_data_path());
        ds.finish()
    }
}
pub enum OutputSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct OutputSlice<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OutputSlice<'a> {
    type Inner = OutputSlice<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> OutputSlice<'a> {
    pub const VT_DATA_LOGICAL_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OutputSlice { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OutputSliceArgs<'args>,
    ) -> flatbuffers::WIPOffset<OutputSlice<'bldr>> {
        let mut builder = OutputSliceBuilder::new(_fbb);
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        if let Some(x) = args.data_logical_hash {
            builder.add_data_logical_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data_logical_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                OutputSlice::VT_DATA_LOGICAL_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                OutputSlice::VT_DATA_INTERVAL,
                None,
            )
    }
}

impl flatbuffers::Verifiable for OutputSlice<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "data_logical_hash",
                Self::VT_DATA_LOGICAL_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct OutputSliceArgs<'a> {
    pub data_logical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
}
impl<'a> Default for OutputSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        OutputSliceArgs {
            data_logical_hash: None,
            data_interval: None,
        }
    }
}
pub struct OutputSliceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OutputSliceBuilder<'a, 'b> {
    #[inline]
    pub fn add_data_logical_hash(
        &mut self,
        data_logical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            OutputSlice::VT_DATA_LOGICAL_HASH,
            data_logical_hash,
        );
    }
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                OutputSlice::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OutputSliceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OutputSliceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OutputSlice<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for OutputSlice<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("OutputSlice");
        ds.field("data_logical_hash", &self.data_logical_hash());
        ds.field("data_interval", &self.data_interval());
        ds.finish()
    }
}
pub enum InputSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct InputSlice<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InputSlice<'a> {
    type Inner = InputSlice<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> InputSlice<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_INTERVAL: flatbuffers::VOffsetT = 6;
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InputSlice { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InputSliceArgs<'args>,
    ) -> flatbuffers::WIPOffset<InputSlice<'bldr>> {
        let mut builder = InputSliceBuilder::new(_fbb);
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        if let Some(x) = args.block_interval {
            builder.add_block_interval(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(InputSlice::VT_DATASET_ID, None)
    }
    #[inline]
    pub fn block_interval(&self) -> Option<BlockInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<BlockInterval>>(InputSlice::VT_BLOCK_INTERVAL, None)
    }
    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(InputSlice::VT_DATA_INTERVAL, None)
    }
}

impl flatbuffers::Verifiable for InputSlice<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<BlockInterval>>(
                "block_interval",
                Self::VT_BLOCK_INTERVAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct InputSliceArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub block_interval: Option<flatbuffers::WIPOffset<BlockInterval<'a>>>,
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
}
impl<'a> Default for InputSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        InputSliceArgs {
            dataset_id: None,
            block_interval: None,
            data_interval: None,
        }
    }
}
pub struct InputSliceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InputSliceBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(&mut self, dataset_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InputSlice::VT_DATASET_ID, dataset_id);
    }
    #[inline]
    pub fn add_block_interval(
        &mut self,
        block_interval: flatbuffers::WIPOffset<BlockInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<BlockInterval>>(
                InputSlice::VT_BLOCK_INTERVAL,
                block_interval,
            );
    }
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                InputSlice::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InputSliceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InputSliceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InputSlice<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for InputSlice<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("InputSlice");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("block_interval", &self.block_interval());
        ds.field("data_interval", &self.data_interval());
        ds.finish()
    }
}
pub enum MetadataBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MetadataBlock<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataBlock<'a> {
    type Inner = MetadataBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MetadataBlock<'a> {
    pub const VT_BLOCK_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUT_SLICE: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 12;
    pub const VT_INPUT_SLICES: flatbuffers::VOffsetT = 14;
    pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 16;
    pub const VT_SOURCE: flatbuffers::VOffsetT = 18;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 20;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataBlock { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataBlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<MetadataBlock<'bldr>> {
        let mut builder = MetadataBlockBuilder::new(_fbb);
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.source {
            builder.add_source(x);
        }
        if let Some(x) = args.input_slices {
            builder.add_input_slices(x);
        }
        if let Some(x) = args.output_watermark {
            builder.add_output_watermark(x);
        }
        if let Some(x) = args.output_slice {
            builder.add_output_slice(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        if let Some(x) = args.prev_block_hash {
            builder.add_prev_block_hash(x);
        }
        if let Some(x) = args.block_hash {
            builder.add_block_hash(x);
        }
        builder.add_source_type(args.source_type);
        builder.finish()
    }

    #[inline]
    pub fn block_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                MetadataBlock::VT_BLOCK_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn prev_block_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                MetadataBlock::VT_PREV_BLOCK_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(MetadataBlock::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn output_slice(&self) -> Option<OutputSlice<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OutputSlice>>(MetadataBlock::VT_OUTPUT_SLICE, None)
    }
    #[inline]
    pub fn output_watermark(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(MetadataBlock::VT_OUTPUT_WATERMARK, None)
    }
    #[inline]
    pub fn input_slices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice>>,
        >>(MetadataBlock::VT_INPUT_SLICES, None)
    }
    #[inline]
    pub fn source_type(&self) -> DatasetSource {
        self._tab
            .get::<DatasetSource>(MetadataBlock::VT_SOURCE_TYPE, Some(DatasetSource::NONE))
            .unwrap()
    }
    #[inline]
    pub fn source(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                MetadataBlock::VT_SOURCE,
                None,
            )
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(MetadataBlock::VT_VOCAB, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn source_as_dataset_source_root(&self) -> Option<DatasetSourceRoot<'a>> {
        if self.source_type() == DatasetSource::DatasetSourceRoot {
            self.source().map(DatasetSourceRoot::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn source_as_dataset_source_derivative(&self) -> Option<DatasetSourceDerivative<'a>> {
        if self.source_type() == DatasetSource::DatasetSourceDerivative {
            self.source().map(DatasetSourceDerivative::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for MetadataBlock<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("block_hash", Self::VT_BLOCK_HASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("prev_block_hash", Self::VT_PREV_BLOCK_HASH, false)?
     .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<OutputSlice>>("output_slice", Self::VT_OUTPUT_SLICE, false)?
     .visit_field::<Timestamp>("output_watermark", Self::VT_OUTPUT_WATERMARK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputSlice>>>>("input_slices", Self::VT_INPUT_SLICES, false)?
     .visit_union::<DatasetSource, _>("source_type", Self::VT_SOURCE_TYPE, "source", Self::VT_SOURCE, false, |key, v, pos| {
        match key {
          DatasetSource::DatasetSourceRoot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DatasetSourceRoot>>("DatasetSource::DatasetSourceRoot", pos),
          DatasetSource::DatasetSourceDerivative => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DatasetSourceDerivative>>("DatasetSource::DatasetSourceDerivative", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>("vocab", Self::VT_VOCAB, false)?
     .finish();
        Ok(())
    }
}
pub struct MetadataBlockArgs<'a> {
    pub block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub system_time: Option<&'a Timestamp>,
    pub output_slice: Option<flatbuffers::WIPOffset<OutputSlice<'a>>>,
    pub output_watermark: Option<&'a Timestamp>,
    pub input_slices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice<'a>>>,
        >,
    >,
    pub source_type: DatasetSource,
    pub source: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
}
impl<'a> Default for MetadataBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataBlockArgs {
            block_hash: None,
            prev_block_hash: None,
            system_time: None,
            output_slice: None,
            output_watermark: None,
            input_slices: None,
            source_type: DatasetSource::NONE,
            source: None,
            vocab: None,
        }
    }
}
pub struct MetadataBlockBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBlockBuilder<'a, 'b> {
    #[inline]
    pub fn add_block_hash(
        &mut self,
        block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MetadataBlock::VT_BLOCK_HASH,
            block_hash,
        );
    }
    #[inline]
    pub fn add_prev_block_hash(
        &mut self,
        prev_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MetadataBlock::VT_PREV_BLOCK_HASH,
            prev_block_hash,
        );
    }
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(MetadataBlock::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_output_slice(&mut self, output_slice: flatbuffers::WIPOffset<OutputSlice<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OutputSlice>>(
                MetadataBlock::VT_OUTPUT_SLICE,
                output_slice,
            );
    }
    #[inline]
    pub fn add_output_watermark(&mut self, output_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(MetadataBlock::VT_OUTPUT_WATERMARK, output_watermark);
    }
    #[inline]
    pub fn add_input_slices(
        &mut self,
        input_slices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InputSlice<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MetadataBlock::VT_INPUT_SLICES,
            input_slices,
        );
    }
    #[inline]
    pub fn add_source_type(&mut self, source_type: DatasetSource) {
        self.fbb_.push_slot::<DatasetSource>(
            MetadataBlock::VT_SOURCE_TYPE,
            source_type,
            DatasetSource::NONE,
        );
    }
    #[inline]
    pub fn add_source(&mut self, source: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_SOURCE, source);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                MetadataBlock::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBlockBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MetadataBlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MetadataBlock<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for MetadataBlock<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("MetadataBlock");
        ds.field("block_hash", &self.block_hash());
        ds.field("prev_block_hash", &self.prev_block_hash());
        ds.field("system_time", &self.system_time());
        ds.field("output_slice", &self.output_slice());
        ds.field("output_watermark", &self.output_watermark());
        ds.field("input_slices", &self.input_slices());
        ds.field("source_type", &self.source_type());
        match self.source_type() {
            DatasetSource::DatasetSourceRoot => {
                if let Some(x) = self.source_as_dataset_source_root() {
                    ds.field("source", &x)
                } else {
                    ds.field(
                        "source",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            DatasetSource::DatasetSourceDerivative => {
                if let Some(x) = self.source_as_dataset_source_derivative() {
                    ds.field("source", &x)
                } else {
                    ds.field(
                        "source",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("source", &x)
            }
        };
        ds.field("vocab", &self.vocab());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseProgressOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQueryResponseProgress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseProgress<'a> {
    type Inner = ExecuteQueryResponseProgress<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseProgress<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseProgress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ExecuteQueryResponseProgressArgs,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseProgress<'bldr>> {
        let mut builder = ExecuteQueryResponseProgressBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseProgress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseProgressArgs {}
impl<'a> Default for ExecuteQueryResponseProgressArgs {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseProgressArgs {}
    }
}
pub struct ExecuteQueryResponseProgressBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseProgressBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseProgressBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseProgressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseProgress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryResponseProgress<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseProgress");
        ds.finish()
    }
}
pub enum ExecuteQueryResponseSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseSuccess<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseSuccess<'a> {
    type Inner = ExecuteQueryResponseSuccess<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseSuccess<'a> {
    pub const VT_METADATA_BLOCK: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseSuccess { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseSuccessArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseSuccess<'bldr>> {
        let mut builder = ExecuteQueryResponseSuccessBuilder::new(_fbb);
        if let Some(x) = args.metadata_block {
            builder.add_metadata_block(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn metadata_block(&self) -> Option<MetadataBlock<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<MetadataBlock>>(
                ExecuteQueryResponseSuccess::VT_METADATA_BLOCK,
                None,
            )
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseSuccess<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<MetadataBlock>>(
                "metadata_block",
                Self::VT_METADATA_BLOCK,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseSuccessArgs<'a> {
    pub metadata_block: Option<flatbuffers::WIPOffset<MetadataBlock<'a>>>,
}
impl<'a> Default for ExecuteQueryResponseSuccessArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseSuccessArgs {
            metadata_block: None,
        }
    }
}
pub struct ExecuteQueryResponseSuccessBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseSuccessBuilder<'a, 'b> {
    #[inline]
    pub fn add_metadata_block(
        &mut self,
        metadata_block: flatbuffers::WIPOffset<MetadataBlock<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<MetadataBlock>>(
                ExecuteQueryResponseSuccess::VT_METADATA_BLOCK,
                metadata_block,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseSuccessBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseSuccessBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseSuccess<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryResponseSuccess<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseSuccess");
        ds.field("metadata_block", &self.metadata_block());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseInvalidQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseInvalidQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseInvalidQuery<'a> {
    type Inner = ExecuteQueryResponseInvalidQuery<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseInvalidQuery<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseInvalidQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseInvalidQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseInvalidQuery<'bldr>> {
        let mut builder = ExecuteQueryResponseInvalidQueryBuilder::new(_fbb);
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInvalidQuery::VT_MESSAGE,
            None,
        )
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseInvalidQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseInvalidQueryArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryResponseInvalidQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseInvalidQueryArgs { message: None }
    }
}
pub struct ExecuteQueryResponseInvalidQueryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseInvalidQueryBuilder<'a, 'b> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInvalidQuery::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseInvalidQueryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseInvalidQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseInvalidQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryResponseInvalidQuery<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseInvalidQuery");
        ds.field("message", &self.message());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseInternalErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseInternalError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseInternalError<'a> {
    type Inner = ExecuteQueryResponseInternalError<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseInternalError<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
    pub const VT_BACKTRACE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseInternalError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseInternalErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseInternalError<'bldr>> {
        let mut builder = ExecuteQueryResponseInternalErrorBuilder::new(_fbb);
        if let Some(x) = args.backtrace {
            builder.add_backtrace(x);
        }
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInternalError::VT_MESSAGE,
            None,
        )
    }
    #[inline]
    pub fn backtrace(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInternalError::VT_BACKTRACE,
            None,
        )
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseInternalError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backtrace",
                Self::VT_BACKTRACE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseInternalErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backtrace: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryResponseInternalErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseInternalErrorArgs {
            message: None,
            backtrace: None,
        }
    }
}
pub struct ExecuteQueryResponseInternalErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseInternalErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInternalError::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn add_backtrace(&mut self, backtrace: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInternalError::VT_BACKTRACE,
            backtrace,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseInternalErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseInternalErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseInternalError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryResponseInternalError<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseInternalError");
        ds.field("message", &self.message());
        ds.field("backtrace", &self.backtrace());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseRootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseRoot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseRoot<'a> {
    type Inner = ExecuteQueryResponseRoot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseRoot<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseRoot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseRootArgs,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseRoot<'bldr>> {
        let mut builder = ExecuteQueryResponseRootBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> ExecuteQueryResponse {
        self._tab
            .get::<ExecuteQueryResponse>(
                ExecuteQueryResponseRoot::VT_VALUE_TYPE,
                Some(ExecuteQueryResponse::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ExecuteQueryResponseRoot::VT_VALUE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_progress(
        &self,
    ) -> Option<ExecuteQueryResponseProgress<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseProgress {
            self.value()
                .map(ExecuteQueryResponseProgress::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_success(
        &self,
    ) -> Option<ExecuteQueryResponseSuccess<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseSuccess {
            self.value()
                .map(ExecuteQueryResponseSuccess::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_invalid_query(
        &self,
    ) -> Option<ExecuteQueryResponseInvalidQuery<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery {
            self.value()
                .map(ExecuteQueryResponseInvalidQuery::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_internal_error(
        &self,
    ) -> Option<ExecuteQueryResponseInternalError<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseInternalError {
            self.value()
                .map(ExecuteQueryResponseInternalError::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseRoot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<ExecuteQueryResponse, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          ExecuteQueryResponse::ExecuteQueryResponseProgress => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseProgress>>("ExecuteQueryResponse::ExecuteQueryResponseProgress", pos),
          ExecuteQueryResponse::ExecuteQueryResponseSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseSuccess>>("ExecuteQueryResponse::ExecuteQueryResponseSuccess", pos),
          ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseInvalidQuery>>("ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery", pos),
          ExecuteQueryResponse::ExecuteQueryResponseInternalError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseInternalError>>("ExecuteQueryResponse::ExecuteQueryResponseInternalError", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseRootArgs {
    pub value_type: ExecuteQueryResponse,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ExecuteQueryResponseRootArgs {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseRootArgs {
            value_type: ExecuteQueryResponse::NONE,
            value: None,
        }
    }
}
pub struct ExecuteQueryResponseRootBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseRootBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: ExecuteQueryResponse) {
        self.fbb_.push_slot::<ExecuteQueryResponse>(
            ExecuteQueryResponseRoot::VT_VALUE_TYPE,
            value_type,
            ExecuteQueryResponse::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseRoot::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseRootBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseRootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseRoot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl std::fmt::Debug for ExecuteQueryResponseRoot<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseRoot");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            ExecuteQueryResponse::ExecuteQueryResponseProgress => {
                if let Some(x) = self.value_as_execute_query_response_progress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseSuccess => {
                if let Some(x) = self.value_as_execute_query_response_success() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery => {
                if let Some(x) = self.value_as_execute_query_response_invalid_query() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseInternalError => {
                if let Some(x) = self.value_as_execute_query_response_internal_error() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
