// Copyright Kamu Data, Inc. and contributors. All rights reserved.
//
// Use of this software is governed by the Business Source License
// included in the LICENSE file.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0.

// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_ATTACHMENTS: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_ATTACHMENTS: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ATTACHMENTS: [Attachments; 2] =
    [Attachments::NONE, Attachments::AttachmentsEmbedded];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Attachments(pub u8);
#[allow(non_upper_case_globals)]
impl Attachments {
    pub const NONE: Self = Self(0);
    pub const AttachmentsEmbedded: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::AttachmentsEmbedded];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::AttachmentsEmbedded => Some("AttachmentsEmbedded"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Attachments {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Attachments {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for Attachments {
    type Output = Attachments;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for Attachments {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Attachments {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Attachments {}
pub struct AttachmentsUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DATASET_KIND: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DATASET_KIND: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATASET_KIND: [DatasetKind; 2] = [DatasetKind::Root, DatasetKind::Derivative];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DatasetKind(pub i32);
#[allow(non_upper_case_globals)]
impl DatasetKind {
    pub const Root: Self = Self(0);
    pub const Derivative: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Root, Self::Derivative];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Root => Some("Root"),
            Self::Derivative => Some("Derivative"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DatasetKind {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DatasetKind {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for DatasetKind {
    type Output = DatasetKind;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for DatasetKind {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i32::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i32::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DatasetKind {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DatasetKind {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EVENT_TIME_SOURCE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EVENT_TIME_SOURCE: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EVENT_TIME_SOURCE: [EventTimeSource; 3] = [
    EventTimeSource::NONE,
    EventTimeSource::EventTimeSourceFromMetadata,
    EventTimeSource::EventTimeSourceFromPath,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct EventTimeSource(pub u8);
#[allow(non_upper_case_globals)]
impl EventTimeSource {
    pub const NONE: Self = Self(0);
    pub const EventTimeSourceFromMetadata: Self = Self(1);
    pub const EventTimeSourceFromPath: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::EventTimeSourceFromMetadata,
        Self::EventTimeSourceFromPath,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::EventTimeSourceFromMetadata => Some("EventTimeSourceFromMetadata"),
            Self::EventTimeSourceFromPath => Some("EventTimeSourceFromPath"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for EventTimeSource {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for EventTimeSource {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for EventTimeSource {
    type Output = EventTimeSource;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for EventTimeSource {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for EventTimeSource {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for EventTimeSource {}
pub struct EventTimeSourceUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_CACHING: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_CACHING: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_CACHING: [SourceCaching; 2] =
    [SourceCaching::NONE, SourceCaching::SourceCachingForever];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceCaching(pub u8);
#[allow(non_upper_case_globals)]
impl SourceCaching {
    pub const NONE: Self = Self(0);
    pub const SourceCachingForever: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::SourceCachingForever];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::SourceCachingForever => Some("SourceCachingForever"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SourceCaching {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceCaching {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for SourceCaching {
    type Output = SourceCaching;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for SourceCaching {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceCaching {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceCaching {}
pub struct SourceCachingUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SOURCE_ORDERING: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SOURCE_ORDERING: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SOURCE_ORDERING: [SourceOrdering; 2] =
    [SourceOrdering::ByEventTime, SourceOrdering::ByName];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SourceOrdering(pub i32);
#[allow(non_upper_case_globals)]
impl SourceOrdering {
    pub const ByEventTime: Self = Self(0);
    pub const ByName: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::ByEventTime, Self::ByName];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::ByEventTime => Some("ByEventTime"),
            Self::ByName => Some("ByName"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SourceOrdering {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SourceOrdering {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for SourceOrdering {
    type Output = SourceOrdering;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for SourceOrdering {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i32::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i32::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SourceOrdering {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SourceOrdering {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_FETCH_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_FETCH_STEP: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FETCH_STEP: [FetchStep; 4] = [
    FetchStep::NONE,
    FetchStep::FetchStepUrl,
    FetchStep::FetchStepFilesGlob,
    FetchStep::FetchStepContainer,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FetchStep(pub u8);
#[allow(non_upper_case_globals)]
impl FetchStep {
    pub const NONE: Self = Self(0);
    pub const FetchStepUrl: Self = Self(1);
    pub const FetchStepFilesGlob: Self = Self(2);
    pub const FetchStepContainer: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::FetchStepUrl,
        Self::FetchStepFilesGlob,
        Self::FetchStepContainer,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::FetchStepUrl => Some("FetchStepUrl"),
            Self::FetchStepFilesGlob => Some("FetchStepFilesGlob"),
            Self::FetchStepContainer => Some("FetchStepContainer"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for FetchStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for FetchStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for FetchStep {
    type Output = FetchStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for FetchStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for FetchStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for FetchStep {}
pub struct FetchStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_COMPRESSION_FORMAT: i32 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_COMPRESSION_FORMAT: i32 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMPRESSION_FORMAT: [CompressionFormat; 2] =
    [CompressionFormat::Gzip, CompressionFormat::Zip];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CompressionFormat(pub i32);
#[allow(non_upper_case_globals)]
impl CompressionFormat {
    pub const Gzip: Self = Self(0);
    pub const Zip: Self = Self(1);

    pub const ENUM_MIN: i32 = 0;
    pub const ENUM_MAX: i32 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::Gzip, Self::Zip];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::Gzip => Some("Gzip"),
            Self::Zip => Some("Zip"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for CompressionFormat {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for CompressionFormat {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<i32>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for CompressionFormat {
    type Output = CompressionFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<i32>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for CompressionFormat {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = i32::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = i32::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for CompressionFormat {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        i32::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for CompressionFormat {}
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_PREP_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_PREP_STEP: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PREP_STEP: [PrepStep; 3] = [
    PrepStep::NONE,
    PrepStep::PrepStepDecompress,
    PrepStep::PrepStepPipe,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PrepStep(pub u8);
#[allow(non_upper_case_globals)]
impl PrepStep {
    pub const NONE: Self = Self(0);
    pub const PrepStepDecompress: Self = Self(1);
    pub const PrepStepPipe: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] =
        &[Self::NONE, Self::PrepStepDecompress, Self::PrepStepPipe];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::PrepStepDecompress => Some("PrepStepDecompress"),
            Self::PrepStepPipe => Some("PrepStepPipe"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for PrepStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for PrepStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for PrepStep {
    type Output = PrepStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for PrepStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for PrepStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for PrepStep {}
pub struct PrepStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_READ_STEP: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_READ_STEP: u8 = 5;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_READ_STEP: [ReadStep; 6] = [
    ReadStep::NONE,
    ReadStep::ReadStepCsv,
    ReadStep::ReadStepJsonLines,
    ReadStep::ReadStepGeoJson,
    ReadStep::ReadStepEsriShapefile,
    ReadStep::ReadStepParquet,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ReadStep(pub u8);
#[allow(non_upper_case_globals)]
impl ReadStep {
    pub const NONE: Self = Self(0);
    pub const ReadStepCsv: Self = Self(1);
    pub const ReadStepJsonLines: Self = Self(2);
    pub const ReadStepGeoJson: Self = Self(3);
    pub const ReadStepEsriShapefile: Self = Self(4);
    pub const ReadStepParquet: Self = Self(5);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 5;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ReadStepCsv,
        Self::ReadStepJsonLines,
        Self::ReadStepGeoJson,
        Self::ReadStepEsriShapefile,
        Self::ReadStepParquet,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ReadStepCsv => Some("ReadStepCsv"),
            Self::ReadStepJsonLines => Some("ReadStepJsonLines"),
            Self::ReadStepGeoJson => Some("ReadStepGeoJson"),
            Self::ReadStepEsriShapefile => Some("ReadStepEsriShapefile"),
            Self::ReadStepParquet => Some("ReadStepParquet"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ReadStep {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ReadStep {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ReadStep {
    type Output = ReadStep;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ReadStep {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ReadStep {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ReadStep {}
pub struct ReadStepUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_TRANSFORM: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_TRANSFORM: u8 = 1;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TRANSFORM: [Transform; 2] = [Transform::NONE, Transform::TransformSql];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Transform(pub u8);
#[allow(non_upper_case_globals)]
impl Transform {
    pub const NONE: Self = Self(0);
    pub const TransformSql: Self = Self(1);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 1;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::TransformSql];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TransformSql => Some("TransformSql"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Transform {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Transform {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for Transform {
    type Output = Transform;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for Transform {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Transform {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Transform {}
pub struct TransformUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_MERGE_STRATEGY: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_MERGE_STRATEGY: u8 = 3;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MERGE_STRATEGY: [MergeStrategy; 4] = [
    MergeStrategy::NONE,
    MergeStrategy::MergeStrategyAppend,
    MergeStrategy::MergeStrategyLedger,
    MergeStrategy::MergeStrategySnapshot,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MergeStrategy(pub u8);
#[allow(non_upper_case_globals)]
impl MergeStrategy {
    pub const NONE: Self = Self(0);
    pub const MergeStrategyAppend: Self = Self(1);
    pub const MergeStrategyLedger: Self = Self(2);
    pub const MergeStrategySnapshot: Self = Self(3);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 3;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::MergeStrategyAppend,
        Self::MergeStrategyLedger,
        Self::MergeStrategySnapshot,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::MergeStrategyAppend => Some("MergeStrategyAppend"),
            Self::MergeStrategyLedger => Some("MergeStrategyLedger"),
            Self::MergeStrategySnapshot => Some("MergeStrategySnapshot"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MergeStrategy {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MergeStrategy {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for MergeStrategy {
    type Output = MergeStrategy;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for MergeStrategy {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MergeStrategy {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MergeStrategy {}
pub struct MergeStrategyUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_METADATA_EVENT: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_METADATA_EVENT: u8 = 10;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_METADATA_EVENT: [MetadataEvent; 11] = [
    MetadataEvent::NONE,
    MetadataEvent::AddData,
    MetadataEvent::ExecuteQuery,
    MetadataEvent::Seed,
    MetadataEvent::SetPollingSource,
    MetadataEvent::SetTransform,
    MetadataEvent::SetVocab,
    MetadataEvent::SetWatermark,
    MetadataEvent::SetAttachments,
    MetadataEvent::SetInfo,
    MetadataEvent::SetLicense,
];

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MetadataEvent(pub u8);
#[allow(non_upper_case_globals)]
impl MetadataEvent {
    pub const NONE: Self = Self(0);
    pub const AddData: Self = Self(1);
    pub const ExecuteQuery: Self = Self(2);
    pub const Seed: Self = Self(3);
    pub const SetPollingSource: Self = Self(4);
    pub const SetTransform: Self = Self(5);
    pub const SetVocab: Self = Self(6);
    pub const SetWatermark: Self = Self(7);
    pub const SetAttachments: Self = Self(8);
    pub const SetInfo: Self = Self(9);
    pub const SetLicense: Self = Self(10);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 10;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::AddData,
        Self::ExecuteQuery,
        Self::Seed,
        Self::SetPollingSource,
        Self::SetTransform,
        Self::SetVocab,
        Self::SetWatermark,
        Self::SetAttachments,
        Self::SetInfo,
        Self::SetLicense,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::AddData => Some("AddData"),
            Self::ExecuteQuery => Some("ExecuteQuery"),
            Self::Seed => Some("Seed"),
            Self::SetPollingSource => Some("SetPollingSource"),
            Self::SetTransform => Some("SetTransform"),
            Self::SetVocab => Some("SetVocab"),
            Self::SetWatermark => Some("SetWatermark"),
            Self::SetAttachments => Some("SetAttachments"),
            Self::SetInfo => Some("SetInfo"),
            Self::SetLicense => Some("SetLicense"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for MetadataEvent {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for MetadataEvent {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for MetadataEvent {
    type Output = MetadataEvent;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for MetadataEvent {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for MetadataEvent {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for MetadataEvent {}
pub struct MetadataEventUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_EXECUTE_QUERY_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_EXECUTE_QUERY_RESPONSE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_EXECUTE_QUERY_RESPONSE: [ExecuteQueryResponse; 5] = [
    ExecuteQueryResponse::NONE,
    ExecuteQueryResponse::ExecuteQueryResponseProgress,
    ExecuteQueryResponse::ExecuteQueryResponseSuccess,
    ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery,
    ExecuteQueryResponse::ExecuteQueryResponseInternalError,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ExecuteQueryResponse(pub u8);
#[allow(non_upper_case_globals)]
impl ExecuteQueryResponse {
    pub const NONE: Self = Self(0);
    pub const ExecuteQueryResponseProgress: Self = Self(1);
    pub const ExecuteQueryResponseSuccess: Self = Self(2);
    pub const ExecuteQueryResponseInvalidQuery: Self = Self(3);
    pub const ExecuteQueryResponseInternalError: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ExecuteQueryResponseProgress,
        Self::ExecuteQueryResponseSuccess,
        Self::ExecuteQueryResponseInvalidQuery,
        Self::ExecuteQueryResponseInternalError,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ExecuteQueryResponseProgress => Some("ExecuteQueryResponseProgress"),
            Self::ExecuteQueryResponseSuccess => Some("ExecuteQueryResponseSuccess"),
            Self::ExecuteQueryResponseInvalidQuery => Some("ExecuteQueryResponseInvalidQuery"),
            Self::ExecuteQueryResponseInternalError => Some("ExecuteQueryResponseInternalError"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ExecuteQueryResponse {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponse {
    type Inner = Self;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
        Self(b)
    }
}

impl flatbuffers::Push for ExecuteQueryResponse {
    type Output = ExecuteQueryResponse;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }
}

impl flatbuffers::EndianScalar for ExecuteQueryResponse {
    #[inline]
    fn to_little_endian(self) -> Self {
        let b = u8::to_le(self.0);
        Self(b)
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(self) -> Self {
        let b = u8::from_le(self.0);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ExecuteQueryResponse {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ExecuteQueryResponse {}
pub struct ExecuteQueryResponseUnionTableOffset {}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
// struct Timestamp, aligned to 4
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Timestamp(pub [u8; 16]);
impl Default for Timestamp {
    fn default() -> Self {
        Self([0; 16])
    }
}
impl core::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Timestamp")
            .field("year", &self.year())
            .field("ordinal", &self.ordinal())
            .field("seconds_from_midnight", &self.seconds_from_midnight())
            .field("nanoseconds", &self.nanoseconds())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Timestamp {}
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a Timestamp>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
    type Inner = &'a Timestamp;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::core::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Timestamp {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> Timestamp {
    #[allow(clippy::too_many_arguments)]
    pub fn new(year: i32, ordinal: u16, seconds_from_midnight: u32, nanoseconds: u32) -> Self {
        let mut s = Self([0; 16]);
        s.set_year(year);
        s.set_ordinal(ordinal);
        s.set_seconds_from_midnight(seconds_from_midnight);
        s.set_nanoseconds(nanoseconds);
        s
    }

    pub fn year(&self) -> i32 {
        let mut mem = core::mem::MaybeUninit::<i32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[0..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<i32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_year(&mut self, x: i32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const i32 as *const u8,
                self.0[0..].as_mut_ptr(),
                core::mem::size_of::<i32>(),
            );
        }
    }

    pub fn ordinal(&self) -> u16 {
        let mut mem = core::mem::MaybeUninit::<u16>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[4..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u16>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_ordinal(&mut self, x: u16) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u16 as *const u8,
                self.0[4..].as_mut_ptr(),
                core::mem::size_of::<u16>(),
            );
        }
    }

    pub fn seconds_from_midnight(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<u32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[8..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_seconds_from_midnight(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u32 as *const u8,
                self.0[8..].as_mut_ptr(),
                core::mem::size_of::<u32>(),
            );
        }
    }

    pub fn nanoseconds(&self) -> u32 {
        let mut mem = core::mem::MaybeUninit::<u32>::uninit();
        unsafe {
            core::ptr::copy_nonoverlapping(
                self.0[12..].as_ptr(),
                mem.as_mut_ptr() as *mut u8,
                core::mem::size_of::<u32>(),
            );
            mem.assume_init()
        }
        .from_little_endian()
    }

    pub fn set_nanoseconds(&mut self, x: u32) {
        let x_le = x.to_little_endian();
        unsafe {
            core::ptr::copy_nonoverlapping(
                &x_le as *const u32 as *const u8,
                self.0[12..].as_mut_ptr(),
                core::mem::size_of::<u32>(),
            );
        }
    }
}

pub enum OffsetIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct OffsetInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OffsetInterval<'a> {
    type Inner = OffsetInterval<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> OffsetInterval<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        OffsetInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OffsetIntervalArgs,
    ) -> flatbuffers::WIPOffset<OffsetInterval<'bldr>> {
        let mut builder = OffsetIntervalBuilder::new(_fbb);
        builder.add_end(args.end);
        builder.add_start(args.start);
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> i64 {
        self._tab
            .get::<i64>(OffsetInterval::VT_START, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn end(&self) -> i64 {
        self._tab
            .get::<i64>(OffsetInterval::VT_END, Some(0))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for OffsetInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("start", Self::VT_START, false)?
            .visit_field::<i64>("end", Self::VT_END, false)?
            .finish();
        Ok(())
    }
}
pub struct OffsetIntervalArgs {
    pub start: i64,
    pub end: i64,
}
impl<'a> Default for OffsetIntervalArgs {
    #[inline]
    fn default() -> Self {
        OffsetIntervalArgs { start: 0, end: 0 }
    }
}

pub struct OffsetIntervalBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OffsetIntervalBuilder<'a, 'b> {
    #[inline]
    pub fn add_start(&mut self, start: i64) {
        self.fbb_
            .push_slot::<i64>(OffsetInterval::VT_START, start, 0);
    }
    #[inline]
    pub fn add_end(&mut self, end: i64) {
        self.fbb_.push_slot::<i64>(OffsetInterval::VT_END, end, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OffsetIntervalBuilder<'a, 'b> {
        let start = _fbb.start_table();
        OffsetIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<OffsetInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for OffsetInterval<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("OffsetInterval");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum DataSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DataSlice<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DataSlice<'a> {
    type Inner = DataSlice<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DataSlice<'a> {
    pub const VT_LOGICAL_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_PHYSICAL_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_INTERVAL: flatbuffers::VOffsetT = 8;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DataSlice { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DataSliceArgs<'args>,
    ) -> flatbuffers::WIPOffset<DataSlice<'bldr>> {
        let mut builder = DataSliceBuilder::new(_fbb);
        builder.add_size_(args.size_);
        if let Some(x) = args.interval {
            builder.add_interval(x);
        }
        if let Some(x) = args.physical_hash {
            builder.add_physical_hash(x);
        }
        if let Some(x) = args.logical_hash {
            builder.add_logical_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn logical_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                DataSlice::VT_LOGICAL_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn physical_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                DataSlice::VT_PHYSICAL_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(DataSlice::VT_INTERVAL, None)
    }
    #[inline]
    pub fn size_(&self) -> i64 {
        self._tab.get::<i64>(DataSlice::VT_SIZE_, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for DataSlice<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "logical_hash",
                Self::VT_LOGICAL_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "physical_hash",
                Self::VT_PHYSICAL_HASH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "interval",
                Self::VT_INTERVAL,
                false,
            )?
            .visit_field::<i64>("size_", Self::VT_SIZE_, false)?
            .finish();
        Ok(())
    }
}
pub struct DataSliceArgs<'a> {
    pub logical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub physical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub size_: i64,
}
impl<'a> Default for DataSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        DataSliceArgs {
            logical_hash: None,
            physical_hash: None,
            interval: None,
            size_: 0,
        }
    }
}

pub struct DataSliceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DataSliceBuilder<'a, 'b> {
    #[inline]
    pub fn add_logical_hash(
        &mut self,
        logical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DataSlice::VT_LOGICAL_HASH,
            logical_hash,
        );
    }
    #[inline]
    pub fn add_physical_hash(
        &mut self,
        physical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DataSlice::VT_PHYSICAL_HASH,
            physical_hash,
        );
    }
    #[inline]
    pub fn add_interval(&mut self, interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                DataSlice::VT_INTERVAL,
                interval,
            );
    }
    #[inline]
    pub fn add_size_(&mut self, size_: i64) {
        self.fbb_.push_slot::<i64>(DataSlice::VT_SIZE_, size_, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DataSliceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DataSliceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DataSlice<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DataSlice<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DataSlice");
        ds.field("logical_hash", &self.logical_hash());
        ds.field("physical_hash", &self.physical_hash());
        ds.field("interval", &self.interval());
        ds.field("size_", &self.size_());
        ds.finish()
    }
}
pub enum CheckpointOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct Checkpoint<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
    type Inner = Checkpoint<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Checkpoint<'a> {
    pub const VT_PHYSICAL_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Checkpoint { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CheckpointArgs<'args>,
    ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
        let mut builder = CheckpointBuilder::new(_fbb);
        builder.add_size_(args.size_);
        if let Some(x) = args.physical_hash {
            builder.add_physical_hash(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn physical_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Checkpoint::VT_PHYSICAL_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn size_(&self) -> i64 {
        self._tab.get::<i64>(Checkpoint::VT_SIZE_, Some(0)).unwrap()
    }
}

impl flatbuffers::Verifiable for Checkpoint<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "physical_hash",
                Self::VT_PHYSICAL_HASH,
                false,
            )?
            .visit_field::<i64>("size_", Self::VT_SIZE_, false)?
            .finish();
        Ok(())
    }
}
pub struct CheckpointArgs<'a> {
    pub physical_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub size_: i64,
}
impl<'a> Default for CheckpointArgs<'a> {
    #[inline]
    fn default() -> Self {
        CheckpointArgs {
            physical_hash: None,
            size_: 0,
        }
    }
}

pub struct CheckpointBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CheckpointBuilder<'a, 'b> {
    #[inline]
    pub fn add_physical_hash(
        &mut self,
        physical_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            Checkpoint::VT_PHYSICAL_HASH,
            physical_hash,
        );
    }
    #[inline]
    pub fn add_size_(&mut self, size_: i64) {
        self.fbb_.push_slot::<i64>(Checkpoint::VT_SIZE_, size_, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CheckpointBuilder<'a, 'b> {
        let start = _fbb.start_table();
        CheckpointBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Checkpoint<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Checkpoint");
        ds.field("physical_hash", &self.physical_hash());
        ds.field("size_", &self.size_());
        ds.finish()
    }
}
pub enum AddDataOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct AddData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddData<'a> {
    type Inner = AddData<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AddData<'a> {
    pub const VT_INPUT_CHECKPOINT: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_DATA: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUT_CHECKPOINT: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AddData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AddDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<AddData<'bldr>> {
        let mut builder = AddDataBuilder::new(_fbb);
        if let Some(x) = args.output_watermark {
            builder.add_output_watermark(x);
        }
        if let Some(x) = args.output_checkpoint {
            builder.add_output_checkpoint(x);
        }
        if let Some(x) = args.output_data {
            builder.add_output_data(x);
        }
        if let Some(x) = args.input_checkpoint {
            builder.add_input_checkpoint(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn input_checkpoint(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                AddData::VT_INPUT_CHECKPOINT,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn output_data(&self) -> Option<DataSlice<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DataSlice>>(AddData::VT_OUTPUT_DATA, None)
    }
    #[inline]
    pub fn output_checkpoint(&self) -> Option<Checkpoint<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Checkpoint>>(AddData::VT_OUTPUT_CHECKPOINT, None)
    }
    #[inline]
    pub fn output_watermark(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(AddData::VT_OUTPUT_WATERMARK, None)
    }
}

impl flatbuffers::Verifiable for AddData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "input_checkpoint",
                Self::VT_INPUT_CHECKPOINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DataSlice>>(
                "output_data",
                Self::VT_OUTPUT_DATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Checkpoint>>(
                "output_checkpoint",
                Self::VT_OUTPUT_CHECKPOINT,
                false,
            )?
            .visit_field::<Timestamp>("output_watermark", Self::VT_OUTPUT_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct AddDataArgs<'a> {
    pub input_checkpoint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub output_data: Option<flatbuffers::WIPOffset<DataSlice<'a>>>,
    pub output_checkpoint: Option<flatbuffers::WIPOffset<Checkpoint<'a>>>,
    pub output_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for AddDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        AddDataArgs {
            input_checkpoint: None,
            output_data: None,
            output_checkpoint: None,
            output_watermark: None,
        }
    }
}

pub struct AddDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_input_checkpoint(
        &mut self,
        input_checkpoint: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            AddData::VT_INPUT_CHECKPOINT,
            input_checkpoint,
        );
    }
    #[inline]
    pub fn add_output_data(&mut self, output_data: flatbuffers::WIPOffset<DataSlice<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DataSlice>>(
                AddData::VT_OUTPUT_DATA,
                output_data,
            );
    }
    #[inline]
    pub fn add_output_checkpoint(
        &mut self,
        output_checkpoint: flatbuffers::WIPOffset<Checkpoint<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Checkpoint>>(
                AddData::VT_OUTPUT_CHECKPOINT,
                output_checkpoint,
            );
    }
    #[inline]
    pub fn add_output_watermark(&mut self, output_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(AddData::VT_OUTPUT_WATERMARK, output_watermark);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AddDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AddData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AddData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AddData");
        ds.field("input_checkpoint", &self.input_checkpoint());
        ds.field("output_data", &self.output_data());
        ds.field("output_checkpoint", &self.output_checkpoint());
        ds.field("output_watermark", &self.output_watermark());
        ds.finish()
    }
}
pub enum AttachmentEmbeddedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct AttachmentEmbedded<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttachmentEmbedded<'a> {
    type Inner = AttachmentEmbedded<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AttachmentEmbedded<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AttachmentEmbedded { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AttachmentEmbeddedArgs<'args>,
    ) -> flatbuffers::WIPOffset<AttachmentEmbedded<'bldr>> {
        let mut builder = AttachmentEmbeddedBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(AttachmentEmbedded::VT_PATH, None)
    }
    #[inline]
    pub fn content(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(AttachmentEmbedded::VT_CONTENT, None)
    }
}

impl flatbuffers::Verifiable for AttachmentEmbedded<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
            .finish();
        Ok(())
    }
}
pub struct AttachmentEmbeddedArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for AttachmentEmbeddedArgs<'a> {
    #[inline]
    fn default() -> Self {
        AttachmentEmbeddedArgs {
            path: None,
            content: None,
        }
    }
}

pub struct AttachmentEmbeddedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AttachmentEmbeddedBuilder<'a, 'b> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentEmbedded::VT_PATH, path);
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentEmbedded::VT_CONTENT, content);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> AttachmentEmbeddedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AttachmentEmbeddedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AttachmentEmbedded<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AttachmentEmbedded<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AttachmentEmbedded");
        ds.field("path", &self.path());
        ds.field("content", &self.content());
        ds.finish()
    }
}
pub enum AttachmentsEmbeddedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct AttachmentsEmbedded<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AttachmentsEmbedded<'a> {
    type Inner = AttachmentsEmbedded<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> AttachmentsEmbedded<'a> {
    pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        AttachmentsEmbedded { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AttachmentsEmbeddedArgs<'args>,
    ) -> flatbuffers::WIPOffset<AttachmentsEmbedded<'bldr>> {
        let mut builder = AttachmentsEmbeddedBuilder::new(_fbb);
        if let Some(x) = args.items {
            builder.add_items(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn items(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded>>,
        >>(AttachmentsEmbedded::VT_ITEMS, None)
    }
}

impl flatbuffers::Verifiable for AttachmentsEmbedded<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<AttachmentEmbedded>>,
            >>("items", Self::VT_ITEMS, false)?
            .finish();
        Ok(())
    }
}
pub struct AttachmentsEmbeddedArgs<'a> {
    pub items: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'a>>>,
        >,
    >,
}
impl<'a> Default for AttachmentsEmbeddedArgs<'a> {
    #[inline]
    fn default() -> Self {
        AttachmentsEmbeddedArgs { items: None }
    }
}

pub struct AttachmentsEmbeddedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AttachmentsEmbeddedBuilder<'a, 'b> {
    #[inline]
    pub fn add_items(
        &mut self,
        items: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<AttachmentEmbedded<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(AttachmentsEmbedded::VT_ITEMS, items);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> AttachmentsEmbeddedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        AttachmentsEmbeddedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<AttachmentsEmbedded<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for AttachmentsEmbedded<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("AttachmentsEmbedded");
        ds.field("items", &self.items());
        ds.finish()
    }
}
pub enum BlockIntervalOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct BlockInterval<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockInterval<'a> {
    type Inner = BlockInterval<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> BlockInterval<'a> {
    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BlockInterval { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BlockIntervalArgs<'args>,
    ) -> flatbuffers::WIPOffset<BlockInterval<'bldr>> {
        let mut builder = BlockIntervalBuilder::new(_fbb);
        if let Some(x) = args.end {
            builder.add_end(x);
        }
        if let Some(x) = args.start {
            builder.add_start(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn start(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                BlockInterval::VT_START,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn end(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                BlockInterval::VT_END,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

impl flatbuffers::Verifiable for BlockInterval<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "start",
                Self::VT_START,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "end",
                Self::VT_END,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct BlockIntervalArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub end: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BlockIntervalArgs<'a> {
    #[inline]
    fn default() -> Self {
        BlockIntervalArgs {
            start: None,
            end: None,
        }
    }
}

pub struct BlockIntervalBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockIntervalBuilder<'a, 'b> {
    #[inline]
    pub fn add_start(&mut self, start: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockInterval::VT_START, start);
    }
    #[inline]
    pub fn add_end(&mut self, end: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(BlockInterval::VT_END, end);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockIntervalBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BlockIntervalBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<BlockInterval<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for BlockInterval<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("BlockInterval");
        ds.field("start", &self.start());
        ds.field("end", &self.end());
        ds.finish()
    }
}
pub enum InputSliceOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct InputSlice<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InputSlice<'a> {
    type Inner = InputSlice<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> InputSlice<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_BLOCK_INTERVAL: flatbuffers::VOffsetT = 6;
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InputSlice { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InputSliceArgs<'args>,
    ) -> flatbuffers::WIPOffset<InputSlice<'bldr>> {
        let mut builder = InputSliceBuilder::new(_fbb);
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        if let Some(x) = args.block_interval {
            builder.add_block_interval(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                InputSlice::VT_DATASET_ID,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn block_interval(&self) -> Option<BlockInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<BlockInterval>>(InputSlice::VT_BLOCK_INTERVAL, None)
    }
    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(InputSlice::VT_DATA_INTERVAL, None)
    }
}

impl flatbuffers::Verifiable for InputSlice<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<BlockInterval>>(
                "block_interval",
                Self::VT_BLOCK_INTERVAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct InputSliceArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub block_interval: Option<flatbuffers::WIPOffset<BlockInterval<'a>>>,
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
}
impl<'a> Default for InputSliceArgs<'a> {
    #[inline]
    fn default() -> Self {
        InputSliceArgs {
            dataset_id: None,
            block_interval: None,
            data_interval: None,
        }
    }
}

pub struct InputSliceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InputSliceBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(InputSlice::VT_DATASET_ID, dataset_id);
    }
    #[inline]
    pub fn add_block_interval(
        &mut self,
        block_interval: flatbuffers::WIPOffset<BlockInterval<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<BlockInterval>>(
                InputSlice::VT_BLOCK_INTERVAL,
                block_interval,
            );
    }
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                InputSlice::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InputSliceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        InputSliceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<InputSlice<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for InputSlice<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("InputSlice");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("block_interval", &self.block_interval());
        ds.field("data_interval", &self.data_interval());
        ds.finish()
    }
}
pub enum ExecuteQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQuery<'a> {
    type Inner = ExecuteQuery<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQuery<'a> {
    pub const VT_INPUT_SLICES: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT_CHECKPOINT: flatbuffers::VOffsetT = 6;
    pub const VT_OUTPUT_DATA: flatbuffers::VOffsetT = 8;
    pub const VT_OUTPUT_CHECKPOINT: flatbuffers::VOffsetT = 10;
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQuery<'bldr>> {
        let mut builder = ExecuteQueryBuilder::new(_fbb);
        if let Some(x) = args.output_watermark {
            builder.add_output_watermark(x);
        }
        if let Some(x) = args.output_checkpoint {
            builder.add_output_checkpoint(x);
        }
        if let Some(x) = args.output_data {
            builder.add_output_data(x);
        }
        if let Some(x) = args.input_checkpoint {
            builder.add_input_checkpoint(x);
        }
        if let Some(x) = args.input_slices {
            builder.add_input_slices(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn input_slices(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice>>,
        >>(ExecuteQuery::VT_INPUT_SLICES, None)
    }
    #[inline]
    pub fn input_checkpoint(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                ExecuteQuery::VT_INPUT_CHECKPOINT,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn output_data(&self) -> Option<DataSlice<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DataSlice>>(ExecuteQuery::VT_OUTPUT_DATA, None)
    }
    #[inline]
    pub fn output_checkpoint(&self) -> Option<Checkpoint<'a>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<Checkpoint>>(
            ExecuteQuery::VT_OUTPUT_CHECKPOINT,
            None,
        )
    }
    #[inline]
    pub fn output_watermark(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(ExecuteQuery::VT_OUTPUT_WATERMARK, None)
    }
}

impl flatbuffers::Verifiable for ExecuteQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<InputSlice>>,
            >>("input_slices", Self::VT_INPUT_SLICES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "input_checkpoint",
                Self::VT_INPUT_CHECKPOINT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DataSlice>>(
                "output_data",
                Self::VT_OUTPUT_DATA,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<Checkpoint>>(
                "output_checkpoint",
                Self::VT_OUTPUT_CHECKPOINT,
                false,
            )?
            .visit_field::<Timestamp>("output_watermark", Self::VT_OUTPUT_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryArgs<'a> {
    pub input_slices: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<InputSlice<'a>>>,
        >,
    >,
    pub input_checkpoint: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub output_data: Option<flatbuffers::WIPOffset<DataSlice<'a>>>,
    pub output_checkpoint: Option<flatbuffers::WIPOffset<Checkpoint<'a>>>,
    pub output_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for ExecuteQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryArgs {
            input_slices: None,
            input_checkpoint: None,
            output_data: None,
            output_checkpoint: None,
            output_watermark: None,
        }
    }
}

pub struct ExecuteQueryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryBuilder<'a, 'b> {
    #[inline]
    pub fn add_input_slices(
        &mut self,
        input_slices: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<InputSlice<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQuery::VT_INPUT_SLICES,
            input_slices,
        );
    }
    #[inline]
    pub fn add_input_checkpoint(
        &mut self,
        input_checkpoint: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQuery::VT_INPUT_CHECKPOINT,
            input_checkpoint,
        );
    }
    #[inline]
    pub fn add_output_data(&mut self, output_data: flatbuffers::WIPOffset<DataSlice<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DataSlice>>(
                ExecuteQuery::VT_OUTPUT_DATA,
                output_data,
            );
    }
    #[inline]
    pub fn add_output_checkpoint(
        &mut self,
        output_checkpoint: flatbuffers::WIPOffset<Checkpoint<'b>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Checkpoint>>(
                ExecuteQuery::VT_OUTPUT_CHECKPOINT,
                output_checkpoint,
            );
    }
    #[inline]
    pub fn add_output_watermark(&mut self, output_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(ExecuteQuery::VT_OUTPUT_WATERMARK, output_watermark);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExecuteQueryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQuery");
        ds.field("input_slices", &self.input_slices());
        ds.field("input_checkpoint", &self.input_checkpoint());
        ds.field("output_data", &self.output_data());
        ds.field("output_checkpoint", &self.output_checkpoint());
        ds.field("output_watermark", &self.output_watermark());
        ds.finish()
    }
}
pub enum SeedOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct Seed<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Seed<'a> {
    type Inner = Seed<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Seed<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_KIND: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Seed { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SeedArgs<'args>,
    ) -> flatbuffers::WIPOffset<Seed<'bldr>> {
        let mut builder = SeedBuilder::new(_fbb);
        builder.add_dataset_kind(args.dataset_kind);
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Seed::VT_DATASET_ID,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn dataset_kind(&self) -> DatasetKind {
        self._tab
            .get::<DatasetKind>(Seed::VT_DATASET_KIND, Some(DatasetKind::Root))
            .unwrap()
    }
}

impl flatbuffers::Verifiable for Seed<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<DatasetKind>("dataset_kind", Self::VT_DATASET_KIND, false)?
            .finish();
        Ok(())
    }
}
pub struct SeedArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_kind: DatasetKind,
}
impl<'a> Default for SeedArgs<'a> {
    #[inline]
    fn default() -> Self {
        SeedArgs {
            dataset_id: None,
            dataset_kind: DatasetKind::Root,
        }
    }
}

pub struct SeedBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SeedBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Seed::VT_DATASET_ID, dataset_id);
    }
    #[inline]
    pub fn add_dataset_kind(&mut self, dataset_kind: DatasetKind) {
        self.fbb_
            .push_slot::<DatasetKind>(Seed::VT_DATASET_KIND, dataset_kind, DatasetKind::Root);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SeedBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SeedBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Seed<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Seed<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Seed");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_kind", &self.dataset_kind());
        ds.finish()
    }
}
pub enum EventTimeSourceFromMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct EventTimeSourceFromMetadata<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromMetadata<'a> {
    type Inner = EventTimeSourceFromMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EventTimeSourceFromMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromMetadata { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args EventTimeSourceFromMetadataArgs,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'bldr>> {
        let mut builder = EventTimeSourceFromMetadataBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromMetadata<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromMetadataArgs {}
impl<'a> Default for EventTimeSourceFromMetadataArgs {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromMetadataArgs {}
    }
}

pub struct EventTimeSourceFromMetadataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromMetadataBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> EventTimeSourceFromMetadataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EventTimeSourceFromMetadataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromMetadata<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EventTimeSourceFromMetadata<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromMetadata");
        ds.finish()
    }
}
pub enum EventTimeSourceFromPathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EventTimeSourceFromPath<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EventTimeSourceFromPath<'a> {
    type Inner = EventTimeSourceFromPath<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EventTimeSourceFromPath<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EventTimeSourceFromPath { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EventTimeSourceFromPathArgs<'args>,
    ) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'bldr>> {
        let mut builder = EventTimeSourceFromPathBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EventTimeSourceFromPath::VT_PATTERN, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
            None,
        )
    }
}

impl flatbuffers::Verifiable for EventTimeSourceFromPath<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct EventTimeSourceFromPathArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EventTimeSourceFromPathArgs<'a> {
    #[inline]
    fn default() -> Self {
        EventTimeSourceFromPathArgs {
            pattern: None,
            timestamp_format: None,
        }
    }
}

pub struct EventTimeSourceFromPathBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EventTimeSourceFromPathBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_PATTERN,
            pattern,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            EventTimeSourceFromPath::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> EventTimeSourceFromPathBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EventTimeSourceFromPathBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EventTimeSourceFromPath<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EventTimeSourceFromPath<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EventTimeSourceFromPath");
        ds.field("pattern", &self.pattern());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum SourceCachingForeverOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SourceCachingForever<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SourceCachingForever<'a> {
    type Inner = SourceCachingForever<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SourceCachingForever<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SourceCachingForever { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args SourceCachingForeverArgs,
    ) -> flatbuffers::WIPOffset<SourceCachingForever<'bldr>> {
        let mut builder = SourceCachingForeverBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for SourceCachingForever<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct SourceCachingForeverArgs {}
impl<'a> Default for SourceCachingForeverArgs {
    #[inline]
    fn default() -> Self {
        SourceCachingForeverArgs {}
    }
}

pub struct SourceCachingForeverBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SourceCachingForeverBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> SourceCachingForeverBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SourceCachingForeverBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SourceCachingForever<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SourceCachingForever<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SourceCachingForever");
        ds.finish()
    }
}
pub enum EnvVarOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct EnvVar<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EnvVar<'a> {
    type Inner = EnvVar<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> EnvVar<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EnvVar { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EnvVarArgs<'args>,
    ) -> flatbuffers::WIPOffset<EnvVar<'bldr>> {
        let mut builder = EnvVarBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EnvVar::VT_NAME, None)
    }
    #[inline]
    pub fn value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(EnvVar::VT_VALUE, None)
    }
}

impl flatbuffers::Verifiable for EnvVar<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct EnvVarArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for EnvVarArgs<'a> {
    #[inline]
    fn default() -> Self {
        EnvVarArgs {
            name: None,
            value: None,
        }
    }
}

pub struct EnvVarBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EnvVarBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvVar::VT_NAME, name);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(EnvVar::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EnvVarBuilder<'a, 'b> {
        let start = _fbb.start_table();
        EnvVarBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<EnvVar<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for EnvVar<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("EnvVar");
        ds.field("name", &self.name());
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum FetchStepUrlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct FetchStepUrl<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepUrl<'a> {
    type Inner = FetchStepUrl<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FetchStepUrl<'a> {
    pub const VT_URL: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepUrl { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepUrlArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepUrl<'bldr>> {
        let mut builder = FetchStepUrlBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.url {
            builder.add_url(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn url(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepUrl::VT_URL, None)
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        self._tab
            .get::<EventTimeSource>(
                FetchStepUrl::VT_EVENT_TIME_TYPE,
                Some(EventTimeSource::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepUrl::VT_EVENT_TIME,
                None,
            )
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        self._tab
            .get::<SourceCaching>(FetchStepUrl::VT_CACHE_TYPE, Some(SourceCaching::NONE))
            .unwrap()
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepUrl::VT_CACHE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time()
                .map(EventTimeSourceFromMetadata::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time()
                .map(EventTimeSourceFromPath::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(SourceCachingForever::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepUrl<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct FetchStepUrlArgs<'a> {
    pub url: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FetchStepUrlArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepUrlArgs {
            url: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
        }
    }
}

pub struct FetchStepUrlBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepUrlBuilder<'a, 'b> {
    #[inline]
    pub fn add_url(&mut self, url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_URL, url);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepUrl::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepUrl::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepUrl::VT_CACHE, cache);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FetchStepUrlBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FetchStepUrlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepUrl<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepUrl<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepUrl");
        ds.field("url", &self.url());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.finish()
    }
}
pub enum FetchStepFilesGlobOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FetchStepFilesGlob<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepFilesGlob<'a> {
    type Inner = FetchStepFilesGlob<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FetchStepFilesGlob<'a> {
    pub const VT_PATH: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_CACHE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_CACHE: flatbuffers::VOffsetT = 12;
    pub const VT_ORDER: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepFilesGlob { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepFilesGlobArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'bldr>> {
        let mut builder = FetchStepFilesGlobBuilder::new(_fbb);
        if let Some(x) = args.order {
            builder.add_order(x);
        }
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.path {
            builder.add_path(x);
        }
        builder.add_cache_type(args.cache_type);
        builder.add_event_time_type(args.event_time_type);
        builder.finish()
    }

    #[inline]
    pub fn path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepFilesGlob::VT_PATH, None)
    }
    #[inline]
    pub fn event_time_type(&self) -> EventTimeSource {
        self._tab
            .get::<EventTimeSource>(
                FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
                Some(EventTimeSource::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn event_time(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepFilesGlob::VT_EVENT_TIME,
                None,
            )
    }
    #[inline]
    pub fn cache_type(&self) -> SourceCaching {
        self._tab
            .get::<SourceCaching>(FetchStepFilesGlob::VT_CACHE_TYPE, Some(SourceCaching::NONE))
            .unwrap()
    }
    #[inline]
    pub fn cache(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                FetchStepFilesGlob::VT_CACHE,
                None,
            )
    }
    #[inline]
    pub fn order(&self) -> Option<SourceOrdering> {
        self._tab
            .get::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_metadata(
        &self,
    ) -> Option<EventTimeSourceFromMetadata<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromMetadata {
            self.event_time()
                .map(EventTimeSourceFromMetadata::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_time_as_event_time_source_from_path(&self) -> Option<EventTimeSourceFromPath<'a>> {
        if self.event_time_type() == EventTimeSource::EventTimeSourceFromPath {
            self.event_time()
                .map(EventTimeSourceFromPath::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn cache_as_source_caching_forever(&self) -> Option<SourceCachingForever<'a>> {
        if self.cache_type() == SourceCaching::SourceCachingForever {
            self.cache().map(SourceCachingForever::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for FetchStepFilesGlob<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_union::<EventTimeSource, _>("event_time_type", Self::VT_EVENT_TIME_TYPE, "event_time", Self::VT_EVENT_TIME, false, |key, v, pos| {
        match key {
          EventTimeSource::EventTimeSourceFromMetadata => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromMetadata>>("EventTimeSource::EventTimeSourceFromMetadata", pos),
          EventTimeSource::EventTimeSourceFromPath => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EventTimeSourceFromPath>>("EventTimeSource::EventTimeSourceFromPath", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<SourceCaching, _>("cache_type", Self::VT_CACHE_TYPE, "cache", Self::VT_CACHE, false, |key, v, pos| {
        match key {
          SourceCaching::SourceCachingForever => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SourceCachingForever>>("SourceCaching::SourceCachingForever", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<SourceOrdering>("order", Self::VT_ORDER, false)?
     .finish();
        Ok(())
    }
}
pub struct FetchStepFilesGlobArgs<'a> {
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_type: EventTimeSource,
    pub event_time: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub cache_type: SourceCaching,
    pub cache: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub order: Option<SourceOrdering>,
}
impl<'a> Default for FetchStepFilesGlobArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepFilesGlobArgs {
            path: None,
            event_time_type: EventTimeSource::NONE,
            event_time: None,
            cache_type: SourceCaching::NONE,
            cache: None,
            order: None,
        }
    }
}

pub struct FetchStepFilesGlobBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepFilesGlobBuilder<'a, 'b> {
    #[inline]
    pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_PATH, path);
    }
    #[inline]
    pub fn add_event_time_type(&mut self, event_time_type: EventTimeSource) {
        self.fbb_.push_slot::<EventTimeSource>(
            FetchStepFilesGlob::VT_EVENT_TIME_TYPE,
            event_time_type,
            EventTimeSource::NONE,
        );
    }
    #[inline]
    pub fn add_event_time(
        &mut self,
        event_time: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            FetchStepFilesGlob::VT_EVENT_TIME,
            event_time,
        );
    }
    #[inline]
    pub fn add_cache_type(&mut self, cache_type: SourceCaching) {
        self.fbb_.push_slot::<SourceCaching>(
            FetchStepFilesGlob::VT_CACHE_TYPE,
            cache_type,
            SourceCaching::NONE,
        );
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepFilesGlob::VT_CACHE, cache);
    }
    #[inline]
    pub fn add_order(&mut self, order: SourceOrdering) {
        self.fbb_
            .push_slot_always::<SourceOrdering>(FetchStepFilesGlob::VT_ORDER, order);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> FetchStepFilesGlobBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FetchStepFilesGlobBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepFilesGlob<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepFilesGlob<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepFilesGlob");
        ds.field("path", &self.path());
        ds.field("event_time_type", &self.event_time_type());
        match self.event_time_type() {
            EventTimeSource::EventTimeSourceFromMetadata => {
                if let Some(x) = self.event_time_as_event_time_source_from_metadata() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            EventTimeSource::EventTimeSourceFromPath => {
                if let Some(x) = self.event_time_as_event_time_source_from_path() {
                    ds.field("event_time", &x)
                } else {
                    ds.field(
                        "event_time",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event_time", &x)
            }
        };
        ds.field("cache_type", &self.cache_type());
        match self.cache_type() {
            SourceCaching::SourceCachingForever => {
                if let Some(x) = self.cache_as_source_caching_forever() {
                    ds.field("cache", &x)
                } else {
                    ds.field(
                        "cache",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("cache", &x)
            }
        };
        ds.field("order", &self.order());
        ds.finish()
    }
}
pub enum FetchStepContainerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FetchStepContainer<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FetchStepContainer<'a> {
    type Inner = FetchStepContainer<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> FetchStepContainer<'a> {
    pub const VT_IMAGE: flatbuffers::VOffsetT = 4;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 6;
    pub const VT_ARGS: flatbuffers::VOffsetT = 8;
    pub const VT_ENV: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FetchStepContainer { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FetchStepContainerArgs<'args>,
    ) -> flatbuffers::WIPOffset<FetchStepContainer<'bldr>> {
        let mut builder = FetchStepContainerBuilder::new(_fbb);
        if let Some(x) = args.env {
            builder.add_env(x);
        }
        if let Some(x) = args.args {
            builder.add_args(x);
        }
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        if let Some(x) = args.image {
            builder.add_image(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn image(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(FetchStepContainer::VT_IMAGE, None)
    }
    #[inline]
    pub fn command(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(FetchStepContainer::VT_COMMAND, None)
    }
    #[inline]
    pub fn args(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(FetchStepContainer::VT_ARGS, None)
    }
    #[inline]
    pub fn env(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar>>,
        >>(FetchStepContainer::VT_ENV, None)
    }
}

impl flatbuffers::Verifiable for FetchStepContainer<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("command", Self::VT_COMMAND, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("args", Self::VT_ARGS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EnvVar>>,
            >>("env", Self::VT_ENV, false)?
            .finish();
        Ok(())
    }
}
pub struct FetchStepContainerArgs<'a> {
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub command: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub args: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub env: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EnvVar<'a>>>>,
    >,
}
impl<'a> Default for FetchStepContainerArgs<'a> {
    #[inline]
    fn default() -> Self {
        FetchStepContainerArgs {
            image: None,
            command: None,
            args: None,
            env: None,
        }
    }
}

pub struct FetchStepContainerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FetchStepContainerBuilder<'a, 'b> {
    #[inline]
    pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_IMAGE, image);
    }
    #[inline]
    pub fn add_command(
        &mut self,
        command: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_COMMAND, command);
    }
    #[inline]
    pub fn add_args(
        &mut self,
        args: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_ARGS, args);
    }
    #[inline]
    pub fn add_env(
        &mut self,
        env: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<EnvVar<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(FetchStepContainer::VT_ENV, env);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> FetchStepContainerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        FetchStepContainerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<FetchStepContainer<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for FetchStepContainer<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("FetchStepContainer");
        ds.field("image", &self.image());
        ds.field("command", &self.command());
        ds.field("args", &self.args());
        ds.field("env", &self.env());
        ds.finish()
    }
}
pub enum PrepStepDecompressOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepStepDecompress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepDecompress<'a> {
    type Inner = PrepStepDecompress<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepDecompress<'a> {
    pub const VT_FORMAT: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepDecompress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepDecompressArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepDecompress<'bldr>> {
        let mut builder = PrepStepDecompressBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        builder.add_format(args.format);
        builder.finish()
    }

    #[inline]
    pub fn format(&self) -> CompressionFormat {
        self._tab
            .get::<CompressionFormat>(PrepStepDecompress::VT_FORMAT, Some(CompressionFormat::Gzip))
            .unwrap()
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(PrepStepDecompress::VT_SUB_PATH, None)
    }
}

impl flatbuffers::Verifiable for PrepStepDecompress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<CompressionFormat>("format", Self::VT_FORMAT, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepDecompressArgs<'a> {
    pub format: CompressionFormat,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for PrepStepDecompressArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepDecompressArgs {
            format: CompressionFormat::Gzip,
            sub_path: None,
        }
    }
}

pub struct PrepStepDecompressBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepDecompressBuilder<'a, 'b> {
    #[inline]
    pub fn add_format(&mut self, format: CompressionFormat) {
        self.fbb_.push_slot::<CompressionFormat>(
            PrepStepDecompress::VT_FORMAT,
            format,
            CompressionFormat::Gzip,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            PrepStepDecompress::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> PrepStepDecompressBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepDecompressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepDecompress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepDecompress<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepDecompress");
        ds.field("format", &self.format());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum PrepStepPipeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrepStepPipe<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepPipe<'a> {
    type Inner = PrepStepPipe<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepPipe<'a> {
    pub const VT_COMMAND: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepPipe { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepPipeArgs<'args>,
    ) -> flatbuffers::WIPOffset<PrepStepPipe<'bldr>> {
        let mut builder = PrepStepPipeBuilder::new(_fbb);
        if let Some(x) = args.command {
            builder.add_command(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn command(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(PrepStepPipe::VT_COMMAND, None)
    }
}

impl flatbuffers::Verifiable for PrepStepPipe<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("command", Self::VT_COMMAND, false)?
            .finish();
        Ok(())
    }
}
pub struct PrepStepPipeArgs<'a> {
    pub command: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for PrepStepPipeArgs<'a> {
    #[inline]
    fn default() -> Self {
        PrepStepPipeArgs { command: None }
    }
}

pub struct PrepStepPipeBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepPipeBuilder<'a, 'b> {
    #[inline]
    pub fn add_command(
        &mut self,
        command: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepPipe::VT_COMMAND, command);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepPipeBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepPipeBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepPipe<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepPipe<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepPipe");
        ds.field("command", &self.command());
        ds.finish()
    }
}
pub enum ReadStepCsvOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ReadStepCsv<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepCsv<'a> {
    type Inner = ReadStepCsv<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepCsv<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SEPARATOR: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_QUOTE: flatbuffers::VOffsetT = 10;
    pub const VT_ESCAPE: flatbuffers::VOffsetT = 12;
    pub const VT_COMMENT: flatbuffers::VOffsetT = 14;
    pub const VT_HEADER: flatbuffers::VOffsetT = 16;
    pub const VT_ENFORCE_SCHEMA: flatbuffers::VOffsetT = 18;
    pub const VT_INFER_SCHEMA: flatbuffers::VOffsetT = 20;
    pub const VT_IGNORE_LEADING_WHITE_SPACE: flatbuffers::VOffsetT = 22;
    pub const VT_IGNORE_TRAILING_WHITE_SPACE: flatbuffers::VOffsetT = 24;
    pub const VT_NULL_VALUE: flatbuffers::VOffsetT = 26;
    pub const VT_EMPTY_VALUE: flatbuffers::VOffsetT = 28;
    pub const VT_NAN_VALUE: flatbuffers::VOffsetT = 30;
    pub const VT_POSITIVE_INF: flatbuffers::VOffsetT = 32;
    pub const VT_NEGATIVE_INF: flatbuffers::VOffsetT = 34;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 36;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 38;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 40;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepCsv { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepCsvArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepCsv<'bldr>> {
        let mut builder = ReadStepCsvBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.negative_inf {
            builder.add_negative_inf(x);
        }
        if let Some(x) = args.positive_inf {
            builder.add_positive_inf(x);
        }
        if let Some(x) = args.nan_value {
            builder.add_nan_value(x);
        }
        if let Some(x) = args.empty_value {
            builder.add_empty_value(x);
        }
        if let Some(x) = args.null_value {
            builder.add_null_value(x);
        }
        if let Some(x) = args.comment {
            builder.add_comment(x);
        }
        if let Some(x) = args.escape {
            builder.add_escape(x);
        }
        if let Some(x) = args.quote {
            builder.add_quote(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.separator {
            builder.add_separator(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.multi_line {
            builder.add_multi_line(x);
        }
        if let Some(x) = args.ignore_trailing_white_space {
            builder.add_ignore_trailing_white_space(x);
        }
        if let Some(x) = args.ignore_leading_white_space {
            builder.add_ignore_leading_white_space(x);
        }
        if let Some(x) = args.infer_schema {
            builder.add_infer_schema(x);
        }
        if let Some(x) = args.enforce_schema {
            builder.add_enforce_schema(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepCsv::VT_SCHEMA, None)
    }
    #[inline]
    pub fn separator(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_SEPARATOR, None)
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ENCODING, None)
    }
    #[inline]
    pub fn quote(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_QUOTE, None)
    }
    #[inline]
    pub fn escape(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_ESCAPE, None)
    }
    #[inline]
    pub fn comment(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_COMMENT, None)
    }
    #[inline]
    pub fn header(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_HEADER, None)
    }
    #[inline]
    pub fn enforce_schema(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, None)
    }
    #[inline]
    pub fn infer_schema(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_INFER_SCHEMA, None)
    }
    #[inline]
    pub fn ignore_leading_white_space(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE, None)
    }
    #[inline]
    pub fn ignore_trailing_white_space(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE, None)
    }
    #[inline]
    pub fn null_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NULL_VALUE, None)
    }
    #[inline]
    pub fn empty_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_EMPTY_VALUE, None)
    }
    #[inline]
    pub fn nan_value(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NAN_VALUE, None)
    }
    #[inline]
    pub fn positive_inf(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_POSITIVE_INF, None)
    }
    #[inline]
    pub fn negative_inf(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_NEGATIVE_INF, None)
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_DATE_FORMAT, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepCsv::VT_TIMESTAMP_FORMAT, None)
    }
    #[inline]
    pub fn multi_line(&self) -> Option<bool> {
        self._tab.get::<bool>(ReadStepCsv::VT_MULTI_LINE, None)
    }
}

impl flatbuffers::Verifiable for ReadStepCsv<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "separator",
                Self::VT_SEPARATOR,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("quote", Self::VT_QUOTE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("escape", Self::VT_ESCAPE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("comment", Self::VT_COMMENT, false)?
            .visit_field::<bool>("header", Self::VT_HEADER, false)?
            .visit_field::<bool>("enforce_schema", Self::VT_ENFORCE_SCHEMA, false)?
            .visit_field::<bool>("infer_schema", Self::VT_INFER_SCHEMA, false)?
            .visit_field::<bool>(
                "ignore_leading_white_space",
                Self::VT_IGNORE_LEADING_WHITE_SPACE,
                false,
            )?
            .visit_field::<bool>(
                "ignore_trailing_white_space",
                Self::VT_IGNORE_TRAILING_WHITE_SPACE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "null_value",
                Self::VT_NULL_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "empty_value",
                Self::VT_EMPTY_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "nan_value",
                Self::VT_NAN_VALUE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "positive_inf",
                Self::VT_POSITIVE_INF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "negative_inf",
                Self::VT_NEGATIVE_INF,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .visit_field::<bool>("multi_line", Self::VT_MULTI_LINE, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepCsvArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub separator: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quote: Option<flatbuffers::WIPOffset<&'a str>>,
    pub escape: Option<flatbuffers::WIPOffset<&'a str>>,
    pub comment: Option<flatbuffers::WIPOffset<&'a str>>,
    pub header: Option<bool>,
    pub enforce_schema: Option<bool>,
    pub infer_schema: Option<bool>,
    pub ignore_leading_white_space: Option<bool>,
    pub ignore_trailing_white_space: Option<bool>,
    pub null_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub empty_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nan_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub positive_inf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub negative_inf: Option<flatbuffers::WIPOffset<&'a str>>,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multi_line: Option<bool>,
}
impl<'a> Default for ReadStepCsvArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepCsvArgs {
            schema: None,
            separator: None,
            encoding: None,
            quote: None,
            escape: None,
            comment: None,
            header: None,
            enforce_schema: None,
            infer_schema: None,
            ignore_leading_white_space: None,
            ignore_trailing_white_space: None,
            null_value: None,
            empty_value: None,
            nan_value: None,
            positive_inf: None,
            negative_inf: None,
            date_format: None,
            timestamp_format: None,
            multi_line: None,
        }
    }
}

pub struct ReadStepCsvBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepCsvBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_separator(&mut self, separator: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_SEPARATOR, separator);
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ENCODING, encoding);
    }
    #[inline]
    pub fn add_quote(&mut self, quote: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_QUOTE, quote);
    }
    #[inline]
    pub fn add_escape(&mut self, escape: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_ESCAPE, escape);
    }
    #[inline]
    pub fn add_comment(&mut self, comment: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_COMMENT, comment);
    }
    #[inline]
    pub fn add_header(&mut self, header: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_HEADER, header);
    }
    #[inline]
    pub fn add_enforce_schema(&mut self, enforce_schema: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_ENFORCE_SCHEMA, enforce_schema);
    }
    #[inline]
    pub fn add_infer_schema(&mut self, infer_schema: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_INFER_SCHEMA, infer_schema);
    }
    #[inline]
    pub fn add_ignore_leading_white_space(&mut self, ignore_leading_white_space: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepCsv::VT_IGNORE_LEADING_WHITE_SPACE,
            ignore_leading_white_space,
        );
    }
    #[inline]
    pub fn add_ignore_trailing_white_space(&mut self, ignore_trailing_white_space: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepCsv::VT_IGNORE_TRAILING_WHITE_SPACE,
            ignore_trailing_white_space,
        );
    }
    #[inline]
    pub fn add_null_value(&mut self, null_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NULL_VALUE, null_value);
    }
    #[inline]
    pub fn add_empty_value(&mut self, empty_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_EMPTY_VALUE,
            empty_value,
        );
    }
    #[inline]
    pub fn add_nan_value(&mut self, nan_value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepCsv::VT_NAN_VALUE, nan_value);
    }
    #[inline]
    pub fn add_positive_inf(&mut self, positive_inf: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_POSITIVE_INF,
            positive_inf,
        );
    }
    #[inline]
    pub fn add_negative_inf(&mut self, negative_inf: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_NEGATIVE_INF,
            negative_inf,
        );
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepCsv::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn add_multi_line(&mut self, multi_line: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepCsv::VT_MULTI_LINE, multi_line);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepCsvBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepCsvBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepCsv<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepCsv<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepCsv");
        ds.field("schema", &self.schema());
        ds.field("separator", &self.separator());
        ds.field("encoding", &self.encoding());
        ds.field("quote", &self.quote());
        ds.field("escape", &self.escape());
        ds.field("comment", &self.comment());
        ds.field("header", &self.header());
        ds.field("enforce_schema", &self.enforce_schema());
        ds.field("infer_schema", &self.infer_schema());
        ds.field(
            "ignore_leading_white_space",
            &self.ignore_leading_white_space(),
        );
        ds.field(
            "ignore_trailing_white_space",
            &self.ignore_trailing_white_space(),
        );
        ds.field("null_value", &self.null_value());
        ds.field("empty_value", &self.empty_value());
        ds.field("nan_value", &self.nan_value());
        ds.field("positive_inf", &self.positive_inf());
        ds.field("negative_inf", &self.negative_inf());
        ds.field("date_format", &self.date_format());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.field("multi_line", &self.multi_line());
        ds.finish()
    }
}
pub enum ReadStepJsonLinesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepJsonLines<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepJsonLines<'a> {
    type Inner = ReadStepJsonLines<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepJsonLines<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_DATE_FORMAT: flatbuffers::VOffsetT = 6;
    pub const VT_ENCODING: flatbuffers::VOffsetT = 8;
    pub const VT_MULTI_LINE: flatbuffers::VOffsetT = 10;
    pub const VT_PRIMITIVES_AS_STRING: flatbuffers::VOffsetT = 12;
    pub const VT_TIMESTAMP_FORMAT: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepJsonLines { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepJsonLinesArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepJsonLines<'bldr>> {
        let mut builder = ReadStepJsonLinesBuilder::new(_fbb);
        if let Some(x) = args.timestamp_format {
            builder.add_timestamp_format(x);
        }
        if let Some(x) = args.encoding {
            builder.add_encoding(x);
        }
        if let Some(x) = args.date_format {
            builder.add_date_format(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        if let Some(x) = args.primitives_as_string {
            builder.add_primitives_as_string(x);
        }
        if let Some(x) = args.multi_line {
            builder.add_multi_line(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepJsonLines::VT_SCHEMA, None)
    }
    #[inline]
    pub fn date_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_DATE_FORMAT, None)
    }
    #[inline]
    pub fn encoding(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_ENCODING, None)
    }
    #[inline]
    pub fn multi_line(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepJsonLines::VT_MULTI_LINE, None)
    }
    #[inline]
    pub fn primitives_as_string(&self) -> Option<bool> {
        self._tab
            .get::<bool>(ReadStepJsonLines::VT_PRIMITIVES_AS_STRING, None)
    }
    #[inline]
    pub fn timestamp_format(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepJsonLines::VT_TIMESTAMP_FORMAT, None)
    }
}

impl flatbuffers::Verifiable for ReadStepJsonLines<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "date_format",
                Self::VT_DATE_FORMAT,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "encoding",
                Self::VT_ENCODING,
                false,
            )?
            .visit_field::<bool>("multi_line", Self::VT_MULTI_LINE, false)?
            .visit_field::<bool>("primitives_as_string", Self::VT_PRIMITIVES_AS_STRING, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "timestamp_format",
                Self::VT_TIMESTAMP_FORMAT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepJsonLinesArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub date_format: Option<flatbuffers::WIPOffset<&'a str>>,
    pub encoding: Option<flatbuffers::WIPOffset<&'a str>>,
    pub multi_line: Option<bool>,
    pub primitives_as_string: Option<bool>,
    pub timestamp_format: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepJsonLinesArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepJsonLinesArgs {
            schema: None,
            date_format: None,
            encoding: None,
            multi_line: None,
            primitives_as_string: None,
            timestamp_format: None,
        }
    }
}

pub struct ReadStepJsonLinesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepJsonLinesBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepJsonLines::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn add_date_format(&mut self, date_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_DATE_FORMAT,
            date_format,
        );
    }
    #[inline]
    pub fn add_encoding(&mut self, encoding: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_ENCODING,
            encoding,
        );
    }
    #[inline]
    pub fn add_multi_line(&mut self, multi_line: bool) {
        self.fbb_
            .push_slot_always::<bool>(ReadStepJsonLines::VT_MULTI_LINE, multi_line);
    }
    #[inline]
    pub fn add_primitives_as_string(&mut self, primitives_as_string: bool) {
        self.fbb_.push_slot_always::<bool>(
            ReadStepJsonLines::VT_PRIMITIVES_AS_STRING,
            primitives_as_string,
        );
    }
    #[inline]
    pub fn add_timestamp_format(&mut self, timestamp_format: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepJsonLines::VT_TIMESTAMP_FORMAT,
            timestamp_format,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ReadStepJsonLinesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepJsonLinesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepJsonLines<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepJsonLines<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepJsonLines");
        ds.field("schema", &self.schema());
        ds.field("date_format", &self.date_format());
        ds.field("encoding", &self.encoding());
        ds.field("multi_line", &self.multi_line());
        ds.field("primitives_as_string", &self.primitives_as_string());
        ds.field("timestamp_format", &self.timestamp_format());
        ds.finish()
    }
}
pub enum ReadStepGeoJsonOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepGeoJson<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepGeoJson<'a> {
    type Inner = ReadStepGeoJson<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepGeoJson<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepGeoJson { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepGeoJsonArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepGeoJson<'bldr>> {
        let mut builder = ReadStepGeoJsonBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepGeoJson::VT_SCHEMA, None)
    }
}

impl flatbuffers::Verifiable for ReadStepGeoJson<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepGeoJsonArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepGeoJsonArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepGeoJsonArgs { schema: None }
    }
}

pub struct ReadStepGeoJsonBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepGeoJsonBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepGeoJson::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepGeoJsonBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepGeoJsonBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepGeoJson<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepGeoJson<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepGeoJson");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum ReadStepEsriShapefileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepEsriShapefile<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepEsriShapefile<'a> {
    type Inner = ReadStepEsriShapefile<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepEsriShapefile<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_SUB_PATH: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepEsriShapefile { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepEsriShapefileArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'bldr>> {
        let mut builder = ReadStepEsriShapefileBuilder::new(_fbb);
        if let Some(x) = args.sub_path {
            builder.add_sub_path(x);
        }
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepEsriShapefile::VT_SCHEMA, None)
    }
    #[inline]
    pub fn sub_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ReadStepEsriShapefile::VT_SUB_PATH, None)
    }
}

impl flatbuffers::Verifiable for ReadStepEsriShapefile<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "sub_path",
                Self::VT_SUB_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ReadStepEsriShapefileArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub sub_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ReadStepEsriShapefileArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepEsriShapefileArgs {
            schema: None,
            sub_path: None,
        }
    }
}

pub struct ReadStepEsriShapefileBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepEsriShapefileBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SCHEMA,
            schema,
        );
    }
    #[inline]
    pub fn add_sub_path(&mut self, sub_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ReadStepEsriShapefile::VT_SUB_PATH,
            sub_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ReadStepEsriShapefileBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepEsriShapefileBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepEsriShapefile<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepEsriShapefile<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepEsriShapefile");
        ds.field("schema", &self.schema());
        ds.field("sub_path", &self.sub_path());
        ds.finish()
    }
}
pub enum ReadStepParquetOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReadStepParquet<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReadStepParquet<'a> {
    type Inner = ReadStepParquet<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ReadStepParquet<'a> {
    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReadStepParquet { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReadStepParquetArgs<'args>,
    ) -> flatbuffers::WIPOffset<ReadStepParquet<'bldr>> {
        let mut builder = ReadStepParquetBuilder::new(_fbb);
        if let Some(x) = args.schema {
            builder.add_schema(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn schema(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ReadStepParquet::VT_SCHEMA, None)
    }
}

impl flatbuffers::Verifiable for ReadStepParquet<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("schema", Self::VT_SCHEMA, false)?
            .finish();
        Ok(())
    }
}
pub struct ReadStepParquetArgs<'a> {
    pub schema: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for ReadStepParquetArgs<'a> {
    #[inline]
    fn default() -> Self {
        ReadStepParquetArgs { schema: None }
    }
}

pub struct ReadStepParquetBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReadStepParquetBuilder<'a, 'b> {
    #[inline]
    pub fn add_schema(
        &mut self,
        schema: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReadStepParquet::VT_SCHEMA, schema);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReadStepParquetBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReadStepParquetBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReadStepParquet<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReadStepParquet<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReadStepParquet");
        ds.field("schema", &self.schema());
        ds.finish()
    }
}
pub enum SqlQueryStepOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SqlQueryStep<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqlQueryStep<'a> {
    type Inner = SqlQueryStep<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SqlQueryStep<'a> {
    pub const VT_ALIAS: flatbuffers::VOffsetT = 4;
    pub const VT_QUERY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SqlQueryStep { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SqlQueryStepArgs<'args>,
    ) -> flatbuffers::WIPOffset<SqlQueryStep<'bldr>> {
        let mut builder = SqlQueryStepBuilder::new(_fbb);
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.alias {
            builder.add_alias(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn alias(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_ALIAS, None)
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SqlQueryStep::VT_QUERY, None)
    }
}

impl flatbuffers::Verifiable for SqlQueryStep<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("alias", Self::VT_ALIAS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .finish();
        Ok(())
    }
}
pub struct SqlQueryStepArgs<'a> {
    pub alias: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SqlQueryStepArgs<'a> {
    #[inline]
    fn default() -> Self {
        SqlQueryStepArgs {
            alias: None,
            query: None,
        }
    }
}

pub struct SqlQueryStepBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqlQueryStepBuilder<'a, 'b> {
    #[inline]
    pub fn add_alias(&mut self, alias: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_ALIAS, alias);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SqlQueryStep::VT_QUERY, query);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqlQueryStepBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SqlQueryStepBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SqlQueryStep<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SqlQueryStep<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SqlQueryStep");
        ds.field("alias", &self.alias());
        ds.field("query", &self.query());
        ds.finish()
    }
}
pub enum TemporalTableOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TemporalTable<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TemporalTable<'a> {
    type Inner = TemporalTable<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TemporalTable<'a> {
    pub const VT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TemporalTable { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TemporalTableArgs<'args>,
    ) -> flatbuffers::WIPOffset<TemporalTable<'bldr>> {
        let mut builder = TemporalTableBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TemporalTable::VT_NAME, None)
    }
    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(TemporalTable::VT_PRIMARY_KEY, None)
    }
}

impl flatbuffers::Verifiable for TemporalTable<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct TemporalTableArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for TemporalTableArgs<'a> {
    #[inline]
    fn default() -> Self {
        TemporalTableArgs {
            name: None,
            primary_key: None,
        }
    }
}

pub struct TemporalTableBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TemporalTableBuilder<'a, 'b> {
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TemporalTable::VT_NAME, name);
    }
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TemporalTable::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TemporalTableBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TemporalTableBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TemporalTable<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TemporalTable<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TemporalTable");
        ds.field("name", &self.name());
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum TransformSqlOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TransformSql<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformSql<'a> {
    type Inner = TransformSql<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TransformSql<'a> {
    pub const VT_ENGINE: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_QUERY: flatbuffers::VOffsetT = 8;
    pub const VT_QUERIES: flatbuffers::VOffsetT = 10;
    pub const VT_TEMPORAL_TABLES: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformSql { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransformSqlArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformSql<'bldr>> {
        let mut builder = TransformSqlBuilder::new(_fbb);
        if let Some(x) = args.temporal_tables {
            builder.add_temporal_tables(x);
        }
        if let Some(x) = args.queries {
            builder.add_queries(x);
        }
        if let Some(x) = args.query {
            builder.add_query(x);
        }
        if let Some(x) = args.version {
            builder.add_version(x);
        }
        if let Some(x) = args.engine {
            builder.add_engine(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn engine(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_ENGINE, None)
    }
    #[inline]
    pub fn version(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_VERSION, None)
    }
    #[inline]
    pub fn query(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformSql::VT_QUERY, None)
    }
    #[inline]
    pub fn queries(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
        >>(TransformSql::VT_QUERIES, None)
    }
    #[inline]
    pub fn temporal_tables(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable>>,
        >>(TransformSql::VT_TEMPORAL_TABLES, None)
    }
}

impl flatbuffers::Verifiable for TransformSql<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("engine", Self::VT_ENGINE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SqlQueryStep>>,
            >>("queries", Self::VT_QUERIES, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TemporalTable>>,
            >>("temporal_tables", Self::VT_TEMPORAL_TABLES, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformSqlArgs<'a> {
    pub engine: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub queries: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SqlQueryStep<'a>>>,
        >,
    >,
    pub temporal_tables: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TemporalTable<'a>>>,
        >,
    >,
}
impl<'a> Default for TransformSqlArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformSqlArgs {
            engine: None,
            version: None,
            query: None,
            queries: None,
            temporal_tables: None,
        }
    }
}

pub struct TransformSqlBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformSqlBuilder<'a, 'b> {
    #[inline]
    pub fn add_engine(&mut self, engine: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_ENGINE, engine);
    }
    #[inline]
    pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_VERSION, version);
    }
    #[inline]
    pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERY, query);
    }
    #[inline]
    pub fn add_queries(
        &mut self,
        queries: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<SqlQueryStep<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformSql::VT_QUERIES, queries);
    }
    #[inline]
    pub fn add_temporal_tables(
        &mut self,
        temporal_tables: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TemporalTable<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            TransformSql::VT_TEMPORAL_TABLES,
            temporal_tables,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformSqlBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransformSqlBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformSql<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformSql<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformSql");
        ds.field("engine", &self.engine());
        ds.field("version", &self.version());
        ds.field("query", &self.query());
        ds.field("queries", &self.queries());
        ds.field("temporal_tables", &self.temporal_tables());
        ds.finish()
    }
}
pub enum MergeStrategyAppendOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MergeStrategyAppend<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyAppend<'a> {
    type Inner = MergeStrategyAppend<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategyAppend<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyAppend { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args MergeStrategyAppendArgs,
    ) -> flatbuffers::WIPOffset<MergeStrategyAppend<'bldr>> {
        let mut builder = MergeStrategyAppendBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for MergeStrategyAppend<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct MergeStrategyAppendArgs {}
impl<'a> Default for MergeStrategyAppendArgs {
    #[inline]
    fn default() -> Self {
        MergeStrategyAppendArgs {}
    }
}

pub struct MergeStrategyAppendBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyAppendBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategyAppendBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategyAppendBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyAppend<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategyAppend<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyAppend");
        ds.finish()
    }
}
pub enum MergeStrategyLedgerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MergeStrategyLedger<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategyLedger<'a> {
    type Inner = MergeStrategyLedger<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategyLedger<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategyLedger { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategyLedgerArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategyLedger<'bldr>> {
        let mut builder = MergeStrategyLedgerBuilder::new(_fbb);
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategyLedger::VT_PRIMARY_KEY, None)
    }
}

impl flatbuffers::Verifiable for MergeStrategyLedger<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategyLedgerArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for MergeStrategyLedgerArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategyLedgerArgs { primary_key: None }
    }
}

pub struct MergeStrategyLedgerBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategyLedgerBuilder<'a, 'b> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategyLedger::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategyLedgerBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategyLedgerBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategyLedger<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategyLedger<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategyLedger");
        ds.field("primary_key", &self.primary_key());
        ds.finish()
    }
}
pub enum MergeStrategySnapshotOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MergeStrategySnapshot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MergeStrategySnapshot<'a> {
    type Inner = MergeStrategySnapshot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MergeStrategySnapshot<'a> {
    pub const VT_PRIMARY_KEY: flatbuffers::VOffsetT = 4;
    pub const VT_COMPARE_COLUMNS: flatbuffers::VOffsetT = 6;
    pub const VT_OBSERVATION_COLUMN: flatbuffers::VOffsetT = 8;
    pub const VT_OBSV_ADDED: flatbuffers::VOffsetT = 10;
    pub const VT_OBSV_CHANGED: flatbuffers::VOffsetT = 12;
    pub const VT_OBSV_REMOVED: flatbuffers::VOffsetT = 14;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MergeStrategySnapshot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MergeStrategySnapshotArgs<'args>,
    ) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'bldr>> {
        let mut builder = MergeStrategySnapshotBuilder::new(_fbb);
        if let Some(x) = args.obsv_removed {
            builder.add_obsv_removed(x);
        }
        if let Some(x) = args.obsv_changed {
            builder.add_obsv_changed(x);
        }
        if let Some(x) = args.obsv_added {
            builder.add_obsv_added(x);
        }
        if let Some(x) = args.observation_column {
            builder.add_observation_column(x);
        }
        if let Some(x) = args.compare_columns {
            builder.add_compare_columns(x);
        }
        if let Some(x) = args.primary_key {
            builder.add_primary_key(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn primary_key(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategySnapshot::VT_PRIMARY_KEY, None)
    }
    #[inline]
    pub fn compare_columns(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(MergeStrategySnapshot::VT_COMPARE_COLUMNS, None)
    }
    #[inline]
    pub fn observation_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            MergeStrategySnapshot::VT_OBSERVATION_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn obsv_added(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_ADDED, None)
    }
    #[inline]
    pub fn obsv_changed(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_CHANGED, None)
    }
    #[inline]
    pub fn obsv_removed(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(MergeStrategySnapshot::VT_OBSV_REMOVED, None)
    }
}

impl flatbuffers::Verifiable for MergeStrategySnapshot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("primary_key", Self::VT_PRIMARY_KEY, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("compare_columns", Self::VT_COMPARE_COLUMNS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "observation_column",
                Self::VT_OBSERVATION_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_added",
                Self::VT_OBSV_ADDED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_changed",
                Self::VT_OBSV_CHANGED,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "obsv_removed",
                Self::VT_OBSV_REMOVED,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct MergeStrategySnapshotArgs<'a> {
    pub primary_key: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub compare_columns: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub observation_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_added: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_changed: Option<flatbuffers::WIPOffset<&'a str>>,
    pub obsv_removed: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MergeStrategySnapshotArgs<'a> {
    #[inline]
    fn default() -> Self {
        MergeStrategySnapshotArgs {
            primary_key: None,
            compare_columns: None,
            observation_column: None,
            obsv_added: None,
            obsv_changed: None,
            obsv_removed: None,
        }
    }
}

pub struct MergeStrategySnapshotBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MergeStrategySnapshotBuilder<'a, 'b> {
    #[inline]
    pub fn add_primary_key(
        &mut self,
        primary_key: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_PRIMARY_KEY,
            primary_key,
        );
    }
    #[inline]
    pub fn add_compare_columns(
        &mut self,
        compare_columns: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_COMPARE_COLUMNS,
            compare_columns,
        );
    }
    #[inline]
    pub fn add_observation_column(&mut self, observation_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSERVATION_COLUMN,
            observation_column,
        );
    }
    #[inline]
    pub fn add_obsv_added(&mut self, obsv_added: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_ADDED,
            obsv_added,
        );
    }
    #[inline]
    pub fn add_obsv_changed(&mut self, obsv_changed: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_CHANGED,
            obsv_changed,
        );
    }
    #[inline]
    pub fn add_obsv_removed(&mut self, obsv_removed: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MergeStrategySnapshot::VT_OBSV_REMOVED,
            obsv_removed,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> MergeStrategySnapshotBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MergeStrategySnapshotBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MergeStrategySnapshot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MergeStrategySnapshot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MergeStrategySnapshot");
        ds.field("primary_key", &self.primary_key());
        ds.field("compare_columns", &self.compare_columns());
        ds.field("observation_column", &self.observation_column());
        ds.field("obsv_added", &self.obsv_added());
        ds.field("obsv_changed", &self.obsv_changed());
        ds.field("obsv_removed", &self.obsv_removed());
        ds.finish()
    }
}
pub enum PrepStepWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct PrepStepWrapper<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrepStepWrapper<'a> {
    type Inner = PrepStepWrapper<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> PrepStepWrapper<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PrepStepWrapper { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PrepStepWrapperArgs,
    ) -> flatbuffers::WIPOffset<PrepStepWrapper<'bldr>> {
        let mut builder = PrepStepWrapperBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> PrepStep {
        self._tab
            .get::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, Some(PrepStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                PrepStepWrapper::VT_VALUE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_decompress(&self) -> Option<PrepStepDecompress<'a>> {
        if self.value_type() == PrepStep::PrepStepDecompress {
            self.value().map(PrepStepDecompress::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_prep_step_pipe(&self) -> Option<PrepStepPipe<'a>> {
        if self.value_type() == PrepStep::PrepStepPipe {
            self.value().map(PrepStepPipe::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for PrepStepWrapper<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<PrepStep, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    PrepStep::PrepStepDecompress => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepDecompress>>(
                            "PrepStep::PrepStepDecompress",
                            pos,
                        ),
                    PrepStep::PrepStepPipe => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PrepStepPipe>>(
                            "PrepStep::PrepStepPipe",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct PrepStepWrapperArgs {
    pub value_type: PrepStep,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PrepStepWrapperArgs {
    #[inline]
    fn default() -> Self {
        PrepStepWrapperArgs {
            value_type: PrepStep::NONE,
            value: None,
        }
    }
}

pub struct PrepStepWrapperBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrepStepWrapperBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: PrepStep) {
        self.fbb_
            .push_slot::<PrepStep>(PrepStepWrapper::VT_VALUE_TYPE, value_type, PrepStep::NONE);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PrepStepWrapper::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrepStepWrapperBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PrepStepWrapperBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PrepStepWrapper<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PrepStepWrapper<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PrepStepWrapper");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            PrepStep::PrepStepDecompress => {
                if let Some(x) = self.value_as_prep_step_decompress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            PrepStep::PrepStepPipe => {
                if let Some(x) = self.value_as_prep_step_pipe() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetPollingSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SetPollingSource<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetPollingSource<'a> {
    type Inner = SetPollingSource<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetPollingSource<'a> {
    pub const VT_FETCH_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FETCH: flatbuffers::VOffsetT = 6;
    pub const VT_PREPARE: flatbuffers::VOffsetT = 8;
    pub const VT_READ_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_READ: flatbuffers::VOffsetT = 12;
    pub const VT_PREPROCESS_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_PREPROCESS: flatbuffers::VOffsetT = 16;
    pub const VT_MERGE_TYPE: flatbuffers::VOffsetT = 18;
    pub const VT_MERGE: flatbuffers::VOffsetT = 20;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetPollingSource { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetPollingSourceArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetPollingSource<'bldr>> {
        let mut builder = SetPollingSourceBuilder::new(_fbb);
        if let Some(x) = args.merge {
            builder.add_merge(x);
        }
        if let Some(x) = args.preprocess {
            builder.add_preprocess(x);
        }
        if let Some(x) = args.read {
            builder.add_read(x);
        }
        if let Some(x) = args.prepare {
            builder.add_prepare(x);
        }
        if let Some(x) = args.fetch {
            builder.add_fetch(x);
        }
        builder.add_merge_type(args.merge_type);
        builder.add_preprocess_type(args.preprocess_type);
        builder.add_read_type(args.read_type);
        builder.add_fetch_type(args.fetch_type);
        builder.finish()
    }

    #[inline]
    pub fn fetch_type(&self) -> FetchStep {
        self._tab
            .get::<FetchStep>(SetPollingSource::VT_FETCH_TYPE, Some(FetchStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn fetch(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetPollingSource::VT_FETCH,
                None,
            )
    }
    #[inline]
    pub fn prepare(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper>>,
        >>(SetPollingSource::VT_PREPARE, None)
    }
    #[inline]
    pub fn read_type(&self) -> ReadStep {
        self._tab
            .get::<ReadStep>(SetPollingSource::VT_READ_TYPE, Some(ReadStep::NONE))
            .unwrap()
    }
    #[inline]
    pub fn read(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetPollingSource::VT_READ,
                None,
            )
    }
    #[inline]
    pub fn preprocess_type(&self) -> Transform {
        self._tab
            .get::<Transform>(SetPollingSource::VT_PREPROCESS_TYPE, Some(Transform::NONE))
            .unwrap()
    }
    #[inline]
    pub fn preprocess(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetPollingSource::VT_PREPROCESS,
                None,
            )
    }
    #[inline]
    pub fn merge_type(&self) -> MergeStrategy {
        self._tab
            .get::<MergeStrategy>(SetPollingSource::VT_MERGE_TYPE, Some(MergeStrategy::NONE))
            .unwrap()
    }
    #[inline]
    pub fn merge(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetPollingSource::VT_MERGE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_url(&self) -> Option<FetchStepUrl<'a>> {
        if self.fetch_type() == FetchStep::FetchStepUrl {
            self.fetch().map(FetchStepUrl::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_files_glob(&self) -> Option<FetchStepFilesGlob<'a>> {
        if self.fetch_type() == FetchStep::FetchStepFilesGlob {
            self.fetch().map(FetchStepFilesGlob::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn fetch_as_fetch_step_container(&self) -> Option<FetchStepContainer<'a>> {
        if self.fetch_type() == FetchStep::FetchStepContainer {
            self.fetch().map(FetchStepContainer::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_csv(&self) -> Option<ReadStepCsv<'a>> {
        if self.read_type() == ReadStep::ReadStepCsv {
            self.read().map(ReadStepCsv::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_json_lines(&self) -> Option<ReadStepJsonLines<'a>> {
        if self.read_type() == ReadStep::ReadStepJsonLines {
            self.read().map(ReadStepJsonLines::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_geo_json(&self) -> Option<ReadStepGeoJson<'a>> {
        if self.read_type() == ReadStep::ReadStepGeoJson {
            self.read().map(ReadStepGeoJson::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_esri_shapefile(&self) -> Option<ReadStepEsriShapefile<'a>> {
        if self.read_type() == ReadStep::ReadStepEsriShapefile {
            self.read().map(ReadStepEsriShapefile::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn read_as_read_step_parquet(&self) -> Option<ReadStepParquet<'a>> {
        if self.read_type() == ReadStep::ReadStepParquet {
            self.read().map(ReadStepParquet::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn preprocess_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.preprocess_type() == Transform::TransformSql {
            self.preprocess().map(TransformSql::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_append(&self) -> Option<MergeStrategyAppend<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyAppend {
            self.merge().map(MergeStrategyAppend::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_ledger(&self) -> Option<MergeStrategyLedger<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategyLedger {
            self.merge().map(MergeStrategyLedger::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn merge_as_merge_strategy_snapshot(&self) -> Option<MergeStrategySnapshot<'a>> {
        if self.merge_type() == MergeStrategy::MergeStrategySnapshot {
            self.merge().map(MergeStrategySnapshot::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetPollingSource<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<FetchStep, _>("fetch_type", Self::VT_FETCH_TYPE, "fetch", Self::VT_FETCH, false, |key, v, pos| {
        match key {
          FetchStep::FetchStepUrl => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepUrl>>("FetchStep::FetchStepUrl", pos),
          FetchStep::FetchStepFilesGlob => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepFilesGlob>>("FetchStep::FetchStepFilesGlob", pos),
          FetchStep::FetchStepContainer => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FetchStepContainer>>("FetchStep::FetchStepContainer", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PrepStepWrapper>>>>("prepare", Self::VT_PREPARE, false)?
     .visit_union::<ReadStep, _>("read_type", Self::VT_READ_TYPE, "read", Self::VT_READ, false, |key, v, pos| {
        match key {
          ReadStep::ReadStepCsv => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepCsv>>("ReadStep::ReadStepCsv", pos),
          ReadStep::ReadStepJsonLines => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepJsonLines>>("ReadStep::ReadStepJsonLines", pos),
          ReadStep::ReadStepGeoJson => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepGeoJson>>("ReadStep::ReadStepGeoJson", pos),
          ReadStep::ReadStepEsriShapefile => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepEsriShapefile>>("ReadStep::ReadStepEsriShapefile", pos),
          ReadStep::ReadStepParquet => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReadStepParquet>>("ReadStep::ReadStepParquet", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<Transform, _>("preprocess_type", Self::VT_PREPROCESS_TYPE, "preprocess", Self::VT_PREPROCESS, false, |key, v, pos| {
        match key {
          Transform::TransformSql => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>("Transform::TransformSql", pos),
          _ => Ok(()),
        }
     })?
     .visit_union::<MergeStrategy, _>("merge_type", Self::VT_MERGE_TYPE, "merge", Self::VT_MERGE, false, |key, v, pos| {
        match key {
          MergeStrategy::MergeStrategyAppend => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyAppend>>("MergeStrategy::MergeStrategyAppend", pos),
          MergeStrategy::MergeStrategyLedger => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategyLedger>>("MergeStrategy::MergeStrategyLedger", pos),
          MergeStrategy::MergeStrategySnapshot => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MergeStrategySnapshot>>("MergeStrategy::MergeStrategySnapshot", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct SetPollingSourceArgs<'a> {
    pub fetch_type: FetchStep,
    pub fetch: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub prepare: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PrepStepWrapper<'a>>>,
        >,
    >,
    pub read_type: ReadStep,
    pub read: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub preprocess_type: Transform,
    pub preprocess: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub merge_type: MergeStrategy,
    pub merge: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetPollingSourceArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetPollingSourceArgs {
            fetch_type: FetchStep::NONE,
            fetch: None,
            prepare: None,
            read_type: ReadStep::NONE,
            read: None,
            preprocess_type: Transform::NONE,
            preprocess: None,
            merge_type: MergeStrategy::NONE,
            merge: None,
        }
    }
}

pub struct SetPollingSourceBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetPollingSourceBuilder<'a, 'b> {
    #[inline]
    pub fn add_fetch_type(&mut self, fetch_type: FetchStep) {
        self.fbb_.push_slot::<FetchStep>(
            SetPollingSource::VT_FETCH_TYPE,
            fetch_type,
            FetchStep::NONE,
        );
    }
    #[inline]
    pub fn add_fetch(&mut self, fetch: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_FETCH, fetch);
    }
    #[inline]
    pub fn add_prepare(
        &mut self,
        prepare: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<PrepStepWrapper<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_PREPARE, prepare);
    }
    #[inline]
    pub fn add_read_type(&mut self, read_type: ReadStep) {
        self.fbb_
            .push_slot::<ReadStep>(SetPollingSource::VT_READ_TYPE, read_type, ReadStep::NONE);
    }
    #[inline]
    pub fn add_read(&mut self, read: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_READ, read);
    }
    #[inline]
    pub fn add_preprocess_type(&mut self, preprocess_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            SetPollingSource::VT_PREPROCESS_TYPE,
            preprocess_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_preprocess(
        &mut self,
        preprocess: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetPollingSource::VT_PREPROCESS,
            preprocess,
        );
    }
    #[inline]
    pub fn add_merge_type(&mut self, merge_type: MergeStrategy) {
        self.fbb_.push_slot::<MergeStrategy>(
            SetPollingSource::VT_MERGE_TYPE,
            merge_type,
            MergeStrategy::NONE,
        );
    }
    #[inline]
    pub fn add_merge(&mut self, merge: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetPollingSource::VT_MERGE, merge);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> SetPollingSourceBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetPollingSourceBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetPollingSource<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetPollingSource<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetPollingSource");
        ds.field("fetch_type", &self.fetch_type());
        match self.fetch_type() {
            FetchStep::FetchStepUrl => {
                if let Some(x) = self.fetch_as_fetch_step_url() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepFilesGlob => {
                if let Some(x) = self.fetch_as_fetch_step_files_glob() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            FetchStep::FetchStepContainer => {
                if let Some(x) = self.fetch_as_fetch_step_container() {
                    ds.field("fetch", &x)
                } else {
                    ds.field(
                        "fetch",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("fetch", &x)
            }
        };
        ds.field("prepare", &self.prepare());
        ds.field("read_type", &self.read_type());
        match self.read_type() {
            ReadStep::ReadStepCsv => {
                if let Some(x) = self.read_as_read_step_csv() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepJsonLines => {
                if let Some(x) = self.read_as_read_step_json_lines() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepGeoJson => {
                if let Some(x) = self.read_as_read_step_geo_json() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepEsriShapefile => {
                if let Some(x) = self.read_as_read_step_esri_shapefile() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ReadStep::ReadStepParquet => {
                if let Some(x) = self.read_as_read_step_parquet() {
                    ds.field("read", &x)
                } else {
                    ds.field(
                        "read",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("read", &x)
            }
        };
        ds.field("preprocess_type", &self.preprocess_type());
        match self.preprocess_type() {
            Transform::TransformSql => {
                if let Some(x) = self.preprocess_as_transform_sql() {
                    ds.field("preprocess", &x)
                } else {
                    ds.field(
                        "preprocess",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("preprocess", &x)
            }
        };
        ds.field("merge_type", &self.merge_type());
        match self.merge_type() {
            MergeStrategy::MergeStrategyAppend => {
                if let Some(x) = self.merge_as_merge_strategy_append() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategyLedger => {
                if let Some(x) = self.merge_as_merge_strategy_ledger() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MergeStrategy::MergeStrategySnapshot => {
                if let Some(x) = self.merge_as_merge_strategy_snapshot() {
                    ds.field("merge", &x)
                } else {
                    ds.field(
                        "merge",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("merge", &x)
            }
        };
        ds.finish()
    }
}
pub enum TransformInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct TransformInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransformInput<'a> {
    type Inner = TransformInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> TransformInput<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TransformInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TransformInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<TransformInput<'bldr>> {
        let mut builder = TransformInputBuilder::new(_fbb);
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.id {
            builder.add_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                TransformInput::VT_ID,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(TransformInput::VT_NAME, None)
    }
}

impl flatbuffers::Verifiable for TransformInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "id",
                Self::VT_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .finish();
        Ok(())
    }
}
pub struct TransformInputArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TransformInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        TransformInputArgs {
            id: None,
            name: None,
        }
    }
}

pub struct TransformInputBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransformInputBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformInput::VT_ID, id);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TransformInput::VT_NAME, name);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransformInputBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TransformInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TransformInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TransformInput<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TransformInput");
        ds.field("id", &self.id());
        ds.field("name", &self.name());
        ds.finish()
    }
}
pub enum SetTransformOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetTransform<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetTransform<'a> {
    type Inner = SetTransform<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetTransform<'a> {
    pub const VT_INPUTS: flatbuffers::VOffsetT = 4;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetTransform { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetTransformArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetTransform<'bldr>> {
        let mut builder = SetTransformBuilder::new(_fbb);
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput>>,
        >>(SetTransform::VT_INPUTS, None)
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        self._tab
            .get::<Transform>(SetTransform::VT_TRANSFORM_TYPE, Some(Transform::NONE))
            .unwrap()
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetTransform::VT_TRANSFORM,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(TransformSql::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetTransform<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TransformInput>>,
            >>("inputs", Self::VT_INPUTS, false)?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct SetTransformArgs<'a> {
    pub inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TransformInput<'a>>>,
        >,
    >,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetTransformArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetTransformArgs {
            inputs: None,
            transform_type: Transform::NONE,
            transform: None,
        }
    }
}

pub struct SetTransformBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetTransformBuilder<'a, 'b> {
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<TransformInput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetTransform::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            SetTransform::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetTransform::VT_TRANSFORM, transform);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetTransformBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetTransformBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetTransform<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetTransform<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetTransform");
        ds.field("inputs", &self.inputs());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetVocabOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetVocab<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetVocab<'a> {
    type Inner = SetVocab<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetVocab<'a> {
    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET_COLUMN: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetVocab { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetVocabArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetVocab<'bldr>> {
        let mut builder = SetVocabBuilder::new(_fbb);
        if let Some(x) = args.offset_column {
            builder.add_offset_column(x);
        }
        if let Some(x) = args.event_time_column {
            builder.add_event_time_column(x);
        }
        if let Some(x) = args.system_time_column {
            builder.add_system_time_column(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time_column(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_SYSTEM_TIME_COLUMN, None)
    }
    #[inline]
    pub fn event_time_column(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_EVENT_TIME_COLUMN, None)
    }
    #[inline]
    pub fn offset_column(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetVocab::VT_OFFSET_COLUMN, None)
    }
}

impl flatbuffers::Verifiable for SetVocab<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "system_time_column",
                Self::VT_SYSTEM_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "event_time_column",
                Self::VT_EVENT_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "offset_column",
                Self::VT_OFFSET_COLUMN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SetVocabArgs<'a> {
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offset_column: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetVocabArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetVocabArgs {
            system_time_column: None,
            event_time_column: None,
            offset_column: None,
        }
    }
}

pub struct SetVocabBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetVocabBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_SYSTEM_TIME_COLUMN,
            system_time_column,
        );
    }
    #[inline]
    pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_EVENT_TIME_COLUMN,
            event_time_column,
        );
    }
    #[inline]
    pub fn add_offset_column(&mut self, offset_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetVocab::VT_OFFSET_COLUMN,
            offset_column,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetVocabBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetVocabBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetVocab<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetVocab<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetVocab");
        ds.field("system_time_column", &self.system_time_column());
        ds.field("event_time_column", &self.event_time_column());
        ds.field("offset_column", &self.offset_column());
        ds.finish()
    }
}
pub enum SetWatermarkOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetWatermark<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetWatermark<'a> {
    type Inner = SetWatermark<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetWatermark<'a> {
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetWatermark { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetWatermarkArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetWatermark<'bldr>> {
        let mut builder = SetWatermarkBuilder::new(_fbb);
        if let Some(x) = args.output_watermark {
            builder.add_output_watermark(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn output_watermark(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(SetWatermark::VT_OUTPUT_WATERMARK, None)
    }
}

impl flatbuffers::Verifiable for SetWatermark<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("output_watermark", Self::VT_OUTPUT_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct SetWatermarkArgs<'a> {
    pub output_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for SetWatermarkArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetWatermarkArgs {
            output_watermark: None,
        }
    }
}

pub struct SetWatermarkBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetWatermarkBuilder<'a, 'b> {
    #[inline]
    pub fn add_output_watermark(&mut self, output_watermark: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(SetWatermark::VT_OUTPUT_WATERMARK, output_watermark);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetWatermarkBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetWatermarkBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetWatermark<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetWatermark<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetWatermark");
        ds.field("output_watermark", &self.output_watermark());
        ds.finish()
    }
}
pub enum SetAttachmentsOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetAttachments<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetAttachments<'a> {
    type Inner = SetAttachments<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetAttachments<'a> {
    pub const VT_ATTACHMENTS_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_ATTACHMENTS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetAttachments { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetAttachmentsArgs,
    ) -> flatbuffers::WIPOffset<SetAttachments<'bldr>> {
        let mut builder = SetAttachmentsBuilder::new(_fbb);
        if let Some(x) = args.attachments {
            builder.add_attachments(x);
        }
        builder.add_attachments_type(args.attachments_type);
        builder.finish()
    }

    #[inline]
    pub fn attachments_type(&self) -> Attachments {
        self._tab
            .get::<Attachments>(SetAttachments::VT_ATTACHMENTS_TYPE, Some(Attachments::NONE))
            .unwrap()
    }
    #[inline]
    pub fn attachments(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                SetAttachments::VT_ATTACHMENTS,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn attachments_as_attachments_embedded(&self) -> Option<AttachmentsEmbedded<'a>> {
        if self.attachments_type() == Attachments::AttachmentsEmbedded {
            self.attachments().map(AttachmentsEmbedded::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SetAttachments<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Attachments, _>(
                "attachments_type",
                Self::VT_ATTACHMENTS_TYPE,
                "attachments",
                Self::VT_ATTACHMENTS,
                false,
                |key, v, pos| match key {
                    Attachments::AttachmentsEmbedded => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AttachmentsEmbedded>>(
                            "Attachments::AttachmentsEmbedded",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct SetAttachmentsArgs {
    pub attachments_type: Attachments,
    pub attachments: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SetAttachmentsArgs {
    #[inline]
    fn default() -> Self {
        SetAttachmentsArgs {
            attachments_type: Attachments::NONE,
            attachments: None,
        }
    }
}

pub struct SetAttachmentsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetAttachmentsBuilder<'a, 'b> {
    #[inline]
    pub fn add_attachments_type(&mut self, attachments_type: Attachments) {
        self.fbb_.push_slot::<Attachments>(
            SetAttachments::VT_ATTACHMENTS_TYPE,
            attachments_type,
            Attachments::NONE,
        );
    }
    #[inline]
    pub fn add_attachments(
        &mut self,
        attachments: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            SetAttachments::VT_ATTACHMENTS,
            attachments,
        );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetAttachmentsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetAttachmentsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetAttachments<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetAttachments<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetAttachments");
        ds.field("attachments_type", &self.attachments_type());
        match self.attachments_type() {
            Attachments::AttachmentsEmbedded => {
                if let Some(x) = self.attachments_as_attachments_embedded() {
                    ds.field("attachments", &x)
                } else {
                    ds.field(
                        "attachments",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("attachments", &x)
            }
        };
        ds.finish()
    }
}
pub enum SetInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetInfo<'a> {
    type Inner = SetInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetInfo<'a> {
    pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 4;
    pub const VT_KEYWORDS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetInfo<'bldr>> {
        let mut builder = SetInfoBuilder::new(_fbb);
        if let Some(x) = args.keywords {
            builder.add_keywords(x);
        }
        if let Some(x) = args.description {
            builder.add_description(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn description(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetInfo::VT_DESCRIPTION, None)
    }
    #[inline]
    pub fn keywords(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(SetInfo::VT_KEYWORDS, None)
    }
}

impl flatbuffers::Verifiable for SetInfo<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "description",
                Self::VT_DESCRIPTION,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("keywords", Self::VT_KEYWORDS, false)?
            .finish();
        Ok(())
    }
}
pub struct SetInfoArgs<'a> {
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub keywords: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for SetInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetInfoArgs {
            description: None,
            keywords: None,
        }
    }
}

pub struct SetInfoBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetInfoBuilder<'a, 'b> {
    #[inline]
    pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetInfo::VT_DESCRIPTION, description);
    }
    #[inline]
    pub fn add_keywords(
        &mut self,
        keywords: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetInfo::VT_KEYWORDS, keywords);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetInfoBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetInfo<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetInfo");
        ds.field("description", &self.description());
        ds.field("keywords", &self.keywords());
        ds.finish()
    }
}
pub enum SetLicenseOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct SetLicense<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SetLicense<'a> {
    type Inner = SetLicense<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> SetLicense<'a> {
    pub const VT_SHORT_NAME: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SPDX_ID: flatbuffers::VOffsetT = 8;
    pub const VT_WEBSITE_URL: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SetLicense { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SetLicenseArgs<'args>,
    ) -> flatbuffers::WIPOffset<SetLicense<'bldr>> {
        let mut builder = SetLicenseBuilder::new(_fbb);
        if let Some(x) = args.website_url {
            builder.add_website_url(x);
        }
        if let Some(x) = args.spdx_id {
            builder.add_spdx_id(x);
        }
        if let Some(x) = args.name {
            builder.add_name(x);
        }
        if let Some(x) = args.short_name {
            builder.add_short_name(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn short_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_SHORT_NAME, None)
    }
    #[inline]
    pub fn name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_NAME, None)
    }
    #[inline]
    pub fn spdx_id(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_SPDX_ID, None)
    }
    #[inline]
    pub fn website_url(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(SetLicense::VT_WEBSITE_URL, None)
    }
}

impl flatbuffers::Verifiable for SetLicense<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "short_name",
                Self::VT_SHORT_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("spdx_id", Self::VT_SPDX_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "website_url",
                Self::VT_WEBSITE_URL,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct SetLicenseArgs<'a> {
    pub short_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub spdx_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub website_url: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SetLicenseArgs<'a> {
    #[inline]
    fn default() -> Self {
        SetLicenseArgs {
            short_name: None,
            name: None,
            spdx_id: None,
            website_url: None,
        }
    }
}

pub struct SetLicenseBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SetLicenseBuilder<'a, 'b> {
    #[inline]
    pub fn add_short_name(&mut self, short_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_SHORT_NAME, short_name);
    }
    #[inline]
    pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_NAME, name);
    }
    #[inline]
    pub fn add_spdx_id(&mut self, spdx_id: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_SPDX_ID, spdx_id);
    }
    #[inline]
    pub fn add_website_url(&mut self, website_url: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SetLicense::VT_WEBSITE_URL, website_url);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SetLicenseBuilder<'a, 'b> {
        let start = _fbb.start_table();
        SetLicenseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SetLicense<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SetLicense<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SetLicense");
        ds.field("short_name", &self.short_name());
        ds.field("name", &self.name());
        ds.field("spdx_id", &self.spdx_id());
        ds.field("website_url", &self.website_url());
        ds.finish()
    }
}
pub enum DatasetVocabularyOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct DatasetVocabulary<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatasetVocabulary<'a> {
    type Inner = DatasetVocabulary<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> DatasetVocabulary<'a> {
    pub const VT_SYSTEM_TIME_COLUMN: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME_COLUMN: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET_COLUMN: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DatasetVocabulary { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DatasetVocabularyArgs<'args>,
    ) -> flatbuffers::WIPOffset<DatasetVocabulary<'bldr>> {
        let mut builder = DatasetVocabularyBuilder::new(_fbb);
        if let Some(x) = args.offset_column {
            builder.add_offset_column(x);
        }
        if let Some(x) = args.event_time_column {
            builder.add_event_time_column(x);
        }
        if let Some(x) = args.system_time_column {
            builder.add_system_time_column(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn event_time_column(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            DatasetVocabulary::VT_EVENT_TIME_COLUMN,
            None,
        )
    }
    #[inline]
    pub fn offset_column(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(DatasetVocabulary::VT_OFFSET_COLUMN, None)
    }
}

impl flatbuffers::Verifiable for DatasetVocabulary<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "system_time_column",
                Self::VT_SYSTEM_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "event_time_column",
                Self::VT_EVENT_TIME_COLUMN,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "offset_column",
                Self::VT_OFFSET_COLUMN,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DatasetVocabularyArgs<'a> {
    pub system_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub event_time_column: Option<flatbuffers::WIPOffset<&'a str>>,
    pub offset_column: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DatasetVocabularyArgs<'a> {
    #[inline]
    fn default() -> Self {
        DatasetVocabularyArgs {
            system_time_column: None,
            event_time_column: None,
            offset_column: None,
        }
    }
}

pub struct DatasetVocabularyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DatasetVocabularyBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time_column(&mut self, system_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_SYSTEM_TIME_COLUMN,
            system_time_column,
        );
    }
    #[inline]
    pub fn add_event_time_column(&mut self, event_time_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_EVENT_TIME_COLUMN,
            event_time_column,
        );
    }
    #[inline]
    pub fn add_offset_column(&mut self, offset_column: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            DatasetVocabulary::VT_OFFSET_COLUMN,
            offset_column,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> DatasetVocabularyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DatasetVocabularyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DatasetVocabulary<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DatasetVocabulary<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DatasetVocabulary");
        ds.field("system_time_column", &self.system_time_column());
        ds.field("event_time_column", &self.event_time_column());
        ds.field("offset_column", &self.offset_column());
        ds.finish()
    }
}
pub enum WatermarkOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct Watermark<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Watermark<'a> {
    type Inner = Watermark<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Watermark<'a> {
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_EVENT_TIME: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Watermark { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WatermarkArgs<'args>,
    ) -> flatbuffers::WIPOffset<Watermark<'bldr>> {
        let mut builder = WatermarkBuilder::new(_fbb);
        if let Some(x) = args.event_time {
            builder.add_event_time(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab.get::<Timestamp>(Watermark::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn event_time(&self) -> Option<&'a Timestamp> {
        self._tab.get::<Timestamp>(Watermark::VT_EVENT_TIME, None)
    }
}

impl flatbuffers::Verifiable for Watermark<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<Timestamp>("event_time", Self::VT_EVENT_TIME, false)?
            .finish();
        Ok(())
    }
}
pub struct WatermarkArgs<'a> {
    pub system_time: Option<&'a Timestamp>,
    pub event_time: Option<&'a Timestamp>,
}
impl<'a> Default for WatermarkArgs<'a> {
    #[inline]
    fn default() -> Self {
        WatermarkArgs {
            system_time: None,
            event_time: None,
        }
    }
}

pub struct WatermarkBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WatermarkBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_event_time(&mut self, event_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(Watermark::VT_EVENT_TIME, event_time);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WatermarkBuilder<'a, 'b> {
        let start = _fbb.start_table();
        WatermarkBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Watermark<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Watermark<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Watermark");
        ds.field("system_time", &self.system_time());
        ds.field("event_time", &self.event_time());
        ds.finish()
    }
}
pub enum ExecuteQueryInputOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQueryInput<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryInput<'a> {
    type Inner = ExecuteQueryInput<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryInput<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 8;
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 10;
    pub const VT_DATA_PATHS: flatbuffers::VOffsetT = 12;
    pub const VT_SCHEMA_FILE: flatbuffers::VOffsetT = 14;
    pub const VT_EXPLICIT_WATERMARKS: flatbuffers::VOffsetT = 16;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryInput { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryInputArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryInput<'bldr>> {
        let mut builder = ExecuteQueryInputBuilder::new(_fbb);
        if let Some(x) = args.explicit_watermarks {
            builder.add_explicit_watermarks(x);
        }
        if let Some(x) = args.schema_file {
            builder.add_schema_file(x);
        }
        if let Some(x) = args.data_paths {
            builder.add_data_paths(x);
        }
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.dataset_name {
            builder.add_dataset_name(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                ExecuteQueryInput::VT_DATASET_ID,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn dataset_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryInput::VT_DATASET_NAME, None)
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                ExecuteQueryInput::VT_VOCAB,
                None,
            )
    }
    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                ExecuteQueryInput::VT_DATA_INTERVAL,
                None,
            )
    }
    #[inline]
    pub fn data_paths(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
        >>(ExecuteQueryInput::VT_DATA_PATHS, None)
    }
    #[inline]
    pub fn schema_file(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryInput::VT_SCHEMA_FILE, None)
    }
    #[inline]
    pub fn explicit_watermarks(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark>>,
        >>(ExecuteQueryInput::VT_EXPLICIT_WATERMARKS, None)
    }
}

impl flatbuffers::Verifiable for ExecuteQueryInput<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_name",
                Self::VT_DATASET_NAME,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("data_paths", Self::VT_DATA_PATHS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "schema_file",
                Self::VT_SCHEMA_FILE,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Watermark>>,
            >>("explicit_watermarks", Self::VT_EXPLICIT_WATERMARKS, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryInputArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub data_paths: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub schema_file: Option<flatbuffers::WIPOffset<&'a str>>,
    pub explicit_watermarks: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Watermark<'a>>>,
        >,
    >,
}
impl<'a> Default for ExecuteQueryInputArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryInputArgs {
            dataset_id: None,
            dataset_name: None,
            vocab: None,
            data_interval: None,
            data_paths: None,
            schema_file: None,
            explicit_watermarks: None,
        }
    }
}

pub struct ExecuteQueryInputBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryInputBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryInput::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_dataset_name(&mut self, dataset_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryInput::VT_DATASET_NAME,
            dataset_name,
        );
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                ExecuteQueryInput::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                ExecuteQueryInput::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn add_data_paths(
        &mut self,
        data_paths: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryInput::VT_DATA_PATHS,
            data_paths,
        );
    }
    #[inline]
    pub fn add_schema_file(&mut self, schema_file: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryInput::VT_SCHEMA_FILE,
            schema_file,
        );
    }
    #[inline]
    pub fn add_explicit_watermarks(
        &mut self,
        explicit_watermarks: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Watermark<'b>>>,
        >,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryInput::VT_EXPLICIT_WATERMARKS,
            explicit_watermarks,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryInputBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryInputBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryInput<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryInput<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryInput");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_name", &self.dataset_name());
        ds.field("vocab", &self.vocab());
        ds.field("data_interval", &self.data_interval());
        ds.field("data_paths", &self.data_paths());
        ds.field("schema_file", &self.schema_file());
        ds.field("explicit_watermarks", &self.explicit_watermarks());
        ds.finish()
    }
}
pub enum ExecuteQueryRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQueryRequest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryRequest<'a> {
    type Inner = ExecuteQueryRequest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryRequest<'a> {
    pub const VT_DATASET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_DATASET_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 8;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_VOCAB: flatbuffers::VOffsetT = 12;
    pub const VT_TRANSFORM_TYPE: flatbuffers::VOffsetT = 14;
    pub const VT_TRANSFORM: flatbuffers::VOffsetT = 16;
    pub const VT_INPUTS: flatbuffers::VOffsetT = 18;
    pub const VT_PREV_CHECKPOINT_PATH: flatbuffers::VOffsetT = 20;
    pub const VT_NEW_CHECKPOINT_PATH: flatbuffers::VOffsetT = 22;
    pub const VT_OUT_DATA_PATH: flatbuffers::VOffsetT = 24;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryRequest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryRequestArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryRequest<'bldr>> {
        let mut builder = ExecuteQueryRequestBuilder::new(_fbb);
        builder.add_offset(args.offset);
        if let Some(x) = args.out_data_path {
            builder.add_out_data_path(x);
        }
        if let Some(x) = args.new_checkpoint_path {
            builder.add_new_checkpoint_path(x);
        }
        if let Some(x) = args.prev_checkpoint_path {
            builder.add_prev_checkpoint_path(x);
        }
        if let Some(x) = args.inputs {
            builder.add_inputs(x);
        }
        if let Some(x) = args.transform {
            builder.add_transform(x);
        }
        if let Some(x) = args.vocab {
            builder.add_vocab(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        if let Some(x) = args.dataset_name {
            builder.add_dataset_name(x);
        }
        if let Some(x) = args.dataset_id {
            builder.add_dataset_id(x);
        }
        builder.add_transform_type(args.transform_type);
        builder.finish()
    }

    #[inline]
    pub fn dataset_id(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                ExecuteQueryRequest::VT_DATASET_ID,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn dataset_name(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryRequest::VT_DATASET_NAME, None)
    }
    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(ExecuteQueryRequest::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn offset(&self) -> i64 {
        self._tab
            .get::<i64>(ExecuteQueryRequest::VT_OFFSET, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn vocab(&self) -> Option<DatasetVocabulary<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                ExecuteQueryRequest::VT_VOCAB,
                None,
            )
    }
    #[inline]
    pub fn transform_type(&self) -> Transform {
        self._tab
            .get::<Transform>(
                ExecuteQueryRequest::VT_TRANSFORM_TYPE,
                Some(Transform::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn transform(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ExecuteQueryRequest::VT_TRANSFORM,
                None,
            )
    }
    #[inline]
    pub fn inputs(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteQueryInput<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteQueryInput>>,
        >>(ExecuteQueryRequest::VT_INPUTS, None)
    }
    #[inline]
    pub fn prev_checkpoint_path(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryRequest::VT_PREV_CHECKPOINT_PATH,
            None,
        )
    }
    #[inline]
    pub fn new_checkpoint_path(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryRequest::VT_NEW_CHECKPOINT_PATH,
            None,
        )
    }
    #[inline]
    pub fn out_data_path(&self) -> Option<&'a str> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<&str>>(ExecuteQueryRequest::VT_OUT_DATA_PATH, None)
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn transform_as_transform_sql(&self) -> Option<TransformSql<'a>> {
        if self.transform_type() == Transform::TransformSql {
            self.transform().map(TransformSql::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ExecuteQueryRequest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "dataset_id",
                Self::VT_DATASET_ID,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "dataset_name",
                Self::VT_DATASET_NAME,
                false,
            )?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<i64>("offset", Self::VT_OFFSET, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<DatasetVocabulary>>(
                "vocab",
                Self::VT_VOCAB,
                false,
            )?
            .visit_union::<Transform, _>(
                "transform_type",
                Self::VT_TRANSFORM_TYPE,
                "transform",
                Self::VT_TRANSFORM,
                false,
                |key, v, pos| match key {
                    Transform::TransformSql => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TransformSql>>(
                            "Transform::TransformSql",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ExecuteQueryInput>>,
            >>("inputs", Self::VT_INPUTS, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "prev_checkpoint_path",
                Self::VT_PREV_CHECKPOINT_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "new_checkpoint_path",
                Self::VT_NEW_CHECKPOINT_PATH,
                false,
            )?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "out_data_path",
                Self::VT_OUT_DATA_PATH,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryRequestArgs<'a> {
    pub dataset_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dataset_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub system_time: Option<&'a Timestamp>,
    pub offset: i64,
    pub vocab: Option<flatbuffers::WIPOffset<DatasetVocabulary<'a>>>,
    pub transform_type: Transform,
    pub transform: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub inputs: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ExecuteQueryInput<'a>>>,
        >,
    >,
    pub prev_checkpoint_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub new_checkpoint_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub out_data_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryRequestArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryRequestArgs {
            dataset_id: None,
            dataset_name: None,
            system_time: None,
            offset: 0,
            vocab: None,
            transform_type: Transform::NONE,
            transform: None,
            inputs: None,
            prev_checkpoint_path: None,
            new_checkpoint_path: None,
            out_data_path: None,
        }
    }
}

pub struct ExecuteQueryRequestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryRequestBuilder<'a, 'b> {
    #[inline]
    pub fn add_dataset_id(
        &mut self,
        dataset_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_DATASET_ID,
            dataset_id,
        );
    }
    #[inline]
    pub fn add_dataset_name(&mut self, dataset_name: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_DATASET_NAME,
            dataset_name,
        );
    }
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(ExecuteQueryRequest::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_offset(&mut self, offset: i64) {
        self.fbb_
            .push_slot::<i64>(ExecuteQueryRequest::VT_OFFSET, offset, 0);
    }
    #[inline]
    pub fn add_vocab(&mut self, vocab: flatbuffers::WIPOffset<DatasetVocabulary<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<DatasetVocabulary>>(
                ExecuteQueryRequest::VT_VOCAB,
                vocab,
            );
    }
    #[inline]
    pub fn add_transform_type(&mut self, transform_type: Transform) {
        self.fbb_.push_slot::<Transform>(
            ExecuteQueryRequest::VT_TRANSFORM_TYPE,
            transform_type,
            Transform::NONE,
        );
    }
    #[inline]
    pub fn add_transform(
        &mut self,
        transform: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_TRANSFORM,
            transform,
        );
    }
    #[inline]
    pub fn add_inputs(
        &mut self,
        inputs: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ExecuteQueryInput<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ExecuteQueryRequest::VT_INPUTS, inputs);
    }
    #[inline]
    pub fn add_prev_checkpoint_path(
        &mut self,
        prev_checkpoint_path: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_PREV_CHECKPOINT_PATH,
            prev_checkpoint_path,
        );
    }
    #[inline]
    pub fn add_new_checkpoint_path(
        &mut self,
        new_checkpoint_path: flatbuffers::WIPOffset<&'b str>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_NEW_CHECKPOINT_PATH,
            new_checkpoint_path,
        );
    }
    #[inline]
    pub fn add_out_data_path(&mut self, out_data_path: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryRequest::VT_OUT_DATA_PATH,
            out_data_path,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryRequestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryRequestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryRequest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryRequest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryRequest");
        ds.field("dataset_id", &self.dataset_id());
        ds.field("dataset_name", &self.dataset_name());
        ds.field("system_time", &self.system_time());
        ds.field("offset", &self.offset());
        ds.field("vocab", &self.vocab());
        ds.field("transform_type", &self.transform_type());
        match self.transform_type() {
            Transform::TransformSql => {
                if let Some(x) = self.transform_as_transform_sql() {
                    ds.field("transform", &x)
                } else {
                    ds.field(
                        "transform",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("transform", &x)
            }
        };
        ds.field("inputs", &self.inputs());
        ds.field("prev_checkpoint_path", &self.prev_checkpoint_path());
        ds.field("new_checkpoint_path", &self.new_checkpoint_path());
        ds.field("out_data_path", &self.out_data_path());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseProgressOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct ExecuteQueryResponseProgress<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseProgress<'a> {
    type Inner = ExecuteQueryResponseProgress<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseProgress<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseProgress { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args ExecuteQueryResponseProgressArgs,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseProgress<'bldr>> {
        let mut builder = ExecuteQueryResponseProgressBuilder::new(_fbb);
        builder.finish()
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseProgress<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?.finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseProgressArgs {}
impl<'a> Default for ExecuteQueryResponseProgressArgs {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseProgressArgs {}
    }
}

pub struct ExecuteQueryResponseProgressBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseProgressBuilder<'a, 'b> {
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseProgressBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseProgressBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseProgress<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryResponseProgress<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseProgress");
        ds.finish()
    }
}
pub enum ExecuteQueryResponseSuccessOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseSuccess<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseSuccess<'a> {
    type Inner = ExecuteQueryResponseSuccess<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseSuccess<'a> {
    pub const VT_DATA_INTERVAL: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUT_WATERMARK: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseSuccess { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseSuccessArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseSuccess<'bldr>> {
        let mut builder = ExecuteQueryResponseSuccessBuilder::new(_fbb);
        if let Some(x) = args.output_watermark {
            builder.add_output_watermark(x);
        }
        if let Some(x) = args.data_interval {
            builder.add_data_interval(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn data_interval(&self) -> Option<OffsetInterval<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                ExecuteQueryResponseSuccess::VT_DATA_INTERVAL,
                None,
            )
    }
    #[inline]
    pub fn output_watermark(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(ExecuteQueryResponseSuccess::VT_OUTPUT_WATERMARK, None)
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseSuccess<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<OffsetInterval>>(
                "data_interval",
                Self::VT_DATA_INTERVAL,
                false,
            )?
            .visit_field::<Timestamp>("output_watermark", Self::VT_OUTPUT_WATERMARK, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseSuccessArgs<'a> {
    pub data_interval: Option<flatbuffers::WIPOffset<OffsetInterval<'a>>>,
    pub output_watermark: Option<&'a Timestamp>,
}
impl<'a> Default for ExecuteQueryResponseSuccessArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseSuccessArgs {
            data_interval: None,
            output_watermark: None,
        }
    }
}

pub struct ExecuteQueryResponseSuccessBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseSuccessBuilder<'a, 'b> {
    #[inline]
    pub fn add_data_interval(&mut self, data_interval: flatbuffers::WIPOffset<OffsetInterval<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<OffsetInterval>>(
                ExecuteQueryResponseSuccess::VT_DATA_INTERVAL,
                data_interval,
            );
    }
    #[inline]
    pub fn add_output_watermark(&mut self, output_watermark: &Timestamp) {
        self.fbb_.push_slot_always::<&Timestamp>(
            ExecuteQueryResponseSuccess::VT_OUTPUT_WATERMARK,
            output_watermark,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseSuccessBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseSuccessBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseSuccess<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryResponseSuccess<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseSuccess");
        ds.field("data_interval", &self.data_interval());
        ds.field("output_watermark", &self.output_watermark());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseInvalidQueryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseInvalidQuery<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseInvalidQuery<'a> {
    type Inner = ExecuteQueryResponseInvalidQuery<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseInvalidQuery<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseInvalidQuery { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseInvalidQueryArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseInvalidQuery<'bldr>> {
        let mut builder = ExecuteQueryResponseInvalidQueryBuilder::new(_fbb);
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInvalidQuery::VT_MESSAGE,
            None,
        )
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseInvalidQuery<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseInvalidQueryArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryResponseInvalidQueryArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseInvalidQueryArgs { message: None }
    }
}

pub struct ExecuteQueryResponseInvalidQueryBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseInvalidQueryBuilder<'a, 'b> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInvalidQuery::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseInvalidQueryBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseInvalidQueryBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseInvalidQuery<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryResponseInvalidQuery<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseInvalidQuery");
        ds.field("message", &self.message());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseInternalErrorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseInternalError<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseInternalError<'a> {
    type Inner = ExecuteQueryResponseInternalError<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseInternalError<'a> {
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 4;
    pub const VT_BACKTRACE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseInternalError { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseInternalErrorArgs<'args>,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseInternalError<'bldr>> {
        let mut builder = ExecuteQueryResponseInternalErrorBuilder::new(_fbb);
        if let Some(x) = args.backtrace {
            builder.add_backtrace(x);
        }
        if let Some(x) = args.message {
            builder.add_message(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn message(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInternalError::VT_MESSAGE,
            None,
        )
    }
    #[inline]
    pub fn backtrace(&self) -> Option<&'a str> {
        self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(
            ExecuteQueryResponseInternalError::VT_BACKTRACE,
            None,
        )
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseInternalError<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>(
                "backtrace",
                Self::VT_BACKTRACE,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseInternalErrorArgs<'a> {
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
    pub backtrace: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExecuteQueryResponseInternalErrorArgs<'a> {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseInternalErrorArgs {
            message: None,
            backtrace: None,
        }
    }
}

pub struct ExecuteQueryResponseInternalErrorBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseInternalErrorBuilder<'a, 'b> {
    #[inline]
    pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInternalError::VT_MESSAGE,
            message,
        );
    }
    #[inline]
    pub fn add_backtrace(&mut self, backtrace: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseInternalError::VT_BACKTRACE,
            backtrace,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseInternalErrorBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseInternalErrorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseInternalError<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryResponseInternalError<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseInternalError");
        ds.field("message", &self.message());
        ds.field("backtrace", &self.backtrace());
        ds.finish()
    }
}
pub enum ExecuteQueryResponseRootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExecuteQueryResponseRoot<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExecuteQueryResponseRoot<'a> {
    type Inner = ExecuteQueryResponseRoot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> ExecuteQueryResponseRoot<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ExecuteQueryResponseRoot { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ExecuteQueryResponseRootArgs,
    ) -> flatbuffers::WIPOffset<ExecuteQueryResponseRoot<'bldr>> {
        let mut builder = ExecuteQueryResponseRootBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> ExecuteQueryResponse {
        self._tab
            .get::<ExecuteQueryResponse>(
                ExecuteQueryResponseRoot::VT_VALUE_TYPE,
                Some(ExecuteQueryResponse::NONE),
            )
            .unwrap()
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                ExecuteQueryResponseRoot::VT_VALUE,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_progress(
        &self,
    ) -> Option<ExecuteQueryResponseProgress<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseProgress {
            self.value()
                .map(ExecuteQueryResponseProgress::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_success(
        &self,
    ) -> Option<ExecuteQueryResponseSuccess<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseSuccess {
            self.value()
                .map(ExecuteQueryResponseSuccess::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_invalid_query(
        &self,
    ) -> Option<ExecuteQueryResponseInvalidQuery<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery {
            self.value()
                .map(ExecuteQueryResponseInvalidQuery::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_execute_query_response_internal_error(
        &self,
    ) -> Option<ExecuteQueryResponseInternalError<'a>> {
        if self.value_type() == ExecuteQueryResponse::ExecuteQueryResponseInternalError {
            self.value()
                .map(ExecuteQueryResponseInternalError::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ExecuteQueryResponseRoot<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
     .visit_union::<ExecuteQueryResponse, _>("value_type", Self::VT_VALUE_TYPE, "value", Self::VT_VALUE, false, |key, v, pos| {
        match key {
          ExecuteQueryResponse::ExecuteQueryResponseProgress => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseProgress>>("ExecuteQueryResponse::ExecuteQueryResponseProgress", pos),
          ExecuteQueryResponse::ExecuteQueryResponseSuccess => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseSuccess>>("ExecuteQueryResponse::ExecuteQueryResponseSuccess", pos),
          ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseInvalidQuery>>("ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery", pos),
          ExecuteQueryResponse::ExecuteQueryResponseInternalError => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQueryResponseInternalError>>("ExecuteQueryResponse::ExecuteQueryResponseInternalError", pos),
          _ => Ok(()),
        }
     })?
     .finish();
        Ok(())
    }
}
pub struct ExecuteQueryResponseRootArgs {
    pub value_type: ExecuteQueryResponse,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ExecuteQueryResponseRootArgs {
    #[inline]
    fn default() -> Self {
        ExecuteQueryResponseRootArgs {
            value_type: ExecuteQueryResponse::NONE,
            value: None,
        }
    }
}

pub struct ExecuteQueryResponseRootBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExecuteQueryResponseRootBuilder<'a, 'b> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: ExecuteQueryResponse) {
        self.fbb_.push_slot::<ExecuteQueryResponse>(
            ExecuteQueryResponseRoot::VT_VALUE_TYPE,
            value_type,
            ExecuteQueryResponse::NONE,
        );
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            ExecuteQueryResponseRoot::VT_VALUE,
            value,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> ExecuteQueryResponseRootBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ExecuteQueryResponseRootBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ExecuteQueryResponseRoot<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ExecuteQueryResponseRoot<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ExecuteQueryResponseRoot");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            ExecuteQueryResponse::ExecuteQueryResponseProgress => {
                if let Some(x) = self.value_as_execute_query_response_progress() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseSuccess => {
                if let Some(x) = self.value_as_execute_query_response_success() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseInvalidQuery => {
                if let Some(x) = self.value_as_execute_query_response_invalid_query() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ExecuteQueryResponse::ExecuteQueryResponseInternalError => {
                if let Some(x) = self.value_as_execute_query_response_internal_error() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum ManifestOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct Manifest<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Manifest<'a> {
    type Inner = Manifest<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> Manifest<'a> {
    pub const VT_KIND: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 8;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Manifest { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ManifestArgs<'args>,
    ) -> flatbuffers::WIPOffset<Manifest<'bldr>> {
        let mut builder = ManifestBuilder::new(_fbb);
        builder.add_kind(args.kind);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    #[inline]
    pub fn kind(&self) -> i64 {
        self._tab.get::<i64>(Manifest::VT_KIND, Some(0)).unwrap()
    }
    #[inline]
    pub fn version(&self) -> i32 {
        self._tab.get::<i32>(Manifest::VT_VERSION, Some(0)).unwrap()
    }
    #[inline]
    pub fn content(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                Manifest::VT_CONTENT,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

impl flatbuffers::Verifiable for Manifest<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("kind", Self::VT_KIND, false)?
            .visit_field::<i32>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "content",
                Self::VT_CONTENT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct ManifestArgs<'a> {
    pub kind: i64,
    pub version: i32,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ManifestArgs<'a> {
    #[inline]
    fn default() -> Self {
        ManifestArgs {
            kind: 0,
            version: 0,
            content: None,
        }
    }
}

pub struct ManifestBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ManifestBuilder<'a, 'b> {
    #[inline]
    pub fn add_kind(&mut self, kind: i64) {
        self.fbb_.push_slot::<i64>(Manifest::VT_KIND, kind, 0);
    }
    #[inline]
    pub fn add_version(&mut self, version: i32) {
        self.fbb_.push_slot::<i32>(Manifest::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Manifest::VT_CONTENT, content);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ManifestBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ManifestBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Manifest<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Manifest<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Manifest");
        ds.field("kind", &self.kind());
        ds.field("version", &self.version());
        ds.field("content", &self.content());
        ds.finish()
    }
}
pub enum MetadataBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
pub struct MetadataBlock<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataBlock<'a> {
    type Inner = MetadataBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf, loc },
        }
    }
}

impl<'a> MetadataBlock<'a> {
    pub const VT_SYSTEM_TIME: flatbuffers::VOffsetT = 4;
    pub const VT_PREV_BLOCK_HASH: flatbuffers::VOffsetT = 6;
    pub const VT_SEQUENCE_NUMBER: flatbuffers::VOffsetT = 8;
    pub const VT_EVENT_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_EVENT: flatbuffers::VOffsetT = 12;

    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        MetadataBlock { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args MetadataBlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<MetadataBlock<'bldr>> {
        let mut builder = MetadataBlockBuilder::new(_fbb);
        if let Some(x) = args.event {
            builder.add_event(x);
        }
        builder.add_sequence_number(args.sequence_number);
        if let Some(x) = args.prev_block_hash {
            builder.add_prev_block_hash(x);
        }
        if let Some(x) = args.system_time {
            builder.add_system_time(x);
        }
        builder.add_event_type(args.event_type);
        builder.finish()
    }

    #[inline]
    pub fn system_time(&self) -> Option<&'a Timestamp> {
        self._tab
            .get::<Timestamp>(MetadataBlock::VT_SYSTEM_TIME, None)
    }
    #[inline]
    pub fn prev_block_hash(&self) -> Option<&'a [u8]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                MetadataBlock::VT_PREV_BLOCK_HASH,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn sequence_number(&self) -> i32 {
        self._tab
            .get::<i32>(MetadataBlock::VT_SEQUENCE_NUMBER, Some(0))
            .unwrap()
    }
    #[inline]
    pub fn event_type(&self) -> MetadataEvent {
        self._tab
            .get::<MetadataEvent>(MetadataBlock::VT_EVENT_TYPE, Some(MetadataEvent::NONE))
            .unwrap()
    }
    #[inline]
    pub fn event(&self) -> Option<flatbuffers::Table<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                MetadataBlock::VT_EVENT,
                None,
            )
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_add_data(&self) -> Option<AddData<'a>> {
        if self.event_type() == MetadataEvent::AddData {
            self.event().map(AddData::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_execute_query(&self) -> Option<ExecuteQuery<'a>> {
        if self.event_type() == MetadataEvent::ExecuteQuery {
            self.event().map(ExecuteQuery::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_seed(&self) -> Option<Seed<'a>> {
        if self.event_type() == MetadataEvent::Seed {
            self.event().map(Seed::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_polling_source(&self) -> Option<SetPollingSource<'a>> {
        if self.event_type() == MetadataEvent::SetPollingSource {
            self.event().map(SetPollingSource::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_transform(&self) -> Option<SetTransform<'a>> {
        if self.event_type() == MetadataEvent::SetTransform {
            self.event().map(SetTransform::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_vocab(&self) -> Option<SetVocab<'a>> {
        if self.event_type() == MetadataEvent::SetVocab {
            self.event().map(SetVocab::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_watermark(&self) -> Option<SetWatermark<'a>> {
        if self.event_type() == MetadataEvent::SetWatermark {
            self.event().map(SetWatermark::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_attachments(&self) -> Option<SetAttachments<'a>> {
        if self.event_type() == MetadataEvent::SetAttachments {
            self.event().map(SetAttachments::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_info(&self) -> Option<SetInfo<'a>> {
        if self.event_type() == MetadataEvent::SetInfo {
            self.event().map(SetInfo::init_from_table)
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn event_as_set_license(&self) -> Option<SetLicense<'a>> {
        if self.event_type() == MetadataEvent::SetLicense {
            self.event().map(SetLicense::init_from_table)
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for MetadataBlock<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<Timestamp>("system_time", Self::VT_SYSTEM_TIME, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "prev_block_hash",
                Self::VT_PREV_BLOCK_HASH,
                false,
            )?
            .visit_field::<i32>("sequence_number", Self::VT_SEQUENCE_NUMBER, false)?
            .visit_union::<MetadataEvent, _>(
                "event_type",
                Self::VT_EVENT_TYPE,
                "event",
                Self::VT_EVENT,
                false,
                |key, v, pos| match key {
                    MetadataEvent::AddData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<AddData>>(
                            "MetadataEvent::AddData",
                            pos,
                        ),
                    MetadataEvent::ExecuteQuery => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ExecuteQuery>>(
                            "MetadataEvent::ExecuteQuery",
                            pos,
                        ),
                    MetadataEvent::Seed => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Seed>>(
                            "MetadataEvent::Seed",
                            pos,
                        ),
                    MetadataEvent::SetPollingSource => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetPollingSource>>(
                            "MetadataEvent::SetPollingSource",
                            pos,
                        ),
                    MetadataEvent::SetTransform => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetTransform>>(
                            "MetadataEvent::SetTransform",
                            pos,
                        ),
                    MetadataEvent::SetVocab => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetVocab>>(
                            "MetadataEvent::SetVocab",
                            pos,
                        ),
                    MetadataEvent::SetWatermark => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetWatermark>>(
                            "MetadataEvent::SetWatermark",
                            pos,
                        ),
                    MetadataEvent::SetAttachments => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetAttachments>>(
                            "MetadataEvent::SetAttachments",
                            pos,
                        ),
                    MetadataEvent::SetInfo => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetInfo>>(
                            "MetadataEvent::SetInfo",
                            pos,
                        ),
                    MetadataEvent::SetLicense => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<SetLicense>>(
                            "MetadataEvent::SetLicense",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct MetadataBlockArgs<'a> {
    pub system_time: Option<&'a Timestamp>,
    pub prev_block_hash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub sequence_number: i32,
    pub event_type: MetadataEvent,
    pub event: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MetadataBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        MetadataBlockArgs {
            system_time: None,
            prev_block_hash: None,
            sequence_number: 0,
            event_type: MetadataEvent::NONE,
            event: None,
        }
    }
}

pub struct MetadataBlockBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBlockBuilder<'a, 'b> {
    #[inline]
    pub fn add_system_time(&mut self, system_time: &Timestamp) {
        self.fbb_
            .push_slot_always::<&Timestamp>(MetadataBlock::VT_SYSTEM_TIME, system_time);
    }
    #[inline]
    pub fn add_prev_block_hash(
        &mut self,
        prev_block_hash: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            MetadataBlock::VT_PREV_BLOCK_HASH,
            prev_block_hash,
        );
    }
    #[inline]
    pub fn add_sequence_number(&mut self, sequence_number: i32) {
        self.fbb_
            .push_slot::<i32>(MetadataBlock::VT_SEQUENCE_NUMBER, sequence_number, 0);
    }
    #[inline]
    pub fn add_event_type(&mut self, event_type: MetadataEvent) {
        self.fbb_.push_slot::<MetadataEvent>(
            MetadataBlock::VT_EVENT_TYPE,
            event_type,
            MetadataEvent::NONE,
        );
    }
    #[inline]
    pub fn add_event(&mut self, event: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataBlock::VT_EVENT, event);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBlockBuilder<'a, 'b> {
        let start = _fbb.start_table();
        MetadataBlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<MetadataBlock<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for MetadataBlock<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("MetadataBlock");
        ds.field("system_time", &self.system_time());
        ds.field("prev_block_hash", &self.prev_block_hash());
        ds.field("sequence_number", &self.sequence_number());
        ds.field("event_type", &self.event_type());
        match self.event_type() {
            MetadataEvent::AddData => {
                if let Some(x) = self.event_as_add_data() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::ExecuteQuery => {
                if let Some(x) = self.event_as_execute_query() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::Seed => {
                if let Some(x) = self.event_as_seed() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetPollingSource => {
                if let Some(x) = self.event_as_set_polling_source() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetTransform => {
                if let Some(x) = self.event_as_set_transform() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetVocab => {
                if let Some(x) = self.event_as_set_vocab() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetWatermark => {
                if let Some(x) = self.event_as_set_watermark() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetAttachments => {
                if let Some(x) = self.event_as_set_attachments() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetInfo => {
                if let Some(x) = self.event_as_set_info() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            MetadataEvent::SetLicense => {
                if let Some(x) = self.event_as_set_license() {
                    ds.field("event", &x)
                } else {
                    ds.field(
                        "event",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("event", &x)
            }
        };
        ds.finish()
    }
}
